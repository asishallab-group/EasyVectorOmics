var tipuesearch = {"pages":[{"title":" TensorOmics ","text":"TensorOmics Developer Info TensorOmics Developers","tags":"home","url":"index.html"},{"title":"bst_range_query_r – TensorOmics","text":"subroutine bst_range_query_r(values, sorted_indices, num_values, lower_bound, upper_bound, output_indices, num_matches, ierr) Uses binary_search_tree tox_errors iso_fortran_env Wrapper for getting range query usable by R Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array integer(kind=int32), intent(in) :: sorted_indices (num_values) Permutation index array integer(kind=int32), intent(in) :: num_values Number of elements real(kind=real64), intent(in) :: lower_bound Lower bound of range real(kind=real64), intent(in) :: upper_bound Upper bound of range integer(kind=int32), intent(out) :: output_indices (num_values) Output array of matching indices integer(kind=int32), intent(out) :: num_matches Number of matches found integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/bst_range_query_r.html"},{"title":"build_bst_index_r – TensorOmics","text":"subroutine build_bst_index_r(values, num_values, sorted_indices, left_stack, right_stack, ierr) Uses binary_search_tree tox_errors iso_fortran_env Wrapper for building BST index usable by R Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array integer(kind=int32), intent(in) :: num_values Number of elements integer(kind=int32), intent(out) :: sorted_indices (num_values) Output permutation index integer(kind=int32), intent(out) :: left_stack (num_values) Manual stack for left indices integer(kind=int32), intent(out) :: right_stack (num_values) Manual stack for right indices integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_bst_index_r.html"},{"title":"bst_range_query_C – TensorOmics","text":"subroutine bst_range_query_C(values, sorted_indices, num_values, lower_bound, upper_bound, output_indices, num_matches, ierr) bind(C, name='bst_range_query_C') Uses binary_search_tree tox_errors iso_c_binding Wrapper using C for getting range query usable by python Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: values (num_values) Input real array (C-style) integer(kind=c_int), intent(in) :: sorted_indices (num_values) Permutation index array (C-style) integer(kind=c_int), value :: num_values Number of elements real(kind=c_double), value :: lower_bound Lower bound of range real(kind=c_double), value :: upper_bound Upper bound of range integer(kind=c_int), intent(out) :: output_indices (num_values) Output array (C-style) integer(kind=c_int), intent(out) :: num_matches Number of matches found integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/bst_range_query_c.html"},{"title":"build_bst_index_C – TensorOmics","text":"subroutine build_bst_index_C(values, num_values, sorted_indices, left_stack, right_stack, ierr) bind(C, name='build_bst_index_C') Uses binary_search_tree tox_errors iso_c_binding Wrapper using C for building BST index usable by python Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: values (num_values) Input real array (C-style) integer(kind=c_int), value :: num_values Number of elements integer(kind=c_int), intent(out) :: sorted_indices (num_values) Output permutation index (C-style) integer(kind=c_int), intent(out) :: left_stack (num_values) Manual stack for left indices integer(kind=c_int), intent(out) :: right_stack (num_values) Manual stack for right indices integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/build_bst_index_c.html"},{"title":"serialize_real_flat_r – TensorOmics","text":"subroutine serialize_real_flat_r(arr, array_size, dims, ndim, filename_ascii, fn_len, ierr) Uses serialize_real tox_errors iso_fortran_env array_utils Serialize a flat integer array with specified dimensions and number of dimensions to a binary file.\nR can not pass a multidimensional array directly, so we use a flat array and dimensions. Therefore, exposing serialize_int_*d to R is not needed. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (array_size) Flat real array to serialize integer(kind=int32), intent(in) :: array_size Size of the flat array integer(kind=int32), intent(in) :: dims (ndim) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions integer(kind=int32), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=int32), intent(in) :: fn_len length of the filename array integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/serialize_real_flat_r.html"},{"title":"serialize_real_nd_C – TensorOmics","text":"subroutine serialize_real_nd_C(arr, dims, ndim, filename_ascii, fn_len, ierr) bind(C, name=\"serialize_real_nd_C\") Uses serialize_real tox_errors array_utils iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name type(c_ptr), value :: arr Pointer to the flat real array integer(kind=c_int), intent(in) :: dims (ndim) Dimensions of the array integer(kind=c_int), value :: ndim Number of dimensions integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=c_int), value :: fn_len Length of the filename array integer(kind=c_int), intent(out) :: ierr","tags":"","url":"proc/serialize_real_nd_c.html"},{"title":"normalize_by_std_dev_r – TensorOmics","text":"subroutine normalize_by_std_dev_r(n_genes, n_tissues, input_matrix, output_matrix, ierr) Uses tox_normalization R/Fortran wrapper for normalization by standard deviation.\nProvides an interface for R (.Fortran) and Fortran code to call the normalization routine. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes,n_tissues) Input matrix (n_genes x n_tissues) real(kind=real64), intent(out) :: output_matrix (n_genes,n_tissues) Output normalized matrix (same shape as input) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/normalize_by_std_dev_r.html"},{"title":"normalize_by_std_dev_c – TensorOmics","text":"subroutine normalize_by_std_dev_c(n_genes, n_tissues, input_matrix, output_matrix, ierr) bind(C, name=\"normalize_by_std_dev_c\") Uses tox_normalization iso_c_binding C/Python wrapper for normalization by standard deviation.\nProvides a C/Python-compatible interface to the normalization routine. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_genes Number of genes (rows) integer(kind=c_int), value :: n_tissues Number of tissues (columns) real(kind=c_double), intent(in), target :: input_matrix (n_genes*n_tissues) Input matrix (flattened, n_genes * n_tissues) real(kind=c_double), intent(out), target :: output_matrix (n_genes*n_tissues) Output normalized matrix (flattened, same shape as input) integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/normalize_by_std_dev_c.html"},{"title":"quantile_normalization_r – TensorOmics","text":"subroutine quantile_normalization_r(n_genes, n_tissues, input_matrix, output_matrix, temp_col, rank_means, perm, stack_left, stack_right, max_stack, ierr) Uses tox_normalization R/Fortran wrapper for quantile normalization.\nProvides an interface for R (.Fortran) and Fortran code to call the quantile normalization routine. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes,n_tissues) Input matrix (n_genes x n_tissues) real(kind=real64), intent(out) :: output_matrix (n_genes,n_tissues) Output normalized matrix (same shape as input) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary vector for column sorting (size n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Preallocated vector to store rank means (size n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector (size n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Manual quicksort stack (size max_stack) integer(kind=int32), intent(out) :: stack_right (max_stack) Manual quicksort stack (size max_stack) integer(kind=int32), intent(in) :: max_stack Stack size for sorting integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/quantile_normalization_r.html"},{"title":"quantile_normalization_c – TensorOmics","text":"subroutine quantile_normalization_c(n_genes, n_tissues, input_matrix, output_matrix, temp_col, rank_means, perm, stack_left, stack_right, max_stack, ierr) bind(C, name=\"quantile_normalization_c\") Uses tox_normalization iso_c_binding C/Python wrapper for quantile normalization.\nProvides a C/Python-compatible interface to the quantile normalization routine. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Number of genes (rows) integer(kind=c_int), intent(in), value :: n_tissues Number of tissues (columns) real(kind=c_double), intent(in), target :: input_matrix (n_genes,n_tissues) Input matrix (n_genes x n_tissues) real(kind=c_double), intent(out), target :: output_matrix (n_genes,n_tissues) Output normalized matrix (same shape as input) real(kind=c_double), intent(out), target :: temp_col (n_genes) Temporary vector for column sorting (size n_genes) real(kind=c_double), intent(out), target :: rank_means (n_genes) Preallocated vector to store rank means (size n_genes) integer(kind=c_int), intent(out), target :: perm (n_genes) Permutation vector (size n_genes) integer(kind=c_int), intent(out), target :: stack_left (max_stack) Manual quicksort stack (size max_stack) integer(kind=c_int), intent(out), target :: stack_right (max_stack) Manual quicksort stack (size max_stack) integer(kind=c_int), intent(in), value :: max_stack Stack size for sorting integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/quantile_normalization_c.html"},{"title":"log2_transformation_r – TensorOmics","text":"subroutine log2_transformation_r(n_genes, n_tissues, input_matrix, output_matrix, ierr) Uses tox_normalization R/Fortran wrapper for log2 transformation.\nProvides an interface for R (.Fortran) and Fortran code to call the log2 transformation routine.\nApplies log2(x+1) to each element of the input matrix. Arguments match R's .Fortran calling convention and expect flat arrays. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Input matrix (flattened, n_genes * n_tissues) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output matrix (flattened, same shape as input) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/log2_transformation_r.html"},{"title":"log2_transformation_c – TensorOmics","text":"subroutine log2_transformation_c(n_genes, n_tissues, input_matrix, output_matrix, ierr) bind(C, name=\"log2_transformation_c\") Uses tox_normalization iso_c_binding C/Python wrapper for log2 transformation.\nProvides a C/Python-compatible interface to the log2 transformation routine.\nExpects flat arrays, matching C calling conventions. Suitable for use with ctypes.\nApplies log2(x+1) to each element of the input matrix. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Number of genes (rows) integer(kind=c_int), intent(in), value :: n_tissues Number of tissues (columns) real(kind=c_double), intent(in), target :: input_matrix (n_genes*n_tissues) Input matrix (flattened, n_genes * n_tissues) real(kind=c_double), intent(out), target :: output_matrix (n_genes*n_tissues) Output matrix (flattened, same shape as input) integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/log2_transformation_c.html"},{"title":"calc_tiss_avg_r – TensorOmics","text":"subroutine calc_tiss_avg_r(n_gene, n_grps, group_s, group_c, input_matrix, output_matrix, ierr) Uses tox_normalization R/Fortran wrapper for tissue average calculation.\nProvides an interface for R (.Fortran) and Fortran code to call the tissue average calculation routine.\nComputes average expression per gene for each group of tissue replicates. Arguments match R's .Fortran calling convention. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_gene Number of genes (rows) integer(kind=int32), intent(in) :: n_grps Number of tissue groups integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each group (length: n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per group (length: n_grps) real(kind=real64), intent(in) :: input_matrix (n_gene*sum(group_c)) Input matrix (flattened, n_gene * sum(group_c)) real(kind=real64), intent(out) :: output_matrix (n_gene*n_grps) Output matrix (flattened, n_gene * n_grps) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/calc_tiss_avg_r.html"},{"title":"calc_tiss_avg_c – TensorOmics","text":"subroutine calc_tiss_avg_c(n_gene, n_grps, group_s, group_c, input_matrix, output_matrix, ierr) bind(C, name=\"calc_tiss_avg_c\") Uses tox_normalization iso_c_binding C/Python wrapper for tissue average calculation.\nProvides a C/Python-compatible interface to the tissue average calculation routine.\nSuitable for use with ctypes. Computes average expression per gene for each group of tissue replicates. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_gene Number of genes (rows) integer(kind=c_int), intent(in), value :: n_grps Number of tissue groups integer(kind=c_int), intent(in), target :: group_s (n_grps) Start column index for each group (length: n_grps) integer(kind=c_int), intent(in), target :: group_c (n_grps) Number of columns per group (length: n_grps) real(kind=c_double), intent(in), target :: input_matrix (n_gene*sum(group_c)) Input matrix (flattened, n_gene * sum(group_c)) real(kind=c_double), intent(out) :: output_matrix (n_gene*n_grps) Output matrix (flattened, n_gene * n_grps) integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/calc_tiss_avg_c.html"},{"title":"calc_fchange_r – TensorOmics","text":"subroutine calc_fchange_r(n_genes, n_cols, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ierr) Uses tox_normalization R/Fortran wrapper for fold change calculation.\nProvides an interface for R (.Fortran) and Fortran code to call the fold change calculation routine.\nComputes log2 fold changes between condition and control columns for all genes. Arguments match R's .Fortran calling convention. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_cols Number of columns in the input matrix integer(kind=int32), intent(in) :: n_pairs Number of control-condition pairs integer(kind=int32), intent(in) :: control_cols (n_pairs) Control column indices (length n_pairs) integer(kind=int32), intent(in) :: cond_cols (n_pairs) Condition column indices (length n_pairs) real(kind=real64), intent(in) :: i_matrix (n_genes*n_cols) Input matrix (flattened, n_genes * n_cols) real(kind=real64), intent(out) :: o_matrix (n_genes*n_pairs) Output matrix for fold changes (flattened, n_genes * n_pairs) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/calc_fchange_r.html"},{"title":"calc_fchange_c – TensorOmics","text":"subroutine calc_fchange_c(n_genes, n_cols, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ierr) bind(C, name=\"calc_fchange_c\") Uses tox_normalization iso_c_binding C/Python wrapper for fold change calculation.\nProvides a C/Python-compatible interface to the fold change calculation routine.\nSuitable for use with ctypes. Computes log2 fold changes between condition and control columns for all genes. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Number of genes (rows) integer(kind=c_int), intent(in), value :: n_cols Number of columns in the input matrix integer(kind=c_int), intent(in), value :: n_pairs Number of control-condition pairs integer(kind=c_int), intent(in), target :: control_cols (n_pairs) Control column indices (length n_pairs) integer(kind=c_int), intent(in), target :: cond_cols (n_pairs) Condition column indices (length n_pairs) real(kind=c_double), intent(in), target :: i_matrix (n_genes*n_cols) Input matrix (flattened, n_genes * n_cols) real(kind=c_double), intent(out) :: o_matrix (n_genes*n_pairs) Output matrix for fold changes (flattened, n_genes * n_pairs) integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/calc_fchange_c.html"},{"title":"normalization_pipeline_r – TensorOmics","text":"subroutine normalization_pipeline_r(n_genes, n_tissues, input_matrix, buf_stddev, buf_quant, buf_avg, buf_log, temp_col, rank_means, perm, stack_left, stack_right, max_stack, group_s, group_c, n_grps, ierr) Uses tox_normalization R/Fortran wrapper for normalization pipeline.\nProvides an interface for R (.Fortran) and Fortran code to call the normalization pipeline routine.\nPerforms: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation.\nFinal result is in buf_log. If fold change is needed, call calc_fchange separately. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (n_genes * n_tissues), column-major real(kind=real64), intent(out) :: buf_stddev (n_genes*n_tissues) Buffer for std dev normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_quant (n_genes*n_tissues) Buffer for quantile normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_avg (n_genes*n_grps) Buffer for replicate averaging (n_genes * n_grps) real(kind=real64), intent(out) :: buf_log (n_genes*n_grps) Buffer for log2(x+1) transformation (n_genes * n_grps) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary column vector for sorting (n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Buffer for rank means (n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector for sorting (n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Left stack for quicksort (max_stack) integer(kind=int32), intent(out) :: stack_right (max_stack) Right stack for quicksort (max_stack) integer(kind=int32), intent(in) :: max_stack Stack size for quicksort integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each replicate group (n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per replicate group (n_grps) integer(kind=int32), intent(in) :: n_grps Number of replicate groups integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/normalization_pipeline_r.html"},{"title":"normalization_pipeline_c – TensorOmics","text":"subroutine normalization_pipeline_c(n_genes, n_tissues, input_matrix, buf_stddev, buf_quant, buf_avg, buf_log, temp_col, rank_means, perm, stack_left, stack_right, max_stack, group_s, group_c, n_grps, ierr) bind(C, name=\"normalization_pipeline_c\") Uses tox_normalization iso_c_binding C/Python wrapper for normalization pipeline.\nProvides a C/Python-compatible interface to the normalization pipeline routine.\nSuitable for use with ctypes. Performs: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation.\nFinal result is in buf_log. If fold change is needed, call calc_fchange separately. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Number of genes (rows) integer(kind=c_int), intent(in), value :: n_tissues Number of tissues (columns) real(kind=c_double), intent(in), target :: input_matrix (n_genes*n_tissues) Flattened input matrix (n_genes * n_tissues), column-major real(kind=c_double), intent(out), target :: buf_stddev (n_genes*n_tissues) Buffer for std dev normalization (n_genes * n_tissues) real(kind=c_double), intent(out), target :: buf_quant (n_genes*n_tissues) Buffer for quantile normalization (n_genes * n_tissues) real(kind=c_double), intent(out), target :: buf_avg (n_genes*n_grps) Buffer for replicate averaging (n_genes * n_grps) real(kind=c_double), intent(out), target :: buf_log (n_genes*n_grps) Buffer for log2(x+1) transformation (n_genes * n_grps) real(kind=c_double), intent(out), target :: temp_col (n_genes) Temporary column vector for sorting (n_genes) real(kind=c_double), intent(out), target :: rank_means (n_genes) Buffer for rank means (n_genes) integer(kind=c_int), intent(out), target :: perm (n_genes) Permutation vector for sorting (n_genes) integer(kind=c_int), intent(out), target :: stack_left (max_stack) Left stack for quicksort (max_stack) integer(kind=c_int), intent(out), target :: stack_right (max_stack) Right stack for quicksort (max_stack) integer(kind=c_int), intent(in), value :: max_stack Stack size for quicksort integer(kind=c_int), intent(in), target :: group_s (n_grps) Start column index for each replicate group (n_grps) integer(kind=c_int), intent(in), target :: group_c (n_grps) Number of columns per replicate group (n_grps) integer(kind=c_int), intent(in), value :: n_grps Number of replicate groups integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/normalization_pipeline_c.html"},{"title":"deserialize_char_flat_r – TensorOmics","text":"subroutine deserialize_char_flat_r(ascii_arr, arr_size, filename_ascii, fn_len, ierr) Uses char_deserialize_mod tox_errors iso_fortran_env array_utils Subroutine to deserialize a flat character array from a file and return it as an ASCII array callable by R Note The array is returned flat and needs to be reshaped in R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: ascii_arr (arr_size) Output array of ASCII characters, preallocated by R integer(kind=int32), intent(in) :: arr_size Size of the ASCII array integer(kind=int32), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=int32), intent(in) :: fn_len Length of the filename array integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_flat_r.html"},{"title":"deserialize_char_flat_C – TensorOmics","text":"subroutine deserialize_char_flat_C(ascii_arr, clen, total_array_size, filename_ascii, fn_len, ierr) bind(C, name=\"deserialize_char_flat_C\") Uses char_deserialize_mod tox_errors array_utils iso_c_binding iso_fortran_env C binding for the subroutine to deserialize a flat character array from a file Note The array is returned flat and needs to be reshaped in C/python Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: ascii_arr (clen*total_array_size) Output array of ASCII characters, preallocated by C/Python (flat) integer(kind=c_int), value :: clen Length of each character string integer(kind=c_int), value :: total_array_size Total size of the ASCII array integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=c_int), value :: fn_len Length of the filename array integer(kind=c_int), intent(out) :: ierr error code","tags":"","url":"proc/deserialize_char_flat_c.html"},{"title":"serialize_int_flat_r – TensorOmics","text":"subroutine serialize_int_flat_r(arr, array_size, dims, ndim, filename_ascii, fn_len, ierr) Uses tox_errors iso_fortran_env serialize_int array_utils Serialize a flat integer array with specified dimensions and number of dimensions to a binary file.\nR can not pass a multidimensional array directly, so we use a flat array and dimensions. Therefore, exposing serialize_int_*d to R is not needed. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (array_size) Flat integer array to serialize integer(kind=int32), intent(in) :: array_size Size of the flat array integer(kind=int32), intent(in) :: dims (ndim) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions integer(kind=int32), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=int32), intent(in) :: fn_len Length of the filename array integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/serialize_int_flat_r.html"},{"title":"serialize_int_nd_C – TensorOmics","text":"subroutine serialize_int_nd_C(arr, dims, ndim, filename_ascii, fn_len, ierr) bind(C, name=\"serialize_int_nd_C\") Uses tox_errors array_utils serialize_int iso_c_binding iso_fortran_env C binding for the subroutine to serialize a flat integer array to a binary file. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: arr Pointer to the flat integer array integer(kind=c_int), intent(in) :: dims (ndim) Dimensions of the array integer(kind=c_int), value :: ndim Number of dimensions integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=c_int), value :: fn_len Length of the filename array integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/serialize_int_nd_c.html"},{"title":"relative_axes_changes_from_shift_vector_r – TensorOmics","text":"subroutine relative_axes_changes_from_shift_vector_r(vec, n_axes, contributions, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized shift vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Relative axis contributions (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_changes_from_shift_vector_r.html"},{"title":"relative_axes_changes_from_shift_vector_c – TensorOmics","text":"subroutine relative_axes_changes_from_shift_vector_c(vec, n_axes, contributions, ierr) bind(C, name=\"relative_axes_changes_from_shift_vector_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(n_axes) :: vec RAP-projected and normalized shift vector integer(kind=c_int), intent(in), value :: n_axes Number of axes real(kind=c_double), intent(out), dimension(n_axes) :: contributions Relative axis contributions (output), values in [0,1], sum to 1 integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_changes_from_shift_vector_c.html"},{"title":"relative_axes_expression_from_expression_vector_r – TensorOmics","text":"subroutine relative_axes_expression_from_expression_vector_r(vec, n_axes, contributions, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized expression vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Relative axis contributions (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_expression_from_expression_vector_r.html"},{"title":"relative_axes_expression_from_expression_vector_c – TensorOmics","text":"subroutine relative_axes_expression_from_expression_vector_c(vec, n_axes, contributions, ierr) bind(C, name=\"relative_axes_expression_from_expression_vector_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(n_axes) :: vec RAP-projected and normalized expression vector integer(kind=c_int), intent(in), value :: n_axes Number of axes real(kind=c_double), intent(out), dimension(n_axes) :: contributions Relative axis contributions (output), values in [0,1], sum to 1 integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_expression_from_expression_vector_c.html"},{"title":"omics_vector_RAP_projection_r – TensorOmics","text":"subroutine omics_vector_RAP_projection_r(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes, n_vecs) :: vecs matrix with expression vectors integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/omics_vector_rap_projection_r.html"},{"title":"omics_vector_RAP_projection_c – TensorOmics","text":"subroutine omics_vector_RAP_projection_c(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) bind(C, name=\"omics_vector_RAP_projection_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(n_axes, n_vecs) :: vecs matrix with expression vectors integer(kind=c_int), intent(in), value :: n_axes number of axes integer(kind=c_int), intent(in), value :: n_vecs number of vectors per axis integer(kind=c_int), intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=c_int), intent(in), value :: n_selected_vecs count of .true. values in vecs_selection_mask integer(kind=c_int), intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=c_int), intent(in), value :: n_selected_axes count of .true. values in axes_selection_mask real(kind=c_double), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/omics_vector_rap_projection_c.html"},{"title":"omics_field_RAP_projection_r – TensorOmics","text":"subroutine omics_field_RAP_projection_r(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes, n_vecs) :: vecs matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/omics_field_rap_projection_r.html"},{"title":"omics_field_RAP_projection_c – TensorOmics","text":"subroutine omics_field_RAP_projection_c(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) bind(C, name=\"omics_field_RAP_projection_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(2 * n_axes, n_vecs) :: vecs matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer(kind=c_int), intent(in), value :: n_axes number of axes integer(kind=c_int), intent(in), value :: n_vecs number of vectors per axis integer(kind=c_int), intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=c_int), intent(in), value :: n_selected_vecs count of .true. values in vecs_selection_mask integer(kind=c_int), intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=c_int), intent(in), value :: n_selected_axes count of .true. values in axes_selection_mask real(kind=c_double), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/omics_field_rap_projection_c.html"},{"title":"clock_hand_angle_between_vectors_r – TensorOmics","text":"subroutine clock_hand_angle_between_vectors_r(v1, v2, n_dims, signed_angle, selected_axes_for_signed, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims) :: v1 First normalized vector in RAP space real(kind=real64), intent(in), dimension(n_dims) :: v2 Second normalized vector in RAP space integer(kind=int32), intent(in) :: n_dims Dimension of both vectors real(kind=real64), intent(out) :: signed_angle Signed angle between vectors in radians [-π, π] integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angle_between_vectors_r.html"},{"title":"clock_hand_angle_between_vectors_c – TensorOmics","text":"subroutine clock_hand_angle_between_vectors_c(v1, v2, n_dims, signed_angle, selected_axes_for_signed, ierr) bind(C, name=\"clock_hand_angle_between_vectors_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(n_dims) :: v1 First normalized vector in RAP space real(kind=c_double), intent(in), dimension(n_dims) :: v2 Second normalized vector in RAP space integer(kind=c_int), intent(in), value :: n_dims Dimension of both vectors real(kind=c_double), intent(out) :: signed_angle Signed angle between vectors in radians [-π, π] integer(kind=c_int), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angle_between_vectors_c.html"},{"title":"clock_hand_angles_for_shift_vectors_r – TensorOmics","text":"subroutine clock_hand_angles_for_shift_vectors_r(origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles, ierr) Uses relative_axis_plane_tools iso_fortran_env Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: origins First set of RAP-projected, normalized vectors (e.g. expression centroids) real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: targets Second set of RAP-projected, normalized vectors (e.g. paralogs) integer(kind=int32), intent(in) :: n_dims Dimension of each vector in RAP space integer(kind=int32), intent(in) :: n_vecs Number of vector pairs logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vector pairs where angle should be computed integer(kind=int32), intent(in) :: n_selected_vecs Count of .true. values in vecs_selection_mask integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real(kind=real64), intent(out), dimension(n_selected_vecs) :: signed_angles Signed rotation angles between vector pairs in radians [-π, π] integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angles_for_shift_vectors_r.html"},{"title":"clock_hand_angles_for_shift_vectors_c – TensorOmics","text":"subroutine clock_hand_angles_for_shift_vectors_c(origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles, ierr) bind(C, name=\"clock_hand_angles_for_shift_vectors_c\") Uses relative_axis_plane_tools iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), dimension(n_dims, n_vecs) :: origins First set of RAP-projected, normalized vectors (e.g. expression centroids) real(kind=c_double), intent(in), dimension(n_dims, n_vecs) :: targets Second set of RAP-projected, normalized vectors (e.g. paralogs) integer(kind=c_int), intent(in), value :: n_dims Dimension of each vector in RAP space integer(kind=c_int), intent(in), value :: n_vecs Number of vector pairs integer(kind=c_int), intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vector pairs where angle should be computed integer(kind=c_int), intent(in), value :: n_selected_vecs Count of .true. values in vecs_selection_mask integer(kind=c_int), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real(kind=c_double), intent(out), dimension(n_selected_vecs) :: signed_angles Signed rotation angles between vector pairs in radians [-π, π] integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angles_for_shift_vectors_c.html"},{"title":"compute_family_scaling_expert_r – TensorOmics","text":"subroutine compute_family_scaling_expert_r(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, family_distances, ierr) Uses iso_fortran_env tox_get_outliers R wrapper for compute_family_scaling (expert version with pre-allocated arrays).\nCalls compute_family_scaling with standard Fortran types for R interface.\nThis version requires pre-allocated work arrays for maximum performance and control. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(inout) :: perm_tmp (n_genes) Permutation array for sorting gene distances integer(kind=int32), intent(inout) :: stack_left_tmp (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right_tmp (n_genes) Stack array for right indices during sorting real(kind=real64), intent(out) :: family_distances (n_genes) Pre-allocated work array for family distances (dimension n_genes) integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling_expert_r.html"},{"title":"compute_family_scaling_r – TensorOmics","text":"subroutine compute_family_scaling_r(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, ierr) Uses iso_fortran_env tox_get_outliers R wrapper for compute_family_scaling (main version with automatic allocation).\nCalls compute_family_scaling_alloc with standard Fortran types for R interface.\nThis is the recommended version for most users as it handles memory allocation automatically. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling_r.html"},{"title":"compute_rdi_r – TensorOmics","text":"subroutine compute_rdi_r(n_genes, n_families, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right) Uses iso_fortran_env tox_get_outliers R wrapper for compute_rdi.\nCalls compute_rdi with standard Fortran types for R interface.\nOutputs both unsorted and sorted RDI, permutation, and sorting workspace arrays for downstream use. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(in) :: dscale (n_families) Array of scaling factors for each family real(kind=real64), intent(out) :: rdi (n_genes) Output array of RDI values for each gene real(kind=real64), intent(inout) :: sorted_rdi (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes, should be pre-initialized with 1:n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for sorting (dimension n_genes)","tags":"","url":"proc/compute_rdi_r.html"},{"title":"identify_outliers_r – TensorOmics","text":"subroutine identify_outliers_r(n_genes, rdi, sorted_rdi, is_outlier, threshold, percentile) Uses iso_fortran_env tox_get_outliers R wrapper for identify_outliers.\nCalls identify_outliers with standard Fortran types for R interface. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes real(kind=real64), intent(in) :: rdi (n_genes) Array of RDI values for each gene real(kind=real64), intent(in) :: sorted_rdi (n_genes) Sorted RDI array (must be filtered to remove negatives and sorted in ascending order before calling) logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(out) :: threshold Output threshold value used for detection real(kind=real64), intent(in) :: percentile Percentile threshold (default: 95 for top 5%)","tags":"","url":"proc/identify_outliers_r.html"},{"title":"detect_outliers_r – TensorOmics","text":"subroutine detect_outliers_r(n_genes, n_families, distances, gene_to_fam, work_array, perm, stack_left, stack_right, is_outlier, loess_x, loess_y, loess_n, ierr, percentile) Uses iso_fortran_env tox_get_outliers R wrapper for detect_outliers.\nCalls detect_outliers with standard Fortran types for R interface. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(inout) :: work_array (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for right indices during sorting logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: loess_n (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices real(kind=real64), intent(in), optional :: percentile (optional) Percentile threshold for outlier detection (default: 95)","tags":"","url":"proc/detect_outliers_r.html"},{"title":"compute_family_scaling_expert_c – TensorOmics","text":"subroutine compute_family_scaling_expert_c(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, family_distances, ierr) bind(C, name=\"compute_family_scaling_expert_c\") Uses tox_get_outliers iso_c_binding C wrapper for compute_family_scaling (expert version with pre-allocated arrays).\nCalls compute_family_scaling with C-compatible types for external interface.\nThis version requires pre-allocated work arrays for maximum performance and control. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of genes real(kind=c_double), intent(in), target :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=c_int), intent(in), target :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=c_double), intent(out), target :: dscale (n_families) Output: array of scaling factors per family real(kind=c_double), intent(inout), target :: loess_x (n_families) Reference x-coordinates for LOESS real(kind=c_double), intent(inout), target :: loess_y (n_families) Reference y-coordinates for LOESS integer(kind=c_int), intent(inout), target :: indices_used (n_families) Indices of reference points used for smoothing integer(kind=c_int), intent(inout), target :: perm_tmp (n_genes) Permutation array for sorting gene distances integer(kind=c_int), intent(inout), target :: stack_left_tmp (n_genes) Stack array for left indices during sorting integer(kind=c_int), intent(inout), target :: stack_right_tmp (n_genes) Stack array for right indices during sorting real(kind=c_double), intent(out), target :: family_distances (n_genes) Pre-allocated work array for family distances (dimension n_genes) integer(kind=c_int), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling_expert_c.html"},{"title":"compute_family_scaling_c – TensorOmics","text":"subroutine compute_family_scaling_c(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, ierr) bind(C, name=\"compute_family_scaling_c\") Uses tox_get_outliers iso_c_binding C wrapper for compute_family_scaling (main version with automatic allocation).\nCalls compute_family_scaling_alloc with C-compatible types for external interface.\nThis is the recommended version for most users as it handles memory allocation automatically. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of genes real(kind=c_double), intent(in), target :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=c_int), intent(in), target :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=c_double), intent(out), target :: dscale (n_families) Output: array of scaling factors per family real(kind=c_double), intent(inout), target :: loess_x (n_families) Reference x-coordinates for LOESS real(kind=c_double), intent(inout), target :: loess_y (n_families) Reference y-coordinates for LOESS integer(kind=c_int), intent(inout), target :: indices_used (n_families) Indices of reference points used for smoothing integer(kind=c_int), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling_c.html"},{"title":"compute_rdi_c – TensorOmics","text":"subroutine compute_rdi_c(n_genes, n_families, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right) bind(C, name=\"compute_rdi_c\") Uses tox_get_outliers iso_c_binding C wrapper for compute_rdi.\nCalls compute_rdi with C-compatible types for external interface.\nOutputs both unsorted and sorted RDI, permutation, and sorting workspace arrays for downstream use. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of genes real(kind=c_double), intent(in), target :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=c_int), intent(in), target :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=c_double), intent(in), target :: dscale (n_families) Array of scaling factors for each family real(kind=c_double), intent(out), target :: rdi (n_genes) Output array of RDI values for each gene (unsorted) real(kind=c_double), intent(out), target :: sorted_rdi (n_genes) Output array of sorted RDI values (filtered, sorted) integer(kind=c_int), intent(out), target :: perm (n_genes) Output permutation array for sorting (dimension n_genes) integer(kind=c_int), intent(out), target :: stack_left (n_genes) Output stack array for left indices during sorting integer(kind=c_int), intent(out), target :: stack_right (n_genes) Output stack array for right indices during sorting","tags":"","url":"proc/compute_rdi_c.html"},{"title":"identify_outliers_c – TensorOmics","text":"subroutine identify_outliers_c(n_genes, rdi, sorted_rdi, is_outlier_int, threshold, percentile) bind(C, name=\"identify_outliers_c\") Uses tox_get_outliers iso_c_binding C wrapper for identify_outliers.\nCalls identify_outliers with C-compatible types for external interface. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes real(kind=c_double), intent(in), target :: rdi (n_genes) Array of RDI values for each gene real(kind=c_double), intent(in), target :: sorted_rdi (n_genes) Sorted RDI array (must be sorted in ascending order before calling) integer(kind=c_int), intent(out), target :: is_outlier_int (n_genes) Output integer array indicating outliers (1=outlier, 0=not) real(kind=c_double), intent(out) :: threshold Output threshold value used for detection real(kind=c_double), intent(in), value :: percentile Percentile threshold for outlier detection","tags":"","url":"proc/identify_outliers_c.html"},{"title":"detect_outliers_c – TensorOmics","text":"subroutine detect_outliers_c(n_genes, n_families, distances, gene_to_fam, work_array, perm, stack_left, stack_right, is_outlier_int, loess_x, loess_y, loess_n, ierr, percentile) bind(C, name=\"detect_outliers_c\") Uses tox_get_outliers iso_c_binding C wrapper for detect_outliers.\nCalls detect_outliers with C-compatible types for external interface. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of genes real(kind=c_double), intent(in), target :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=c_int), intent(in), target :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=c_double), intent(inout), target :: work_array (n_genes) Work array for sorting (dimension n_genes) integer(kind=c_int), intent(inout), target :: perm (n_genes) Permutation array for sorting (dimension n_genes) integer(kind=c_int), intent(inout), target :: stack_left (n_genes) Stack array for left indices during sorting integer(kind=c_int), intent(inout), target :: stack_right (n_genes) Stack array for right indices during sorting integer(kind=c_int), intent(out), target :: is_outlier_int (n_genes) Output integer array indicating outliers (1=outlier, 0=not) real(kind=c_double), intent(inout), target :: loess_x (n_families) Reference x-coordinates for LOESS real(kind=c_double), intent(inout), target :: loess_y (n_families) Reference y-coordinates for LOESS integer(kind=c_int), intent(inout), target :: loess_n (n_families) Indices of reference points used for smoothing integer(kind=c_int), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices real(kind=c_double), intent(in), value :: percentile Percentile threshold for outlier detection","tags":"","url":"proc/detect_outliers_c.html"},{"title":"euclidean_distance_r – TensorOmics","text":"subroutine euclidean_distance_r(vec1, vec2, d, result) Uses tox_euclidean_distance R wrapper for euclidean_distance.\nCalls euclidean_distance with standard Fortran types for R interface. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vec1 (d) First expression vector real(kind=real64), intent(in) :: vec2 (d) Second expression vector integer(kind=int32), intent(in) :: d Dimension of both vectors real(kind=real64), intent(out) :: result Output scalar distance","tags":"","url":"proc/euclidean_distance_r.html"},{"title":"euclidean_distance_c – TensorOmics","text":"subroutine euclidean_distance_c(vec1, vec2, d, result) bind(C, name=\"euclidean_distance_c\") Uses tox_euclidean_distance iso_c_binding C wrapper for euclidean_distance.\nExposes euclidean_distance to C via iso_c_binding types. Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), target :: vec1 (d) First expression vector real(kind=c_double), intent(in), target :: vec2 (d) Second expression vector integer(kind=c_int), intent(in), value :: d Dimension of both vectors real(kind=c_double), intent(out) :: result Output scalar distance","tags":"","url":"proc/euclidean_distance_c.html"},{"title":"distance_to_centroid_r – TensorOmics","text":"subroutine distance_to_centroid_r(n_genes, n_families, genes, centroids, gene_to_fam, distances, d) Uses tox_euclidean_distance R wrapper for distance_to_centroid.\nCalls distance_to_centroid with standard Fortran types for R interface. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: genes (d,n_genes) Gene expression matrix (d × n_genes), column-major real(kind=real64), intent(in) :: centroids (d,n_families) Family centroid matrix (d × n_families), column-major integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(out) :: distances (n_genes) Output distances array integer(kind=int32), intent(in) :: d Expression vector dimension","tags":"","url":"proc/distance_to_centroid_r.html"},{"title":"distance_to_centroid_c – TensorOmics","text":"subroutine distance_to_centroid_c(n_genes, n_families, genes, centroids, gene_to_fam, distances, d) bind(C, name=\"distance_to_centroid_c\") Uses tox_euclidean_distance iso_c_binding C wrapper for distance_to_centroid.\nExposes distance_to_centroid to C via iso_c_binding types. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of gene families real(kind=c_double), intent(in), target :: genes (d,n_genes) Gene expression matrix (d × n_genes), column-major real(kind=c_double), intent(in), target :: centroids (d,n_genes) Family centroid matrix (d × n_families), column-major integer(kind=c_int), intent(in), target :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=c_double), intent(out), target :: distances (n_genes) Output distances array integer(kind=c_int), intent(in), value :: d Expression vector dimension","tags":"","url":"proc/distance_to_centroid_c.html"},{"title":"compute_shift_vector_field_r – TensorOmics","text":"pure subroutine compute_shift_vector_field_r(d, n_genes, n_families, expression_vectors, family_centroids, gene_to_centroid, shift_vectors, ierr) Uses tox_shift_vectors R wrapper for compute_shift_vector_field Calls compute_shift_vector_field with standard Fortran types for R interface.\nWhen using these R wrapper functions, copies of the arrays will be created. No direct modification of the original R objects occurs.. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: d Expression vector dimension integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of families real(kind=real64), intent(in) :: expression_vectors (d,n_genes) Gene expression matrix (d × n_genes) real(kind=real64), intent(in) :: family_centroids (d,n_families) Family centroid matrix (d × n_families) integer(kind=int32), intent(in) :: gene_to_centroid (n_genes) Mapping from genes to family centroids to genes of expression_vectors -> family_centroids(:, gene_to_centroid(n)) returns the family centroid of expression_vectors(:,n) real(kind=real64), intent(out) :: shift_vectors (2*d,n_genes) Output, real matrix array, size = 2d x n_genes , stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/compute_shift_vector_field_r.html"},{"title":"compute_shift_vector_field_c – TensorOmics","text":"pure subroutine compute_shift_vector_field_c(d, n_genes, n_families, expression_vectors, family_centroids, gene_to_centroid, shift_vectors, ierr) bind(C, name=\"compute_shift_vector_field_c\") Uses tox_shift_vectors iso_c_binding C wrapper for compute_shift_vector_field .\nExposes compute_shift_vector_field to C via iso_c_binding types with explicit dimensions.\nWhen using these C wrapper functions, no copies of the arrays will be created. The Fortran routine will operate directly on the memory provided by the caller. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: d Expression vector dimension integer(kind=c_int), intent(in), value :: n_genes Total number of genes integer(kind=c_int), intent(in), value :: n_families Total number of families real(kind=c_double), intent(in), target :: expression_vectors (d,n_genes) Gene expression matrix (d × n_genes) real(kind=c_double), intent(in), target :: family_centroids (d,n_families) Family centroid matrix (d × n_families) integer(kind=c_int), intent(in), target :: gene_to_centroid (n_genes) Mapping from genes to families (family IDs for each gene in expression_vectors ) real(kind=c_double), intent(out), target :: shift_vectors (2*d,n_genes) Output, real matrix array, size = 2d x n_genes , stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d integer(kind=c_int), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/compute_shift_vector_field_c.html"},{"title":"compute_tissue_versatility_r – TensorOmics","text":"pure subroutine compute_tissue_versatility_r(n_axes, n_vectors, expression_vectors, exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, tissue_versatilities, tissue_angles_deg, ierr) Uses avmod R wrapper for compute_tissue_versatility.\nCalls compute_tissue_versatility with standard Fortran types for R interface. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions) integer(kind=int32), intent(in) :: n_vectors Number of expression vectors (genes) real(kind=real64), intent(in) :: expression_vectors (n_axes,n_vectors) 2D array (n_axes, n_vectors), each column is a gene expression vector logical, intent(in) :: exp_vecs_selection_index (n_vectors) Logical array (n_vectors), .TRUE. for vectors to process integer(kind=int32), intent(in) :: n_selected_vectors Number of selected expression vectors (count of .TRUE. in exp_vecs_selection_index) logical, intent(in) :: axes_selection (n_axes) Logical array (n_axes), .TRUE. for axes to include in calculation integer(kind=int32), intent(in) :: n_selected_axes Number of selected axes (count of .TRUE. in axes_selection) real(kind=real64), intent(out) :: tissue_versatilities (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities real(kind=real64), intent(out) :: tissue_angles_deg (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated angles in degrees integer(kind=int32), intent(out) :: ierr Error code: 0 = success, non-zero = error","tags":"","url":"proc/compute_tissue_versatility_r.html"},{"title":"compute_tissue_versatility_c – TensorOmics","text":"pure subroutine compute_tissue_versatility_c(n_axes, n_vectors, expression_vectors, exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, tissue_versatilities, tissue_angles_deg, ierr) bind(C, name=\"compute_tissue_versatility_c\") Uses avmod iso_c_binding C wrapper for compute_tissue_versatility.\nExposes compute_tissue_versatility to C via iso_c_binding types with explicit dimensions. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_axes Number of axes (tissues/dimensions) integer(kind=c_int), intent(in), value :: n_vectors Number of expression vectors (genes) real(kind=c_double), intent(in), target :: expression_vectors (n_axes,n_vectors) 2D array (n_axes, n_vectors), each column is a gene expression vector (column-major) integer(kind=c_int), intent(in), target :: exp_vecs_selection_index (n_vectors) Integer array (n_vectors), 0/1 values. 0=not selected, 1=selected. Interpreted as logical internally. integer(kind=c_int), intent(in), value :: n_selected_vectors Number of selected expression vectors (count of 1s in exp_vecs_selection_index) integer(kind=c_int), intent(in), target :: axes_selection (n_axes) Integer array (n_axes), 0/1 values. 0=not selected, 1=selected. Interpreted as logical internally. integer(kind=c_int), intent(in), value :: n_selected_axes Number of selected axes (count of 1s in axes_selection) real(kind=c_double), intent(out), target :: tissue_versatilities (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities for selected vectors real(kind=c_double), intent(out), target :: tissue_angles_deg (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated angles in degrees for selected vectors integer(kind=c_int), intent(out) :: ierr Error code: 0 = success, non-zero = error","tags":"","url":"proc/compute_tissue_versatility_c.html"},{"title":"loess_smooth_2d_r – TensorOmics","text":"subroutine loess_smooth_2d_r(n_total, n_target, x_ref, y_ref, indices_used, n_used, x_query, kernel_sigma, kernel_cutoff, y_out, ierr) Uses f42_utils iso_fortran_env R wrapper for loess_smooth_2d.\nDirect wrapper - user must pre-filter indices in R before calling. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_total Total number of reference points. integer(kind=int32), intent(in) :: n_target Number of target points to smooth. real(kind=real64), intent(in) :: x_ref (n_total) Reference x-coordinates. real(kind=real64), intent(in) :: y_ref (n_total) Reference y-coordinates (length n_total). integer(kind=int32), intent(in) :: indices_used (n_used) Indices of reference points used for smoothing (pre-filtered). integer(kind=int32), intent(in) :: n_used Number of indices actually used for smoothing. real(kind=real64), intent(in) :: x_query (n_target) Target x-coordinates to smooth. real(kind=real64), intent(in) :: kernel_sigma Bandwidth parameter for the kernel. real(kind=real64), intent(in) :: kernel_cutoff Cutoff for the kernel. real(kind=real64), intent(out) :: y_out (n_target) Output smoothed values (length n_target). integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"proc/loess_smooth_2d_r.html"},{"title":"which_c – TensorOmics","text":"subroutine which_c(mask, n, idx_out, m_max, m_out, ierr) bind(C, name=\"which_c\") Uses f42_utils iso_fortran_env iso_c_binding C wrapper for which.\nConverts integer mask to logical and calls which. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: mask (n) Integer mask array (0/1 values). integer(kind=c_int), intent(in), value :: n Size of the mask. integer(kind=c_int), intent(out) :: idx_out (m_max) Output array for indices of true values. integer(kind=c_int), intent(in), value :: m_max Maximum size of idx_out. integer(kind=c_int), intent(out) :: m_out Actual size of idx_out (number of true values found). integer(kind=c_int), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"proc/which_c.html"},{"title":"loess_smooth_2d_c – TensorOmics","text":"subroutine loess_smooth_2d_c(n_total, n_target, x_ref, y_ref, indices_used, n_used, x_query, kernel_sigma, kernel_cutoff, y_out, ierr) bind(C, name=\"loess_smooth_2d_c\") Uses f42_utils iso_fortran_env iso_c_binding C wrapper for loess_smooth_2d.\nDirect wrapper - user must pre-filter indices in C before calling. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n_total Total number of reference points. integer(kind=c_int), intent(in), value :: n_target Number of target points to smooth. real(kind=c_double), intent(in) :: x_ref (n_total) Reference x-coordinates. real(kind=c_double), intent(in) :: y_ref (n_total) Reference y-coordinates (length n_total). integer(kind=c_int), intent(in) :: indices_used (n_used) Indices of reference points used for smoothing (pre-filtered). integer(kind=c_int), intent(in), value :: n_used Number of indices actually used for smoothing. real(kind=c_double), intent(in) :: x_query (n_target) Target x-coordinates to smooth. real(kind=c_double), intent(in), value :: kernel_sigma Bandwidth parameter for the kernel. real(kind=c_double), intent(in), value :: kernel_cutoff Cutoff for the kernel. real(kind=c_double), intent(out) :: y_out (n_target) Output smoothed values (length n_target). integer(kind=c_int), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"proc/loess_smooth_2d_c.html"},{"title":"get_array_metadata_r – TensorOmics","text":"subroutine get_array_metadata_r(filename_ascii, fn_len, dims_out, dims_out_capacity, ndims, ierr, clen) Uses iso_fortran_env array_utils Subroutine to get the dimensions of an array file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=int32), intent(in) :: fn_len Length of the filename array integer(kind=int32), intent(out) :: dims_out (dims_out_capacity) Output array for dimensions integer(kind=int32), intent(in) :: dims_out_capacity integer(kind=int32), intent(out) :: ndims Output variable for the number of dimensions integer(kind=int32), intent(out) :: ierr Error code integer(kind=int32), intent(out), optional :: clen Character length (only for character arrays)","tags":"","url":"proc/get_array_metadata_r.html"},{"title":"get_array_metadata_C – TensorOmics","text":"subroutine get_array_metadata_C(filename_ascii, fn_len, dims_out, dims_out_capacity, ndims, ierr, clen) bind(C, name=\"get_array_metadata_C\") Uses array_utils iso_fortran_env iso_c_binding C binding for the subroutine to get the dimensions of an array file Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=c_int), value :: fn_len Length of the filename array integer(kind=c_int), intent(out) :: dims_out (dims_out_capacity) Output array for dimensions integer(kind=c_int), intent(in) :: dims_out_capacity integer(kind=c_int), intent(out) :: ndims Output variable for the number of dimensions integer(kind=c_int), intent(out) :: ierr Error code integer(kind=c_int), intent(out) :: clen Character length (only for character arrays)","tags":"","url":"proc/get_array_metadata_c.html"},{"title":"serialize_char_flat_r – TensorOmics","text":"subroutine serialize_char_flat_r(ascii_arr, array_size, dims, ndim, clen, filename_ascii, fn_len, ierr) Uses serialize_char tox_errors iso_fortran_env array_utils serializes a flat character array to a binary file. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ascii_arr (clen,array_size) Flat character array in ASCII format integer(kind=int32), intent(in) :: array_size size of the input array integer(kind=int32), intent(in) :: dims (ndim) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions integer(kind=int32), intent(in) :: clen character length integer(kind=int32), intent(in) :: filename_ascii (fn_len) filename in ascii integer(kind=int32), intent(in) :: fn_len length of the filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_flat_r.html"},{"title":"serialize_char_flat_C – TensorOmics","text":"subroutine serialize_char_flat_C(ascii_ptr, dims, ndim, clen, filename_ascii, fn_len, ierr) bind(C, name=\"serialize_char_flat_C\") Uses tox_errors array_utils iso_c_binding serialize_char iso_fortran_env C binding for the subroutine to serialize a flat character array to a binary file. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ascii_ptr pointer to ascii array integer(kind=c_int), intent(in) :: dims (ndim) Dimensions of the array integer(kind=c_int), value :: ndim Number of dimensions integer(kind=c_int), value :: clen Character length integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Array of ASCII characters representing the filename integer(kind=c_int), value :: fn_len Length of the filename array integer(kind=c_int), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_flat_c.html"},{"title":"build_kd_index_r – TensorOmics","text":"subroutine build_kd_index_r(points, num_dimensions, num_points, kd_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, ierr) Uses iso_fortran_env kd_tree R interface for building KD index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: points (num_dimensions,num_points) Input points integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_points Number of points integer(kind=int32), intent(out) :: kd_indices (num_points) Output indices integer(kind=int32), intent(in) :: dimension_order (num_dimensions) Dimension order integer(kind=int32), intent(out) :: workspace (num_points) Workspace real(kind=real64), intent(out) :: value_buffer (num_points) Value buffer integer(kind=int32), intent(out) :: permutation (num_points) Permutation array integer(kind=int32), intent(out) :: left_stack (num_points) Left stack integer(kind=int32), intent(out) :: right_stack (num_points) Right stack integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_kd_index_r.html"},{"title":"build_spherical_kd_r – TensorOmics","text":"subroutine build_spherical_kd_r(vectors, num_dimensions, num_vectors, sphere_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, ierr) Uses iso_fortran_env kd_tree R interface for building spherical KD index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vectors (num_dimensions,num_vectors) Input vectors integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_vectors Number of vectors integer(kind=int32), intent(out) :: sphere_indices (num_vectors) Output indices integer(kind=int32), intent(out) :: dimension_order (num_dimensions) Dimension order integer(kind=int32), intent(out) :: workspace (num_vectors) Workspace real(kind=real64), intent(out) :: value_buffer (num_vectors) Value buffer integer(kind=int32), intent(out) :: permutation (num_vectors) Permutation array integer(kind=int32), intent(out) :: left_stack (num_vectors) Left stack integer(kind=int32), intent(out) :: right_stack (num_vectors) Right stack integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_spherical_kd_r.html"},{"title":"build_kd_index_C – TensorOmics","text":"subroutine build_kd_index_C(points, num_dimensions, num_points, kd_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, ierr) bind(C, name=\"build_kd_index_C\") Uses kd_tree iso_fortran_env iso_c_binding C interface for building KD index Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: points (num_dimensions,num_points) integer(kind=c_int), value :: num_dimensions integer(kind=c_int), value :: num_points integer(kind=c_int), intent(out) :: kd_indices (num_points) integer(kind=c_int), intent(in) :: dimension_order (num_dimensions) integer(kind=c_int), intent(out) :: workspace (num_points) real(kind=c_double), intent(out) :: value_buffer (num_points) integer(kind=c_int), intent(out) :: permutation (num_points) integer(kind=c_int), intent(out) :: left_stack (num_points) integer(kind=c_int), intent(out) :: right_stack (num_points) integer(kind=c_int), intent(out) :: ierr","tags":"","url":"proc/build_kd_index_c.html"},{"title":"deserialize_int_r – TensorOmics","text":"subroutine deserialize_int_r(flat_arr, arr_size, filename_ascii, fn_len, ierr) Uses tox_errors iso_fortran_env array_utils R interface for deserializing an integer array from a file Note The output array is handled and preallocated by R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: flat_arr (arr_size) array passed by R integer(kind=int32), intent(in) :: arr_size size of the array integer(kind=int32), intent(in) :: filename_ascii (fn_len) filename to read from integer(kind=int32), intent(in) :: fn_len length of the filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/deserialize_int_r.html"},{"title":"deserialize_int_C – TensorOmics","text":"subroutine deserialize_int_C(arr, arr_size, filename_ascii, fn_len, ierr) bind(C, name=\"deserialize_int_C\") Uses tox_errors array_utils iso_fortran_env iso_c_binding C binding for the subroutine to deserialize an integer array from a file Note It is assumed that the array is already allocated and passed together with its size Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: arr (arr_size) preallocated array integer(kind=c_int), value :: arr_size Size of the array integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Filename in ascii integer(kind=c_int), value :: fn_len length of the filename integer(kind=c_int), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_c.html"},{"title":"mean_vector_c – TensorOmics","text":"pure subroutine mean_vector_c(expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid_col, ierr) bind(c, name='mean_vector_c') Uses tox_gene_centroids iso_c_binding C interface wrapper for mean_vector. Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=c_int), intent(in), value :: n_axes Number of axes (tissues/dimensions). integer(kind=c_int), intent(in), value :: n_genes Total number of genes in the input matrix. integer(kind=c_int), intent(in) :: gene_indices (n_selected_genes) An array containing the column indices of the selected genes in 'expression_vectors'. integer(kind=c_int), intent(in), value :: n_selected_genes The number of genes in the current family to be averaged. real(kind=c_double), intent(out) :: centroid_col (n_axes) The output vector representing the computed centroid. integer(kind=c_int), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/mean_vector_c.html"},{"title":"group_centroid_c – TensorOmics","text":"pure subroutine group_centroid_c(expression_vectors, n_axes, n_genes, gene_to_family, n_families, centroid_matrix, mode, ortholog_set, selected_indices, selected_indices_len, ierr) bind(c, name='group_centroid_c') Uses tox_errors tox_conversions tox_gene_centroids iso_c_binding C interface wrapper for group_centroid. Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: expression_vectors (n_axes,n_genes) Input expression vectors (passed from C). integer(kind=c_int), intent(in), value :: n_axes Number of axes (tissues/dimensions). integer(kind=c_int), intent(in), value :: n_genes Total number of genes. integer(kind=c_int), intent(in) :: gene_to_family (n_genes) Array mapping gene index to family ID. integer(kind=c_int), intent(in), value :: n_families Total number of families. real(kind=c_double), intent(out) :: centroid_matrix (n_axes,n_families) Output matrix for centroids. character(len=c_char), intent(in) :: mode (10) A character array indicating the mode of operation ('orthologs' or 'all'). integer(kind=c_int), intent(in) :: ortholog_set (n_genes) Integer array from C indicating subset membership. integer(kind=c_int), intent(out) :: selected_indices (selected_indices_len) Output array for selected indices. integer(kind=c_int), intent(in), value :: selected_indices_len The allocated length of the 'selected_indices' array. integer(kind=c_int), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/group_centroid_c.html"},{"title":"mean_vector_r – TensorOmics","text":"pure subroutine mean_vector_r(expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid_col, ierr) Uses tox_gene_centroids iso_fortran_env R interface wrapper for mean_vector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the input matrix. integer(kind=int32), intent(in) :: gene_indices (n_selected_genes) An array containing the column indices of the selected genes in 'expression_vectors'. integer(kind=int32), intent(in) :: n_selected_genes The number of genes in the current family to be averaged. real(kind=real64), intent(out) :: centroid_col (n_axes) The output vector representing the computed centroid. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/mean_vector_r.html"},{"title":"group_centroid_r – TensorOmics","text":"pure subroutine group_centroid_r(expression_vectors, n_axes, n_genes, gene_to_family, n_families, centroid_matrix, mode_raw, ortholog_set, selected_indices, selected_indices_len, ierr) Uses tox_gene_centroids tox_conversions tox_errors iso_c_binding iso_fortran_env R interface wrapper for group_centroid. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the 'expression_vectors' matrix. integer(kind=int32), intent(in) :: gene_to_family (n_genes) An array mapping each gene (by index) to a family ID. integer(kind=int32), intent(in) :: n_families Total number of gene families to compute centroids for. real(kind=real64), intent(out) :: centroid_matrix (n_axes,n_families) The output matrix (n_axes x n_families) to store the computed centroids. character(len=c_char), intent(in) :: mode_raw (10) A raw character array indicating the mode of operation (\"orthologs\" or \"all\"). logical, intent(in) :: ortholog_set (n_genes) A logical array indicating if a gene is part of a specific subset. integer(kind=int32), intent(out) :: selected_indices (selected_indices_len) An output array for storing selected gene indices. integer(kind=int32), intent(in) :: selected_indices_len The allocated length of the 'selected_indices' array. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/group_centroid_r.html"},{"title":"deserialize_real_flat_r – TensorOmics","text":"subroutine deserialize_real_flat_r(flat_arr, arr_size, filename_ascii, fn_len, ierr) Uses tox_errors iso_fortran_env array_utils R binding for the subroutine to deserialize a flat real array from a file Note It is assumed that the array is already allocated and passed together with its size Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: flat_arr (arr_size) array provided by R integer(kind=int32), intent(in) :: arr_size size of the array integer(kind=int32), intent(in) :: filename_ascii (fn_len) filename in ascii integer(kind=int32), intent(in) :: fn_len length of the filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/deserialize_real_flat_r.html"},{"title":"deserialize_real_C – TensorOmics","text":"subroutine deserialize_real_C(arr, arr_size, filename_ascii, fn_len, ierr) bind(C, name=\"deserialize_real_C\") Uses tox_errors array_utils iso_fortran_env iso_c_binding C binding for the subroutine to deserialize a real array from a file Note It is assumed that the array is already allocated and passed together with its size Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(out) :: arr (arr_size) output array integer(kind=c_int), value :: arr_size size of the output array integer(kind=c_int), intent(in) :: filename_ascii (fn_len) Filename in ascii integer(kind=c_int), value :: fn_len length of the filename integer(kind=c_int), intent(out) :: ierr error code","tags":"","url":"proc/deserialize_real_c.html"},{"title":"get_sorted_value – TensorOmics","text":"public  function get_sorted_value(values, sorted_indices, position, ierr) result(sorted_value) Get the value at the sorted position. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (:) Input real array integer(kind=int32), intent(in) :: sorted_indices (:) Permutation index array integer(kind=int32), intent(in) :: position Sorted position (1-based) integer(kind=int32), intent(out) :: ierr Error code Return Value real(kind=real64)","tags":"","url":"proc/get_sorted_value.html"},{"title":"build_bst_index – TensorOmics","text":"public pure subroutine build_bst_index(values, num_values, sorted_indices, left_stack, right_stack, ierr) Build the BST index by sorting indices using values in x. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array to be indexed integer(kind=int32), intent(in) :: num_values Number of elements in values array integer(kind=int32), intent(out) :: sorted_indices (num_values) Output permutation index integer(kind=int32), intent(out) :: left_stack (num_values) Manual stack for left indices integer(kind=int32), intent(out) :: right_stack (num_values) Manual stack for right indices integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_bst_index.html"},{"title":"bst_range_query – TensorOmics","text":"public pure subroutine bst_range_query(values, sorted_indices, num_values, lower_bound, upper_bound, output_indices, num_matches, ierr) Perform a 1D range query over the sorted index. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array integer(kind=int32), intent(in) :: sorted_indices (num_values) Permutation index array (sorted) integer(kind=int32), intent(in) :: num_values Number of elements real(kind=real64), intent(in) :: lower_bound Lower bound of range (inclusive) real(kind=real64), intent(in) :: upper_bound Upper bound of range (inclusive) integer(kind=int32), intent(out) :: output_indices (num_values) Output array of matching indices integer(kind=int32), intent(out) :: num_matches Number of matches found integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/bst_range_query.html"},{"title":"serialize_real_1d – TensorOmics","text":"public  subroutine serialize_real_1d(arr, filename, ierr) Serialize a 1D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_1d.html"},{"title":"serialize_real_2d – TensorOmics","text":"public  subroutine serialize_real_2d(arr, filename, ierr) Serialize a 2D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_2d.html"},{"title":"serialize_real_3d – TensorOmics","text":"public  subroutine serialize_real_3d(arr, filename, ierr) Serialize a 3D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_3d.html"},{"title":"serialize_real_4d – TensorOmics","text":"public  subroutine serialize_real_4d(arr, filename, ierr) Serialize a 4D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_4d.html"},{"title":"serialize_real_5d – TensorOmics","text":"public  subroutine serialize_real_5d(arr, filename, ierr) Serialize a 5D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_5d.html"},{"title":"serialize_real_nd – TensorOmics","text":"public  subroutine serialize_real_nd(arr, dims, ndim, filename, ierr) @brief Writes serialized real array from R to file with metdata. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) array to save integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_real_nd.html"},{"title":"normalization_pipeline – TensorOmics","text":"public pure subroutine normalization_pipeline(n_genes, n_tissues, input_matrix, buf_stddev, buf_quant, buf_avg, buf_log, temp_col, rank_means, perm, stack_left, stack_right, max_stack, group_s, group_c, n_grps, ierr) Complete normalization pipeline for gene expression data.\nPerforms: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation.\nFinal result is in buf_log. If fold change is needed, call calc_fchange separately. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (n_genes * n_tissues), column-major real(kind=real64), intent(out) :: buf_stddev (n_genes*n_tissues) Buffer for std dev normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_quant (n_genes*n_tissues) Buffer for quantile normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_avg (n_genes*n_grps) Buffer for replicate averaging (n_genes * n_grps) real(kind=real64), intent(out) :: buf_log (n_genes*n_grps) Buffer for log2(x+1) transformation (n_genes * n_grps) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary column vector for sorting (n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Buffer for rank means (n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector for sorting (n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Left stack for quicksort (max_stack) integer(kind=int32), intent(out) :: stack_right (max_stack) Right stack for quicksort (max_stack) integer(kind=int32), intent(in) :: max_stack Stack size for quicksort integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each replicate group (n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per replicate group (n_grps) integer(kind=int32), intent(in) :: n_grps Number of replicate groups integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/normalization_pipeline.html"},{"title":"normalize_by_std_dev – TensorOmics","text":"public pure subroutine normalize_by_std_dev(n_genes, n_tissues, input_matrix, output_matrix, ierr) Normalizes each gene's expression vector using sqrt(mean(x&#94;2)) across tissues (not classical standard deviation). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix of gene expression values (column-major) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output normalized matrix (same shape as input) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/normalize_by_std_dev.html"},{"title":"quantile_normalization – TensorOmics","text":"public pure subroutine quantile_normalization(n_genes, n_tissues, input_matrix, output_matrix, temp_col, rank_means, perm, stack_left, stack_right, max_stack, ierr) Uses f42_utils Quantile normalization of a gene expression matrix (F42-compliant).\nComputes average expression per rank across tissues. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (column-major) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output normalized matrix (same shape as input) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary vector for column sorting (size n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Preallocated vector to store rank means (size n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector (size n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Manual quicksort stack (≥ log2(n_genes) + 10) integer(kind=int32), intent(out) :: stack_right (max_stack) Manual quicksort stack (same size as stack_left) integer(kind=int32), intent(in) :: max_stack Stack size passed from R integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/quantile_normalization.html"},{"title":"log2_transformation – TensorOmics","text":"public pure subroutine log2_transformation(n_genes, n_tissues, input_matrix, output_matrix, ierr) Apply log2(x + 1) transformation to each element of the input matrix.\nThis subroutine performs element-wise log2(x + 1) transformation on a\nmatrix flattened in column-major order. The log2 is computed via: log(x + 1) / log(2) , which is numerically equivalent and avoids the\nnon-portable log2 intrinsic for compatibility with WebAssembly (WASM). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (size: n_genes * n_tissues) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output matrix (same size as input) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/log2_transformation.html"},{"title":"calc_tiss_avg – TensorOmics","text":"public pure subroutine calc_tiss_avg(n_gene, n_grps, group_s, group_c, input_matrix, output_matrix, ierr) Calculate tissue averages by averaging replicates within each group.\nFor each group of tissue replicates, this subroutine computes the average\nexpression per gene. The input matrix is column-major, flattened as a 1D array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_gene Number of genes (rows) integer(kind=int32), intent(in) :: n_grps Number of tissue groups integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each group (length: n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per group (length: n_grps) real(kind=real64), intent(in) :: input_matrix (n_gene*sum(group_c)) Flattened input matrix (length: n_gene * n_col) real(kind=real64), intent(out) :: output_matrix (n_gene*n_grps) Flattened output matrix (length: n_gene * n_grps) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/calc_tiss_avg.html"},{"title":"calc_fchange – TensorOmics","text":"public pure subroutine calc_fchange(n_genes, n_cols, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ierr) Calculate log2 fold changes between condition and control columns.\nFor each control-condition pair, this subroutine computes the log2 fold change by subtracting the expression value in the control column from the corresponding\nvalue in the condition column, for all genes. The input matrix must be column-major and flattened as a 1D array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_cols Number of columns in the input matrix integer(kind=int32), intent(in) :: n_pairs Number of control-condition pairs integer(kind=int32), intent(in) :: control_cols (n_pairs) Control column indices (length n_pairs) integer(kind=int32), intent(in) :: cond_cols (n_pairs) Condition column indices (length n_pairs) real(kind=real64), intent(in) :: i_matrix (n_genes*n_cols) Input matrix, flattened (length: n_genes × n_cols) real(kind=real64), intent(out) :: o_matrix (n_genes*n_pairs) Output matrix for fold changes (length: n_genes × n_pairs) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/calc_fchange.html"},{"title":"deserialize_char_flat – TensorOmics","text":"public  subroutine deserialize_char_flat(flat, dims, clen, filename, ierr) Subroutine to deserialize a flat character array from a file Arguments Type Intent Optional Attributes Name character(len=:), intent(out), pointer :: flat (:) Output flat character array integer(kind=int32), intent(out), allocatable :: dims (:) Output dimensions of the array integer(kind=int32), intent(out) :: clen Maximum length of character string character(len=*), intent(in) :: filename Name of the file to read integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_flat.html"},{"title":"deserialize_char_1d – TensorOmics","text":"public  subroutine deserialize_char_1d(arr, filename, ierr) Directly deserialize a 1D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file to read from integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_1d.html"},{"title":"deserialize_char_2d – TensorOmics","text":"public  subroutine deserialize_char_2d(arr, filename, ierr) Directly deserialize a 2D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_2d.html"},{"title":"deserialize_char_3d – TensorOmics","text":"public  subroutine deserialize_char_3d(arr, filename, ierr) Directly deserialize a 3D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_3d.html"},{"title":"deserialize_char_4d – TensorOmics","text":"public  subroutine deserialize_char_4d(arr, filename, ierr) Directly deserialize a 4D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_4d.html"},{"title":"deserialize_char_5d – TensorOmics","text":"public  subroutine deserialize_char_5d(arr, filename, ierr) Directly deserialize a 5D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_char_5d.html"},{"title":"serialize_int_1d – TensorOmics","text":"public  subroutine serialize_int_1d(arr, filename, ierr) Serialize a 1D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_int_1d.html"},{"title":"serialize_int_2d – TensorOmics","text":"public  subroutine serialize_int_2d(arr, filename, ierr) Serialize a 2D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32) :: ierr error code","tags":"","url":"proc/serialize_int_2d.html"},{"title":"serialize_int_3d – TensorOmics","text":"public  subroutine serialize_int_3d(arr, filename, ierr) Serialize a 3D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32) :: ierr error code","tags":"","url":"proc/serialize_int_3d.html"},{"title":"serialize_int_4d – TensorOmics","text":"public  subroutine serialize_int_4d(arr, filename, ierr) Serialize a 4D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_int_4d.html"},{"title":"serialize_int_5d – TensorOmics","text":"public  subroutine serialize_int_5d(arr, filename, ierr) Serialize a 5D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_int_5d.html"},{"title":"serialize_int_nd – TensorOmics","text":"public  subroutine serialize_int_nd(arr, dims, ndim, filename, ierr) Serialize a flat integer array with specified dimensions and number of dimensions to a binary file. Note this is called by R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:) Flat integer array to serialize integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_int_nd.html"},{"title":"c_double_as_real64 – TensorOmics","text":"public elemental subroutine c_double_as_real64(c_val, f_val) Converts a c_double value to real64, elemental -> any shape Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: c_val the element containing the c variant of the number real(kind=real64), intent(out) :: f_val the element that will hold the real64 representation of the c_double","tags":"","url":"proc/c_double_as_real64.html"},{"title":"real64_as_c_double – TensorOmics","text":"public elemental subroutine real64_as_c_double(f_val, c_val) Converts a real64 value to c_double, elemental -> any shape Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f_val the element containing the fortran variant of the number real(kind=c_double), intent(out) :: c_val the element that will hold the c_double representation of the real64","tags":"","url":"proc/real64_as_c_double.html"},{"title":"c_complex_as_complex – TensorOmics","text":"public elemental subroutine c_complex_as_complex(c_val, f_val) Converts a c_double_complex value to fortran complex(real64), elemental -> any shape Arguments Type Intent Optional Attributes Name complex(kind=c_double_complex), intent(in) :: c_val the element containing the c variant of the number complex(kind=real64), intent(out) :: f_val the element that will hold the complex(real64) representation of the c_double_complex","tags":"","url":"proc/c_complex_as_complex.html"},{"title":"complex_as_c_complex – TensorOmics","text":"public elemental subroutine complex_as_c_complex(f_val, c_val) Converts a fortran complex(real64) value to c_double_complex, elemental -> any shape Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f_val the element containing the fortran variant of the number complex(kind=c_double_complex), intent(out) :: c_val the element that will hold the c_double_complex representation of the complex(real64)","tags":"","url":"proc/complex_as_c_complex.html"},{"title":"c_int_as_int32 – TensorOmics","text":"public elemental subroutine c_int_as_int32(c_val, f_val) Converts a c_int value to int32, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: c_val the element containing the c variant of the number integer(kind=int32), intent(out) :: f_val the element that will hold the int32 representation of the c_int","tags":"","url":"proc/c_int_as_int32.html"},{"title":"int32_as_c_int – TensorOmics","text":"public elemental subroutine int32_as_c_int(f_val, c_val) Converts a int32 value to c_int, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: f_val the element containing the fortran variant of the number integer(kind=c_int), intent(out) :: c_val the element that will hold the c_int representation of the int32","tags":"","url":"proc/int32_as_c_int.html"},{"title":"c_int_as_logical – TensorOmics","text":"public elemental subroutine c_int_as_logical(c_val, f_val) Converts a c_int value to logical, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: c_val the element containing the c variant of the number logical, intent(out) :: f_val the element that will hold the logical representation of the c_int: 0 means .false. , else .true.","tags":"","url":"proc/c_int_as_logical.html"},{"title":"logical_as_c_int – TensorOmics","text":"public elemental subroutine logical_as_c_int(f_val, c_val) Converts a logical value to c_int, elemental -> any shape Arguments Type Intent Optional Attributes Name logical, intent(in) :: f_val the element containing the fortran variant of the number integer(kind=c_int), intent(out) :: c_val the element that will hold the c_int representation of the logical: 0 if .false. , else 1","tags":"","url":"proc/logical_as_c_int.html"},{"title":"c_char_as_char – TensorOmics","text":"public elemental subroutine c_char_as_char(c_val, f_val) Converts a c_char value to fortran character, elemental -> any shape Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in) :: c_val the element containing the c variant of the character character(len=1), intent(out) :: f_val the element that will hold the fortran char representation of the c_char","tags":"","url":"proc/c_char_as_char.html"},{"title":"char_as_c_char – TensorOmics","text":"public elemental subroutine char_as_c_char(f_val, c_val) Converts a character value to c_char, elemental -> any shape Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_val the element containing the fortran variant of the character character(kind=c_char, len=1), intent(out) :: c_val the element that will hold the c_char (ASCII) representation of the character","tags":"","url":"proc/char_as_c_char.html"},{"title":"c_char_1d_as_string – TensorOmics","text":"public pure subroutine c_char_1d_as_string(c_char_array, str_out, ierr) Converts a 1D c_char array to string Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in), dimension(:) :: c_char_array c int array, representing characters character(len=:), intent(out), allocatable :: str_out Fortran string, length determined by occuring null char in c_char_array integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/c_char_1d_as_string.html"},{"title":"string_as_c_char_1d – TensorOmics","text":"public pure subroutine string_as_c_char_1d(str, c_char_array) Converts a string to 1D c_char array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Fortran string to be converted character(kind=c_char, len=1), intent(out), dimension(:) :: c_char_array c int array, representing chars of str , will always end with null char. If array too small, it will hold fitting trimmed str .","tags":"","url":"proc/string_as_c_char_1d.html"},{"title":"c_char_2d_as_string – TensorOmics","text":"public pure subroutine c_char_2d_as_string(c_char_array, str_out, ierr) Converts a 2D c_char array to 1D string array Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in), dimension(:, :) :: c_char_array c int array, columns as ascii arrays character(len=:), intent(out), dimension(:), allocatable :: str_out Fortran array of resulting strings integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/c_char_2d_as_string.html"},{"title":"string_as_c_char_2d – TensorOmics","text":"public pure subroutine string_as_c_char_2d(strings, c_char_array) Converts a 1D string array to 2D c_char array Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: strings Fortran array of strings character(kind=c_char, len=1), intent(out), dimension(:, :) :: c_char_array c int array, columns as ascii arrays","tags":"","url":"proc/string_as_c_char_2d.html"},{"title":"cross_product_orientation_sign – TensorOmics","text":"public pure function cross_product_orientation_sign(a, b, n_dims, selected_axes) result(orientation_sign) Compute orientation sign from cross product of two vectors, using selected axes Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a (n_dims) real(kind=real64), intent(in) :: b (n_dims) integer(kind=int32), intent(in) :: n_dims integer(kind=int32), intent(in) :: selected_axes (3) Return Value real(kind=real64)","tags":"","url":"proc/cross_product_orientation_sign.html"},{"title":"omics_vector_RAP_projection – TensorOmics","text":"public pure subroutine omics_vector_RAP_projection(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Project selected vectors (e.g. expression vectors) onto the RAP constructed from a selected set of axes. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes, n_vecs) :: vecs matrix with expression vectors integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/omics_vector_rap_projection.html"},{"title":"omics_field_RAP_projection – TensorOmics","text":"public pure subroutine omics_field_RAP_projection(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Project selected vector fields (e.g. shift vectors) onto the RAP constructed from a selected set of axes. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(2 * n_axes, n_vecs) :: vecs matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/omics_field_rap_projection.html"},{"title":"project_selected_vecs_onto_rap – TensorOmics","text":"public pure subroutine project_selected_vecs_onto_rap(selected_vecs, n_selected_axes, n_selected_vecs) Projects selected vectors onto its RAP Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(n_selected_axes, n_selected_vecs) :: selected_vecs matrix with vectors for selected axes integer(kind=int32), intent(in) :: n_selected_axes number of selected axes integer(kind=int32), intent(in) :: n_selected_vecs number of selected vectors per axis","tags":"","url":"proc/project_selected_vecs_onto_rap.html"},{"title":"clock_hand_angle_between_vectors – TensorOmics","text":"public pure subroutine clock_hand_angle_between_vectors(v1, v2, n_dims, signed_angle, selected_axes_for_signed, ierr) Compute the signed clock hand angle between two RAP-projected and normalized vectors.\nCalculates the signed rotation angle between two normalized vectors in RAP space.\nFor 2D/3D: automatic directionality calculation. For >3D: uses selected axes for directionality. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims) :: v1 First normalized vector in RAP space real(kind=real64), intent(in), dimension(n_dims) :: v2 Second normalized vector in RAP space integer(kind=int32), intent(in) :: n_dims Dimension of both vectors real(kind=real64), intent(out) :: signed_angle Signed angle between vectors in radians [-π, π] integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angle_between_vectors.html"},{"title":"clock_hand_angles_for_shift_vectors – TensorOmics","text":"public pure subroutine clock_hand_angles_for_shift_vectors(origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles, ierr) Compute signed rotation angles between RAP-projected and normalized vector pairs.\nTakes separate arrays of RAP-projected and normalized vectors (e.g. expression centroids and paralogs) and computes the signed rotation angle between corresponding pairs.\nThis measures both magnitude and directionality of angular separation in RAP space. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: origins First set of RAP-projected, normalized vectors (e.g. expression centroids) real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: targets Second set of RAP-projected, normalized vectors (e.g. paralogs) integer(kind=int32), intent(in) :: n_dims Dimension of each vector in RAP space integer(kind=int32), intent(in) :: n_vecs Number of vector pairs logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vector pairs where angle should be computed integer(kind=int32), intent(in) :: n_selected_vecs Count of .true. values in vecs_selection_mask integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real(kind=real64), intent(out), dimension(n_selected_vecs) :: signed_angles Signed rotation angles between vector pairs in radians [-π, π] integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/clock_hand_angles_for_shift_vectors.html"},{"title":"compute_relative_axis_contributions – TensorOmics","text":"public pure subroutine compute_relative_axis_contributions(vec, n_axes, contributions, ierr) Uses ieee_arithmetic Compute fractional contribution of each axis to a RAP-projected and normalized shift vector.\nShared utility: computes fractional contribution of each axis to a RAP-projected and normalized vector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized vector (expression or shift) integer(kind=int32), intent(in) :: n_axes Number of axes (length of vec and contributions) real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/compute_relative_axis_contributions.html"},{"title":"relative_axes_changes_from_shift_vector – TensorOmics","text":"public pure subroutine relative_axes_changes_from_shift_vector(vec, n_axes, contributions, ierr) Compute fractional contribution of each axis to a RAP-projected and normalized shift vector.\nWrapper for shift vectors (e.g. difference between two RAP-projected vectors) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized shift vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_changes_from_shift_vector.html"},{"title":"relative_axes_expression_from_expression_vector – TensorOmics","text":"public pure subroutine relative_axes_expression_from_expression_vector(vec, n_axes, contributions, ierr) Compute fractional contribution of each axis to a RAP-projected and normalized expression vector.\nWrapper for single RAP-projected expression vectors Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized expression vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/relative_axes_expression_from_expression_vector.html"},{"title":"compute_family_scaling – TensorOmics","text":"public pure subroutine compute_family_scaling(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, family_distances, ierr) Compute family scaling factors (dscale) to normalize distances.\nUses LOESS on the median/stddev of intra-family distances for scaling, regardless of orthologs. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(inout) :: perm_tmp (n_genes) Permutation array for sorting gene distances integer(kind=int32), intent(inout) :: stack_left_tmp (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right_tmp (n_genes) Stack array for right indices during sorting real(kind=real64), intent(out) :: family_distances (n_genes) Pre-allocated work array for family distances (dimension n_genes) integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling.html"},{"title":"compute_family_scaling_alloc – TensorOmics","text":"public pure subroutine compute_family_scaling_alloc(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, ierr) Helper routine that allocates internal arrays and calls compute_family_scaling.\nThis makes usage easier since users don't need to care about internal array requirements. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices","tags":"","url":"proc/compute_family_scaling_alloc.html"},{"title":"compute_rdi – TensorOmics","text":"public pure subroutine compute_rdi(n_genes, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right) Compute the hybrid RDI for each gene.\nRDI = Euclidean distance / family scaling factor Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(in) :: dscale (:) Array of scaling factors for each family real(kind=real64), intent(out) :: rdi (n_genes) Output array of RDI values for each gene real(kind=real64), intent(inout) :: sorted_rdi (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes, should be pre-initialized with 1:n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for sorting (dimension n_genes)","tags":"","url":"proc/compute_rdi.html"},{"title":"identify_outliers – TensorOmics","text":"public pure subroutine identify_outliers(n_genes, rdi, sorted_rdi, is_outlier, threshold, percentile) Identify gene outliers based on the top percentile of RDI values.\nExpects sorted_rdi to be filtered (no negative values) and sorted in ascending order before calling.\nIf sorted_rdi contains negatives or is not sorted, results may be invalid. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes real(kind=real64), intent(in) :: rdi (n_genes) Array of RDI values for each gene real(kind=real64), intent(in) :: sorted_rdi (n_genes) Sorted RDI array (must be filtered to remove negatives and sorted in ascending order before calling) logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(out) :: threshold Output threshold value used for detection real(kind=real64), intent(in), optional :: percentile (optional) Percentile threshold (default: 95 for top 5%)","tags":"","url":"proc/identify_outliers.html"},{"title":"detect_outliers – TensorOmics","text":"public pure subroutine detect_outliers(n_genes, n_families, distances, gene_to_fam, work_array, perm, stack_left, stack_right, is_outlier, loess_x, loess_y, loess_n, ierr, percentile) Main routine to detect outliers using RDI and LOESS-based scaling. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(inout) :: work_array (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for right indices during sorting logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: loess_n (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices real(kind=real64), intent(in), optional :: percentile (optional) Percentile threshold for outlier detection (default: 95)","tags":"","url":"proc/detect_outliers.html"},{"title":"euclidean_distance – TensorOmics","text":"public pure subroutine euclidean_distance(vec1, vec2, d, result) Compute the Euclidean distance between two vectors.\nCalculates the L2 norm: result = sqrt(sum((vec1_i - vec2_i)&#94;2)) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vec1 (d) First expression vector real(kind=real64), intent(in) :: vec2 (d) Second expression vector integer(kind=int32), intent(in) :: d Dimension of both vectors real(kind=real64), intent(out) :: result Output scalar distance","tags":"","url":"proc/euclidean_distance.html"},{"title":"distance_to_centroid – TensorOmics","text":"public pure subroutine distance_to_centroid(n_genes, n_families, genes, centroids, gene_to_fam, distances, d) Compute distance from each gene to its corresponding family centroid.\nFor each gene, extracts its expression vector and the centroid of its assigned family, then computes the Euclidean distance between them. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: genes (d,n_genes) Gene expression matrix (d × n_genes), column-major real(kind=real64), intent(in) :: centroids (d,n_families) Family centroid matrix (d × n_families), column-major integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(out) :: distances (n_genes) Output distances array integer(kind=int32), intent(in) :: d Expression vector dimension","tags":"","url":"proc/distance_to_centroid.html"},{"title":"compute_shift_vector_field – TensorOmics","text":"public pure subroutine compute_shift_vector_field(d, n_genes, n_families, expression_vectors, family_centroids, gene_to_centroid, shift_vectors, ierr) Compute the shift vector field for all genes.\nComputes the shift vectors by substracting the corresponding family centroid from the expression vector. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: d Expression vector dimension integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of families real(kind=real64), intent(in) :: expression_vectors (d,n_genes) Gene expression matrix (d × n_genes) real(kind=real64), intent(in) :: family_centroids (d,n_families) Family centroid matrix (d × n_families) integer(kind=int32), intent(in) :: gene_to_centroid (n_genes) Mapping from genes to family centroids to genes of expression_vectors -> family_centroids(:, gene_to_centroid(n)) returns the family centroid of expression_vectors(:,n) real(kind=real64), intent(out) :: shift_vectors (2*d,n_genes) Output, real matrix array, size = 2d x n_genes , stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/compute_shift_vector_field.html"},{"title":"compute_tissue_versatility – TensorOmics","text":"public pure subroutine compute_tissue_versatility(n_axes, n_vectors, expression_vectors, exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, tissue_versatilities, tissue_angles_deg, ierr) Computes normalized tissue versatility for selected expression vectors.\nThe metric is based on the angle between each gene expression vector and the space diagonal.\nVersatility is normalized to [0, 1], where 0 means uniform expression and 1 means expression in only one axis. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions) integer(kind=int32), intent(in) :: n_vectors Number of expression vectors (genes) real(kind=real64), intent(in) :: expression_vectors (n_axes,n_vectors) 2D array (n_axes, n_vectors), each column is a gene expression vector logical, intent(in) :: exp_vecs_selection_index (n_vectors) Logical array (n_vectors), .TRUE. for vectors to process integer(kind=int32), intent(in) :: n_selected_vectors Number of selected expression vectors (count of .TRUE. in exp_vecs_selection_index) logical, intent(in) :: axes_selection (n_axes) Logical array (n_axes), .TRUE. for axes to include in calculation integer(kind=int32), intent(in) :: n_selected_axes Number of selected axes (count of .TRUE. in axes_selection) real(kind=real64), intent(out) :: tissue_versatilities (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities real(kind=real64), intent(out) :: tissue_angles_deg (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated angles in degrees integer(kind=int32), intent(out) :: ierr Error code: 0 = success, non-zero = error","tags":"","url":"proc/compute_tissue_versatility.html"},{"title":"sort_real – TensorOmics","text":"public pure subroutine sort_real(array, perm, stack_left, stack_right) Sort a real array indirectly using quicksort.\nCreates a sorted version of the array by reordering the perm vector. The original data in array remains unchanged. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/sort_real.html"},{"title":"sort_integer – TensorOmics","text":"public pure subroutine sort_integer(array, perm, stack_left, stack_right) Sort an integer array indirectly using quicksort.\nSimilar to sort_real , but for integer input. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/sort_integer.html"},{"title":"sort_character – TensorOmics","text":"public pure subroutine sort_character(array, perm, stack_left, stack_right) Sort a character array indirectly using quicksort.\nUses lexicographic ordering and permutation vector sorting. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/sort_character.html"},{"title":"quicksort_real – TensorOmics","text":"public pure subroutine quicksort_real(array, perm, n, stack_left, stack_right) Internal quicksort implementation for real arrays.\nSorts indirectly using the permutation vector perm . Manual stack replaces recursion. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/quicksort_real.html"},{"title":"quicksort_int – TensorOmics","text":"public pure subroutine quicksort_int(array, perm, n, stack_left, stack_right) Internal quicksort implementation for integer arrays.\nIndirectly sorts array using perm , same algorithm as quicksort_real . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/quicksort_int.html"},{"title":"quicksort_char – TensorOmics","text":"public pure subroutine quicksort_char(array, perm, n, stack_left, stack_right) Internal quicksort implementation for character arrays.\nLexicographic quicksort using string comparison, indirect via perm . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"proc/quicksort_char.html"},{"title":"swap_int – TensorOmics","text":"public pure subroutine swap_int(a, b) Swap two integer values in-place. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: a First integer to swap integer(kind=int32), intent(inout) :: b Second integer to swap","tags":"","url":"proc/swap_int.html"},{"title":"which – TensorOmics","text":"public pure subroutine which(mask, n, idx_out, m_max, m_out, ierr) Finds the indices of the true values in a logical mask. Arguments Type Intent Optional Attributes Name logical, intent(in) :: mask (:) Logical array of size n. integer(kind=int32), intent(in) :: n Size of the mask. integer(kind=int32), intent(out) :: idx_out (:) Integer array to store the indices of true values. integer(kind=int32), intent(in) :: m_max Maximum size of idx_out. integer(kind=int32), intent(out) :: m_out Actual size of idx_out (number of true values found). integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"proc/which.html"},{"title":"loess_smooth_2d – TensorOmics","text":"public pure subroutine loess_smooth_2d(n_total, n_target, x_ref, y_ref, indices_used, n_used, x_query, kernel_sigma, kernel_cutoff, y_out, ierr) Performs LOESS smoothing on a set of data points.\nSmooths y_ref at x_query using reference points x_ref, y_ref, and kernel parameters.\nThe user must pre-filter data and provide only valid indices in indices_used. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_total Total number of reference points. integer(kind=int32), intent(in) :: n_target Number of target points to smooth. real(kind=real64), intent(in) :: x_ref (n_total) Reference x-coordinates. real(kind=real64), intent(in) :: y_ref (n_total) Reference y-coordinates (length n_total). integer(kind=int32), intent(in) :: indices_used (n_used) Indices of reference points used for smoothing (only valid indices). integer(kind=int32), intent(in) :: n_used Number of indices actually used for smoothing. real(kind=real64), intent(in) :: x_query (n_target) Target x-coordinates to smooth. real(kind=real64), intent(in) :: kernel_sigma Bandwidth parameter for the kernel. real(kind=real64), intent(in) :: kernel_cutoff Cutoff for the kernel. real(kind=real64), intent(out) :: y_out (n_target) Output smoothed values (length n_target). integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"proc/loess_smooth_2d.html"},{"title":"sort_array – TensorOmics","text":"public interface sort_array Module Procedures public pure subroutine sort_real (array, perm, stack_left, stack_right) Sort a real array indirectly using quicksort.\nCreates a sorted version of the array by reordering the perm vector. The original data in array remains unchanged. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_integer (array, perm, stack_left, stack_right) Sort an integer array indirectly using quicksort.\nSimilar to sort_real , but for integer input. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_character (array, perm, stack_left, stack_right) Sort a character array indirectly using quicksort.\nUses lexicographic ordering and permutation vector sorting. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion","tags":"","url":"interface/sort_array.html"},{"title":"check_okay_ioerror – TensorOmics","text":"public  subroutine check_okay_ioerror(ioerror, ierr, msg, unit) Check I/O error and set ierr accordingly Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ioerror IO error set by fortran integer(kind=int32), intent(out) :: ierr Error code integer(kind=int32), intent(in) :: msg Error code readable version used for setting integer(kind=int32), intent(in) :: unit pass unit allowing it to be closed","tags":"","url":"proc/check_okay_ioerror.html"},{"title":"check_okay_dims – TensorOmics","text":"public  subroutine check_okay_dims(dims, expected, ierr) check if array dimensions match the expected dimensions Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) array of actual dimensions integer(kind=int32), intent(in) :: expected expected number of dimensions integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/check_okay_dims.html"},{"title":"check_okay_ndims – TensorOmics","text":"public  subroutine check_okay_ndims(ndims, expected, unit, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims number of dimensions integer(kind=int32), intent(in) :: expected expected number of dimensions integer(kind=int32), intent(in) :: unit unit representation integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/check_okay_ndims.html"},{"title":"write_file_header – TensorOmics","text":"public  subroutine write_file_header(filename, unit, type_code, ndim, dims, ierr, clen) Opens unit and writes fileheader with all metadata to the given filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename filename to write to integer(kind=int32), intent(out) :: unit Fortran unit number for the file integer(kind=int32), intent(in) :: type_code type code of the array (1=int, 2=real, 3=char) integer(kind=int32), intent(in) :: ndim number of dimensions integer(kind=int32), intent(in) :: dims (ndim) dimensions of the array integer(kind=int32), intent(inout) :: ierr error code integer(kind=int32), intent(in), optional :: clen character length (only for character arrays)","tags":"","url":"proc/write_file_header.html"},{"title":"read_file_header – TensorOmics","text":"public  subroutine read_file_header(filename, unit, type_code, ndims, dims, clen, ierr) Opens unit and reads file header with all metadata from given file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename filename to read from integer(kind=int32), intent(out) :: unit Fortran unit number for the file integer(kind=int32), intent(out) :: type_code type code of the array (1=int, 2=real, 3=char) integer(kind=int32), intent(out) :: ndims number of dimensions integer(kind=int32), allocatable :: dims (:) dimensions of the array integer(kind=int32), intent(out) :: clen character length (only for character arrays) integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/read_file_header.html"},{"title":"get_array_metadata – TensorOmics","text":"public  subroutine get_array_metadata(filename, dims_out, dims_out_capacity, ndims, ierr, clen) Get the metadata of an array file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: dims_out (dims_out_capacity) Array to store output dimensions integer(kind=int32), intent(in) :: dims_out_capacity Capacity of the dims_out array integer(kind=int32), intent(out) :: ndims number of dimensions integer(kind=int32), intent(out) :: ierr Error code integer(kind=int32), intent(out), optional :: clen length of each string (needed for char arrays)","tags":"","url":"proc/get_array_metadata.html"},{"title":"ascii_to_string – TensorOmics","text":"public  subroutine ascii_to_string(ascii_array, clen, str) subroutine to convert an ASCII array to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ascii_array (clen) Array of ASCII characters integer(kind=int32), intent(in) :: clen Length of the ASCII array character(len=:), intent(out), allocatable :: str Output string","tags":"","url":"proc/ascii_to_string.html"},{"title":"string_to_ascii_arr – TensorOmics","text":"public  subroutine string_to_ascii_arr(flat, array_size, ascii_arr, clen) converts a string array to an ascii array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flat (array_size) input array with characters integer(kind=int32), intent(in) :: array_size size of the input array integer(kind=int32), intent(out) :: ascii_arr (array_size*clen) ascii output array integer(kind=int32), intent(in) :: clen length of the longest string","tags":"","url":"proc/string_to_ascii_arr.html"},{"title":"is_err – TensorOmics","text":"public pure function is_err(ierr) result(not_ok) check if the error code indicates error Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ierr Return Value logical","tags":"","url":"proc/is_err.html"},{"title":"is_ok – TensorOmics","text":"public pure function is_ok(ierr) result(ok) check if the error code indicates success Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ierr Return Value logical","tags":"","url":"proc/is_ok.html"},{"title":"set_ok – TensorOmics","text":"public pure subroutine set_ok(ierr) set the error code to OK, use at beginning of procedures Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: ierr","tags":"","url":"proc/set_ok.html"},{"title":"set_err – TensorOmics","text":"public pure subroutine set_err(ierr, code) set the error code to specific code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ierr integer(kind=int32), intent(in) :: code","tags":"","url":"proc/set_err.html"},{"title":"set_err_once – TensorOmics","text":"public pure subroutine set_err_once(ierr, code) set the error code only if it is currently OK, use to prevent overwriting first error Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ierr integer(kind=int32), intent(in) :: code","tags":"","url":"proc/set_err_once.html"},{"title":"validate_dimension_size – TensorOmics","text":"public pure subroutine validate_dimension_size(n, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(out) :: ierr","tags":"","url":"proc/validate_dimension_size.html"},{"title":"serialize_char_1d – TensorOmics","text":"public  subroutine serialize_char_1d(arr, filename, ierr) Serialize a 1D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_1d.html"},{"title":"serialize_char_2d – TensorOmics","text":"public  subroutine serialize_char_2d(arr, filename, ierr) Serialize a 2D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_2d.html"},{"title":"serialize_char_3d – TensorOmics","text":"public  subroutine serialize_char_3d(arr, filename, ierr) Serialize a 3D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_3d.html"},{"title":"serialize_char_4d – TensorOmics","text":"public  subroutine serialize_char_4d(arr, filename, ierr) Serialize a 4D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_4d.html"},{"title":"serialize_char_5d – TensorOmics","text":"public  subroutine serialize_char_5d(arr, filename, ierr) Serialize a 5D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_5d.html"},{"title":"serialize_char_nd – TensorOmics","text":"public  subroutine serialize_char_nd(flat, dims, ndim, clen, filename, ierr) Serialize a character array of arbitrary dimensions to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Note This routine is only called by R and serializes only flat character arrays to the memory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flat (:) flat array to save integer(kind=int32), intent(in) :: dims (:) dimensions of the array integer(kind=int32), intent(in) :: ndim number of dimensions integer(kind=int32), intent(in) :: clen Length of each string character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"proc/serialize_char_nd.html"},{"title":"build_kd_index – TensorOmics","text":"public pure subroutine build_kd_index(points, num_dimensions, num_points, kd_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, recursion_stack, ierr) Build a k-d tree index using a stack-based, non-recursive approach.\nInitialize kd_indices to 1:num_points (original indices)\nChoose split dimension by cycling through dimension_order\nFind median index\nPartition kd_indices(left_idx:right_idx) by points(current_dim, kd_indices(:))\nPush right and left intervals onto stack Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: points (num_dimensions,num_points) Data points integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_points Number of points integer(kind=int32), intent(out) :: kd_indices (num_points) Output index array (k-d tree order) integer(kind=int32), intent(in) :: dimension_order (num_dimensions) Dimension order (by variance) integer(kind=int32), intent(out) :: workspace (num_points) Workspace array real(kind=real64), intent(out) :: value_buffer (num_points) Workspace for sorting integer(kind=int32), intent(out) :: permutation (num_points) Workspace for sorting integer(kind=int32), intent(out) :: left_stack (num_points) Workspace for sorting integer(kind=int32), intent(out) :: right_stack (num_points) Workspace for sorting integer(kind=int32), intent(out) :: recursion_stack (3,num_points) Stack for l, r, depth integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_kd_index.html"},{"title":"build_spherical_kd – TensorOmics","text":"public pure subroutine build_spherical_kd(vectors, num_dimensions, num_vectors, sphere_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, recursion_stack, ierr) Build spherical k-d tree index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vectors (num_dimensions,num_vectors) Input unit vectors integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_vectors Number of vectors integer(kind=int32), intent(out) :: sphere_indices (num_vectors) Output index array integer(kind=int32), intent(out) :: dimension_order (num_dimensions) Dimension order integer(kind=int32), intent(out) :: workspace (num_vectors) Workspace array real(kind=real64), intent(out) :: value_buffer (num_vectors) Value buffer integer(kind=int32), intent(out) :: permutation (num_vectors) Permutation array integer(kind=int32), intent(out) :: left_stack (num_vectors) Left stack integer(kind=int32), intent(out) :: right_stack (num_vectors) Right stack integer(kind=int32), intent(out) :: recursion_stack (3,num_vectors) Stack for recursive calls integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/build_spherical_kd.html"},{"title":"get_kd_point – TensorOmics","text":"public pure subroutine get_kd_point(points, kd_indices, position, point_values, ierr) Get point from KD index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: points (:,:) Input points integer(kind=int32), intent(in) :: kd_indices (:) KD index array integer(kind=int32), intent(in) :: position Position in index real(kind=real64), intent(out) :: point_values (:) Output point values integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/get_kd_point.html"},{"title":"deserialize_int_1d – TensorOmics","text":"public  subroutine deserialize_int_1d(arr, filename, ierr) Deserialize a flat integer array from a file\nDirectly deserialize a 1D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_1d.html"},{"title":"deserialize_int_2d – TensorOmics","text":"public  subroutine deserialize_int_2d(arr, filename, ierr) Directly deserialize a 2D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_2d.html"},{"title":"deserialize_int_3d – TensorOmics","text":"public  subroutine deserialize_int_3d(arr, filename, ierr) Directly deserialize a 3D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_3d.html"},{"title":"deserialize_int_4d – TensorOmics","text":"public  subroutine deserialize_int_4d(arr, filename, ierr) Directly deserialize a 4D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the File integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_4d.html"},{"title":"deserialize_int_5d – TensorOmics","text":"public  subroutine deserialize_int_5d(arr, filename, ierr) Directly deserialize a 5D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_int_5d.html"},{"title":"mean_vector – TensorOmics","text":"public pure subroutine mean_vector(expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid, ierr) Computes the element-wise mean for a given set of vectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the input matrix. integer(kind=int32), intent(in) :: gene_indices (n_selected_genes) An array containing the column indices of the selected genes in 'expression_vectors'. integer(kind=int32), intent(in) :: n_selected_genes The number of genes in the current family to be averaged. real(kind=real64), intent(out) :: centroid (n_axes) The output vector representing the computed centroid. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"proc/mean_vector.html"},{"title":"group_centroid – TensorOmics","text":"public pure subroutine group_centroid(expression_vectors, n_axes, n_genes, gene_to_family, n_families, centroid_matrix, mode, selected_indices, ierr, ortholog_set) Iterates over families, filters gene indices, and computes centroids. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the 'expression_vectors' matrix. integer(kind=int32), intent(in) :: gene_to_family (n_genes) An array mapping each gene (by index) to a family ID. integer(kind=int32), intent(in) :: n_families Total number of gene families to compute centroids for. real(kind=real64), intent(out) :: centroid_matrix (n_axes,n_families) The output matrix (n_axes x n_families) to store the computed centroids. integer(kind=int32), intent(in) :: mode A integer constant indicating the mode of operation (\"all\" or \"orthologs\"). integer(kind=int32), intent(out) :: selected_indices (n_genes) An output array for storing indices. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error logical, intent(in), optional :: ortholog_set (n_genes) A logical array indicating if a gene is part of a specific subset (e.g., orthologs).","tags":"","url":"proc/group_centroid.html"},{"title":"deserialize_real_1d – TensorOmics","text":"public  subroutine deserialize_real_1d(arr, filename, ierr) Directly deserialize a 1D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_real_1d.html"},{"title":"deserialize_real_2d – TensorOmics","text":"public  subroutine deserialize_real_2d(arr, filename, ierr) Directly deserialize a 2D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_real_2d.html"},{"title":"deserialize_real_3d – TensorOmics","text":"public  subroutine deserialize_real_3d(arr, filename, ierr) Directly deserialize a 3D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_real_3d.html"},{"title":"deserialize_real_4d – TensorOmics","text":"public  subroutine deserialize_real_4d(arr, filename, ierr) Directly deserialize a 4D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_real_4d.html"},{"title":"deserialize_real_5d – TensorOmics","text":"public  subroutine deserialize_real_5d(arr, filename, ierr) Directly deserialize a 5D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"proc/deserialize_real_5d.html"},{"title":"binary_search_tree – TensorOmics","text":"Uses f42_utils tox_errors iso_fortran_env Functions public  function get_sorted_value (values, sorted_indices, position, ierr) result(sorted_value) Get the value at the sorted position. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (:) Input real array integer(kind=int32), intent(in) :: sorted_indices (:) Permutation index array integer(kind=int32), intent(in) :: position Sorted position (1-based) integer(kind=int32), intent(out) :: ierr Error code Return Value real(kind=real64) Subroutines public pure subroutine build_bst_index (values, num_values, sorted_indices, left_stack, right_stack, ierr) Build the BST index by sorting indices using values in x. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array to be indexed integer(kind=int32), intent(in) :: num_values Number of elements in values array integer(kind=int32), intent(out) :: sorted_indices (num_values) Output permutation index integer(kind=int32), intent(out) :: left_stack (num_values) Manual stack for left indices integer(kind=int32), intent(out) :: right_stack (num_values) Manual stack for right indices integer(kind=int32), intent(out) :: ierr Error code public pure subroutine bst_range_query (values, sorted_indices, num_values, lower_bound, upper_bound, output_indices, num_matches, ierr) Perform a 1D range query over the sorted index. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: values (num_values) Input real array integer(kind=int32), intent(in) :: sorted_indices (num_values) Permutation index array (sorted) integer(kind=int32), intent(in) :: num_values Number of elements real(kind=real64), intent(in) :: lower_bound Lower bound of range (inclusive) real(kind=real64), intent(in) :: upper_bound Upper bound of range (inclusive) integer(kind=int32), intent(out) :: output_indices (num_values) Output array of matching indices integer(kind=int32), intent(out) :: num_matches Number of matches found integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/binary_search_tree.html"},{"title":"serialize_real – TensorOmics","text":"Uses tox_errors array_utils iso_fortran_env iso_c_binding Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: ARRAY_TYPE_REAL = 2 Subroutines public  subroutine serialize_real_1d (arr, filename, ierr) Serialize a 1D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_real_2d (arr, filename, ierr) Serialize a 2D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_real_3d (arr, filename, ierr) Serialize a 3D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_real_4d (arr, filename, ierr) Serialize a 4D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_real_5d (arr, filename, ierr) Serialize a 5D real(real64) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_real_nd (arr, dims, ndim, filename, ierr) @brief Writes serialized real array from R to file with metdata. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) array to save integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"module/serialize_real.html"},{"title":"tox_normalization – TensorOmics","text":"Module with normalization routines for tensor omics. Uses tox_errors iso_fortran_env Subroutines public pure subroutine normalization_pipeline (n_genes, n_tissues, input_matrix, buf_stddev, buf_quant, buf_avg, buf_log, temp_col, rank_means, perm, stack_left, stack_right, max_stack, group_s, group_c, n_grps, ierr) Complete normalization pipeline for gene expression data.\nPerforms: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation.\nFinal result is in buf_log. If fold change is needed, call calc_fchange separately. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (n_genes * n_tissues), column-major real(kind=real64), intent(out) :: buf_stddev (n_genes*n_tissues) Buffer for std dev normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_quant (n_genes*n_tissues) Buffer for quantile normalization (n_genes * n_tissues) real(kind=real64), intent(out) :: buf_avg (n_genes*n_grps) Buffer for replicate averaging (n_genes * n_grps) real(kind=real64), intent(out) :: buf_log (n_genes*n_grps) Buffer for log2(x+1) transformation (n_genes * n_grps) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary column vector for sorting (n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Buffer for rank means (n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector for sorting (n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Left stack for quicksort (max_stack) integer(kind=int32), intent(out) :: stack_right (max_stack) Right stack for quicksort (max_stack) integer(kind=int32), intent(in) :: max_stack Stack size for quicksort integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each replicate group (n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per replicate group (n_grps) integer(kind=int32), intent(in) :: n_grps Number of replicate groups integer(kind=int32), intent(out) :: ierr Error code public pure subroutine normalize_by_std_dev (n_genes, n_tissues, input_matrix, output_matrix, ierr) Normalizes each gene's expression vector using sqrt(mean(x&#94;2)) across tissues (not classical standard deviation). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix of gene expression values (column-major) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output normalized matrix (same shape as input) integer(kind=int32), intent(out) :: ierr Error code public pure subroutine quantile_normalization (n_genes, n_tissues, input_matrix, output_matrix, temp_col, rank_means, perm, stack_left, stack_right, max_stack, ierr) Quantile normalization of a gene expression matrix (F42-compliant).\nComputes average expression per rank across tissues. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (column-major) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output normalized matrix (same shape as input) real(kind=real64), intent(out) :: temp_col (n_genes) Temporary vector for column sorting (size n_genes) real(kind=real64), intent(out) :: rank_means (n_genes) Preallocated vector to store rank means (size n_genes) integer(kind=int32), intent(out) :: perm (n_genes) Permutation vector (size n_genes) integer(kind=int32), intent(out) :: stack_left (max_stack) Manual quicksort stack (≥ log2(n_genes) + 10) integer(kind=int32), intent(out) :: stack_right (max_stack) Manual quicksort stack (same size as stack_left) integer(kind=int32), intent(in) :: max_stack Stack size passed from R integer(kind=int32), intent(out) :: ierr Error code public pure subroutine log2_transformation (n_genes, n_tissues, input_matrix, output_matrix, ierr) Apply log2(x + 1) transformation to each element of the input matrix.\nThis subroutine performs element-wise log2(x + 1) transformation on a\nmatrix flattened in column-major order. The log2 is computed via: log(x + 1) / log(2) , which is numerically equivalent and avoids the\nnon-portable log2 intrinsic for compatibility with WebAssembly (WASM). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_tissues Number of tissues (columns) real(kind=real64), intent(in) :: input_matrix (n_genes*n_tissues) Flattened input matrix (size: n_genes * n_tissues) real(kind=real64), intent(out) :: output_matrix (n_genes*n_tissues) Output matrix (same size as input) integer(kind=int32), intent(out) :: ierr Error code public pure subroutine calc_tiss_avg (n_gene, n_grps, group_s, group_c, input_matrix, output_matrix, ierr) Calculate tissue averages by averaging replicates within each group.\nFor each group of tissue replicates, this subroutine computes the average\nexpression per gene. The input matrix is column-major, flattened as a 1D array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_gene Number of genes (rows) integer(kind=int32), intent(in) :: n_grps Number of tissue groups integer(kind=int32), intent(in) :: group_s (n_grps) Start column index for each group (length: n_grps) integer(kind=int32), intent(in) :: group_c (n_grps) Number of columns per group (length: n_grps) real(kind=real64), intent(in) :: input_matrix (n_gene*sum(group_c)) Flattened input matrix (length: n_gene * n_col) real(kind=real64), intent(out) :: output_matrix (n_gene*n_grps) Flattened output matrix (length: n_gene * n_grps) integer(kind=int32), intent(out) :: ierr Error code public pure subroutine calc_fchange (n_genes, n_cols, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ierr) Calculate log2 fold changes between condition and control columns.\nFor each control-condition pair, this subroutine computes the log2 fold change by subtracting the expression value in the control column from the corresponding\nvalue in the condition column, for all genes. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Number of genes (rows) integer(kind=int32), intent(in) :: n_cols Number of columns in the input matrix integer(kind=int32), intent(in) :: n_pairs Number of control-condition pairs integer(kind=int32), intent(in) :: control_cols (n_pairs) Control column indices (length n_pairs) integer(kind=int32), intent(in) :: cond_cols (n_pairs) Condition column indices (length n_pairs) real(kind=real64), intent(in) :: i_matrix (n_genes*n_cols) Input matrix, flattened (length: n_genes × n_cols) real(kind=real64), intent(out) :: o_matrix (n_genes*n_pairs) Output matrix for fold changes (length: n_genes × n_pairs) integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/tox_normalization.html"},{"title":"char_deserialize_mod – TensorOmics","text":"Module for deserializing character arrays from files Uses tox_errors iso_fortran_env array_utils Subroutines public  subroutine deserialize_char_flat (flat, dims, clen, filename, ierr) Subroutine to deserialize a flat character array from a file Arguments Type Intent Optional Attributes Name character(len=:), intent(out), pointer :: flat (:) Output flat character array integer(kind=int32), intent(out), allocatable :: dims (:) Output dimensions of the array integer(kind=int32), intent(out) :: clen Maximum length of character string character(len=*), intent(in) :: filename Name of the file to read integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_char_1d (arr, filename, ierr) Directly deserialize a 1D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file to read from integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_char_2d (arr, filename, ierr) Directly deserialize a 2D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_char_3d (arr, filename, ierr) Directly deserialize a 3D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_char_4d (arr, filename, ierr) Directly deserialize a 4D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_char_5d (arr, filename, ierr) Directly deserialize a 5D character array from a file (array already allocated) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/char_deserialize_mod.html"},{"title":"serialize_int – TensorOmics","text":"Module for serializing integer arrays to binary files. Uses tox_errors array_utils iso_fortran_env iso_c_binding Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: ARRAY_TYPE_INT = 1 Subroutines public  subroutine serialize_int_1d (arr, filename, ierr) Serialize a 1D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_int_2d (arr, filename, ierr) Serialize a 2D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32) :: ierr error code public  subroutine serialize_int_3d (arr, filename, ierr) Serialize a 3D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32) :: ierr error code public  subroutine serialize_int_4d (arr, filename, ierr) Serialize a 4D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_int_5d (arr, filename, ierr) Serialize a 5D integer(int32) array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, and the array data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_int_nd (arr, dims, ndim, filename, ierr) Serialize a flat integer array with specified dimensions and number of dimensions to a binary file. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: arr (:) Flat integer array to serialize integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: ndim Number of dimensions character(len=*), intent(in) :: filename filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"module/serialize_int.html"},{"title":"tox_conversions – TensorOmics","text":"Uses tox_errors iso_fortran_env iso_c_binding Subroutines public elemental subroutine c_double_as_real64 (c_val, f_val) Converts a c_double value to real64, elemental -> any shape Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: c_val the element containing the c variant of the number real(kind=real64), intent(out) :: f_val the element that will hold the real64 representation of the c_double public elemental subroutine real64_as_c_double (f_val, c_val) Converts a real64 value to c_double, elemental -> any shape Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f_val the element containing the fortran variant of the number real(kind=c_double), intent(out) :: c_val the element that will hold the c_double representation of the real64 public elemental subroutine c_complex_as_complex (c_val, f_val) Converts a c_double_complex value to fortran complex(real64), elemental -> any shape Arguments Type Intent Optional Attributes Name complex(kind=c_double_complex), intent(in) :: c_val the element containing the c variant of the number complex(kind=real64), intent(out) :: f_val the element that will hold the complex(real64) representation of the c_double_complex public elemental subroutine complex_as_c_complex (f_val, c_val) Converts a fortran complex(real64) value to c_double_complex, elemental -> any shape Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f_val the element containing the fortran variant of the number complex(kind=c_double_complex), intent(out) :: c_val the element that will hold the c_double_complex representation of the complex(real64) public elemental subroutine c_int_as_int32 (c_val, f_val) Converts a c_int value to int32, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: c_val the element containing the c variant of the number integer(kind=int32), intent(out) :: f_val the element that will hold the int32 representation of the c_int public elemental subroutine int32_as_c_int (f_val, c_val) Converts a int32 value to c_int, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: f_val the element containing the fortran variant of the number integer(kind=c_int), intent(out) :: c_val the element that will hold the c_int representation of the int32 public elemental subroutine c_int_as_logical (c_val, f_val) Converts a c_int value to logical, elemental -> any shape Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: c_val the element containing the c variant of the number logical, intent(out) :: f_val the element that will hold the logical representation of the c_int: 0 means .false. , else .true. public elemental subroutine logical_as_c_int (f_val, c_val) Converts a logical value to c_int, elemental -> any shape Arguments Type Intent Optional Attributes Name logical, intent(in) :: f_val the element containing the fortran variant of the number integer(kind=c_int), intent(out) :: c_val the element that will hold the c_int representation of the logical: 0 if .false. , else 1 public elemental subroutine c_char_as_char (c_val, f_val) Converts a c_char value to fortran character, elemental -> any shape Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in) :: c_val the element containing the c variant of the character character(len=1), intent(out) :: f_val the element that will hold the fortran char representation of the c_char public elemental subroutine char_as_c_char (f_val, c_val) Converts a character value to c_char, elemental -> any shape Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_val the element containing the fortran variant of the character character(kind=c_char, len=1), intent(out) :: c_val the element that will hold the c_char (ASCII) representation of the character public pure subroutine c_char_1d_as_string (c_char_array, str_out, ierr) Converts a 1D c_char array to string Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in), dimension(:) :: c_char_array c int array, representing characters character(len=:), intent(out), allocatable :: str_out Fortran string, length determined by occuring null char in c_char_array integer(kind=int32), intent(out) :: ierr Error code public pure subroutine string_as_c_char_1d (str, c_char_array) Converts a string to 1D c_char array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Fortran string to be converted character(kind=c_char, len=1), intent(out), dimension(:) :: c_char_array c int array, representing chars of str , will always end with null char. If array too small, it will hold fitting trimmed str . public pure subroutine c_char_2d_as_string (c_char_array, str_out, ierr) Converts a 2D c_char array to 1D string array Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in), dimension(:, :) :: c_char_array c int array, columns as ascii arrays character(len=:), intent(out), dimension(:), allocatable :: str_out Fortran array of resulting strings integer(kind=int32), intent(out) :: ierr Error code public pure subroutine string_as_c_char_2d (strings, c_char_array) Converts a 1D string array to 2D c_char array Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: strings Fortran array of strings character(kind=c_char, len=1), intent(out), dimension(:, :) :: c_char_array c int array, columns as ascii arrays","tags":"","url":"module/tox_conversions.html"},{"title":"relative_axis_plane_tools – TensorOmics","text":"Module for tools related to relative axis planes (RAPs), i.e. planes in higher-dimensional gene expression space Uses tox_errors ieee_arithmetic iso_fortran_env Functions public pure function cross_product_orientation_sign (a, b, n_dims, selected_axes) result(orientation_sign) Compute orientation sign from cross product of two vectors, using selected axes Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a (n_dims) real(kind=real64), intent(in) :: b (n_dims) integer(kind=int32), intent(in) :: n_dims integer(kind=int32), intent(in) :: selected_axes (3) Return Value real(kind=real64) Subroutines public pure subroutine omics_vector_RAP_projection (vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Project selected vectors (e.g. expression vectors) onto the RAP constructed from a selected set of axes. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes, n_vecs) :: vecs matrix with expression vectors integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code public pure subroutine omics_field_RAP_projection (vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ierr) Project selected vector fields (e.g. shift vectors) onto the RAP constructed from a selected set of axes. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(2 * n_axes, n_vecs) :: vecs matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer(kind=int32), intent(in) :: n_axes number of axes integer(kind=int32), intent(in) :: n_vecs number of vectors per axis logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vectors where projection is to be computed integer(kind=int32), intent(in) :: n_selected_vecs count of .true. values in vecs_selection_mask logical, intent(in), dimension(n_axes) :: axes_selection_mask .true. for axes to be included in RAP integer(kind=int32), intent(in) :: n_selected_axes count of .true. values in axes_selection_mask real(kind=real64), intent(out), dimension(n_selected_axes, n_selected_vecs) :: projections projected vectors integer(kind=int32), intent(out) :: ierr Error code public pure subroutine project_selected_vecs_onto_rap (selected_vecs, n_selected_axes, n_selected_vecs) Projects selected vectors onto its RAP Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(n_selected_axes, n_selected_vecs) :: selected_vecs matrix with vectors for selected axes integer(kind=int32), intent(in) :: n_selected_axes number of selected axes integer(kind=int32), intent(in) :: n_selected_vecs number of selected vectors per axis public pure subroutine clock_hand_angle_between_vectors (v1, v2, n_dims, signed_angle, selected_axes_for_signed, ierr) Compute the signed clock hand angle between two RAP-projected and normalized vectors.\nCalculates the signed rotation angle between two normalized vectors in RAP space.\nFor 2D/3D: automatic directionality calculation. For >3D: uses selected axes for directionality. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims) :: v1 First normalized vector in RAP space real(kind=real64), intent(in), dimension(n_dims) :: v2 Second normalized vector in RAP space integer(kind=int32), intent(in) :: n_dims Dimension of both vectors real(kind=real64), intent(out) :: signed_angle Signed angle between vectors in radians [-π, π] integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer(kind=int32), intent(out) :: ierr Error code public pure subroutine clock_hand_angles_for_shift_vectors (origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles, ierr) Compute signed rotation angles between RAP-projected and normalized vector pairs.\nTakes separate arrays of RAP-projected and normalized vectors (e.g. expression centroids and paralogs) and computes the signed rotation angle between corresponding pairs.\nThis measures both magnitude and directionality of angular separation in RAP space. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: origins First set of RAP-projected, normalized vectors (e.g. expression centroids) real(kind=real64), intent(in), dimension(n_dims, n_vecs) :: targets Second set of RAP-projected, normalized vectors (e.g. paralogs) integer(kind=int32), intent(in) :: n_dims Dimension of each vector in RAP space integer(kind=int32), intent(in) :: n_vecs Number of vector pairs logical, intent(in), dimension(n_vecs) :: vecs_selection_mask .true. for vector pairs where angle should be computed integer(kind=int32), intent(in) :: n_selected_vecs Count of .true. values in vecs_selection_mask integer(kind=int32), intent(in), dimension(3) :: selected_axes_for_signed Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real(kind=real64), intent(out), dimension(n_selected_vecs) :: signed_angles Signed rotation angles between vector pairs in radians [-π, π] integer(kind=int32), intent(out) :: ierr Error code public pure subroutine compute_relative_axis_contributions (vec, n_axes, contributions, ierr) Compute fractional contribution of each axis to a RAP-projected and normalized shift vector.\nShared utility: computes fractional contribution of each axis to a RAP-projected and normalized vector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized vector (expression or shift) integer(kind=int32), intent(in) :: n_axes Number of axes (length of vec and contributions) real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code public pure subroutine relative_axes_changes_from_shift_vector (vec, n_axes, contributions, ierr) Compute fractional contribution of each axis to a RAP-projected and normalized shift vector.\nWrapper for shift vectors (e.g. difference between two RAP-projected vectors) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized shift vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code public pure subroutine relative_axes_expression_from_expression_vector (vec, n_axes, contributions, ierr) Compute fractional contribution of each axis to a RAP-projected and normalized expression vector.\nWrapper for single RAP-projected expression vectors Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(n_axes) :: vec RAP-projected and normalized expression vector integer(kind=int32), intent(in) :: n_axes Number of axes real(kind=real64), intent(out), dimension(n_axes) :: contributions Fractional contribution of each axis (output), values in [0,1], sum to 1 integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/relative_axis_plane_tools.html"},{"title":"tox_get_outliers – TensorOmics","text":"Module to identify gene outliers based on their distances to family centroids. Uses f42_utils tox_errors ieee_arithmetic iso_fortran_env Subroutines public pure subroutine compute_family_scaling (n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, family_distances, ierr) Compute family scaling factors (dscale) to normalize distances.\nUses LOESS on the median/stddev of intra-family distances for scaling, regardless of orthologs. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(inout) :: perm_tmp (n_genes) Permutation array for sorting gene distances integer(kind=int32), intent(inout) :: stack_left_tmp (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right_tmp (n_genes) Stack array for right indices during sorting real(kind=real64), intent(out) :: family_distances (n_genes) Pre-allocated work array for family distances (dimension n_genes) integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices public pure subroutine compute_family_scaling_alloc (n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, ierr) Helper routine that allocates internal arrays and calls compute_family_scaling.\nThis makes usage easier since users don't need to care about internal array requirements. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Mapping of each gene to its family (1-based) real(kind=real64), intent(out) :: dscale (n_families) Output: array of scaling factors per family real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: indices_used (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices public pure subroutine compute_rdi (n_genes, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right) Compute the hybrid RDI for each gene.\nRDI = Euclidean distance / family scaling factor Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(in) :: dscale (:) Array of scaling factors for each family real(kind=real64), intent(out) :: rdi (n_genes) Output array of RDI values for each gene real(kind=real64), intent(inout) :: sorted_rdi (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes, should be pre-initialized with 1:n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for sorting (dimension n_genes) public pure subroutine identify_outliers (n_genes, rdi, sorted_rdi, is_outlier, threshold, percentile) Identify gene outliers based on the top percentile of RDI values.\nExpects sorted_rdi to be filtered (no negative values) and sorted in ascending order before calling.\nIf sorted_rdi contains negatives or is not sorted, results may be invalid. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes real(kind=real64), intent(in) :: rdi (n_genes) Array of RDI values for each gene real(kind=real64), intent(in) :: sorted_rdi (n_genes) Sorted RDI array (must be filtered to remove negatives and sorted in ascending order before calling) logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(out) :: threshold Output threshold value used for detection real(kind=real64), intent(in), optional :: percentile (optional) Percentile threshold (default: 95 for top 5%) public pure subroutine detect_outliers (n_genes, n_families, distances, gene_to_fam, work_array, perm, stack_left, stack_right, is_outlier, loess_x, loess_y, loess_n, ierr, percentile) Main routine to detect outliers using RDI and LOESS-based scaling. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: distances (n_genes) Array of Euclidean distances for each gene to its centroid integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(inout) :: work_array (n_genes) Work array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: perm (n_genes) Permutation array for sorting (dimension n_genes) integer(kind=int32), intent(inout) :: stack_left (n_genes) Stack array for left indices during sorting integer(kind=int32), intent(inout) :: stack_right (n_genes) Stack array for right indices during sorting logical, intent(out) :: is_outlier (n_genes) Output boolean array indicating outliers real(kind=real64), intent(inout) :: loess_x (n_families) Reference x-coordinates. real(kind=real64), intent(inout) :: loess_y (n_families) Reference y-coordinates (length n_total). integer(kind=int32), intent(inout) :: loess_n (n_families) Indices of reference points used for smoothing. integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid family indices real(kind=real64), intent(in), optional :: percentile (optional) Percentile threshold for outlier detection (default: 95)","tags":"","url":"module/tox_get_outliers.html"},{"title":"tox_euclidean_distance – TensorOmics","text":"Module with Euclidean distance computation routines for tensor omics. Uses iso_fortran_env Subroutines public pure subroutine euclidean_distance (vec1, vec2, d, result) Compute the Euclidean distance between two vectors.\nCalculates the L2 norm: result = sqrt(sum((vec1_i - vec2_i)&#94;2)) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vec1 (d) First expression vector real(kind=real64), intent(in) :: vec2 (d) Second expression vector integer(kind=int32), intent(in) :: d Dimension of both vectors real(kind=real64), intent(out) :: result Output scalar distance public pure subroutine distance_to_centroid (n_genes, n_families, genes, centroids, gene_to_fam, distances, d) Compute distance from each gene to its corresponding family centroid.\nFor each gene, extracts its expression vector and the centroid of its assigned family, then computes the Euclidean distance between them. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of gene families real(kind=real64), intent(in) :: genes (d,n_genes) Gene expression matrix (d × n_genes), column-major real(kind=real64), intent(in) :: centroids (d,n_families) Family centroid matrix (d × n_families), column-major integer(kind=int32), intent(in) :: gene_to_fam (n_genes) Gene-to-family mapping (1-based indexing) real(kind=real64), intent(out) :: distances (n_genes) Output distances array integer(kind=int32), intent(in) :: d Expression vector dimension","tags":"","url":"module/tox_euclidean_distance.html"},{"title":"tox_shift_vectors – TensorOmics","text":"Module for computing the shift vector field for all genes. Uses tox_errors iso_fortran_env Subroutines public pure subroutine compute_shift_vector_field (d, n_genes, n_families, expression_vectors, family_centroids, gene_to_centroid, shift_vectors, ierr) Compute the shift vector field for all genes.\nComputes the shift vectors by substracting the corresponding family centroid from the expression vector. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: d Expression vector dimension integer(kind=int32), intent(in) :: n_genes Total number of genes integer(kind=int32), intent(in) :: n_families Total number of families real(kind=real64), intent(in) :: expression_vectors (d,n_genes) Gene expression matrix (d × n_genes) real(kind=real64), intent(in) :: family_centroids (d,n_families) Family centroid matrix (d × n_families) integer(kind=int32), intent(in) :: gene_to_centroid (n_genes) Mapping from genes to family centroids to genes of expression_vectors -> family_centroids(:, gene_to_centroid(n)) returns the family centroid of expression_vectors(:,n) real(kind=real64), intent(out) :: shift_vectors (2*d,n_genes) Output, real matrix array, size = 2d x n_genes , stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error","tags":"","url":"module/tox_shift_vectors.html"},{"title":"avmod – TensorOmics","text":"Module for calculating normalized tissue (axis) versatility.\nThis module implements the angle-based metric for tissue versatility,\nquantifying how uniformly a gene is expressed across selected axes (tissues). Uses tox_errors iso_fortran_env Subroutines public pure subroutine compute_tissue_versatility (n_axes, n_vectors, expression_vectors, exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, tissue_versatilities, tissue_angles_deg, ierr) Computes normalized tissue versatility for selected expression vectors.\nThe metric is based on the angle between each gene expression vector and the space diagonal.\nVersatility is normalized to [0, 1], where 0 means uniform expression and 1 means expression in only one axis. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions) integer(kind=int32), intent(in) :: n_vectors Number of expression vectors (genes) real(kind=real64), intent(in) :: expression_vectors (n_axes,n_vectors) 2D array (n_axes, n_vectors), each column is a gene expression vector logical, intent(in) :: exp_vecs_selection_index (n_vectors) Logical array (n_vectors), .TRUE. for vectors to process integer(kind=int32), intent(in) :: n_selected_vectors Number of selected expression vectors (count of .TRUE. in exp_vecs_selection_index) logical, intent(in) :: axes_selection (n_axes) Logical array (n_axes), .TRUE. for axes to include in calculation integer(kind=int32), intent(in) :: n_selected_axes Number of selected axes (count of .TRUE. in axes_selection) real(kind=real64), intent(out) :: tissue_versatilities (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities real(kind=real64), intent(out) :: tissue_angles_deg (n_selected_vectors) Output, real array, length = n_selected_vectors, stores the calculated angles in degrees integer(kind=int32), intent(out) :: ierr Error code: 0 = success, non-zero = error","tags":"","url":"module/avmod.html"},{"title":"f42_utils – TensorOmics","text":"Utility module for data analysis.\nThis module provides general-purpose utility functions for data analysis, to be used as needed. Uses tox_errors iso_fortran_env Interfaces public        interface sort_array public pure subroutine sort_real (array, perm, stack_left, stack_right) Sort a real array indirectly using quicksort.\nCreates a sorted version of the array by reordering the perm vector. The original data in array remains unchanged. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_integer (array, perm, stack_left, stack_right) Sort an integer array indirectly using quicksort.\nSimilar to sort_real , but for integer input. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_character (array, perm, stack_left, stack_right) Sort a character array indirectly using quicksort.\nUses lexicographic ordering and permutation vector sorting. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion Subroutines public pure subroutine sort_real (array, perm, stack_left, stack_right) Sort a real array indirectly using quicksort.\nCreates a sorted version of the array by reordering the perm vector. The original data in array remains unchanged. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_integer (array, perm, stack_left, stack_right) Sort an integer array indirectly using quicksort.\nSimilar to sort_real , but for integer input. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine sort_character (array, perm, stack_left, stack_right) Sort a character array indirectly using quicksort.\nUses lexicographic ordering and permutation vector sorting. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine quicksort_real (array, perm, n, stack_left, stack_right) Internal quicksort implementation for real arrays.\nSorts indirectly using the permutation vector perm . Manual stack replaces recursion. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Real input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine quicksort_int (array, perm, n, stack_left, stack_right) Internal quicksort implementation for integer arrays.\nIndirectly sorts array using perm , same algorithm as quicksort_real . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Integer input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine quicksort_char (array, perm, n, stack_left, stack_right) Internal quicksort implementation for character arrays.\nLexicographic quicksort using string comparison, indirect via perm . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Character input array to sort integer(kind=int32), intent(inout) :: perm (:) Permutation vector that will be sorted integer(kind=int32), intent(in) :: n Size of the array integer(kind=int32), intent(inout) :: stack_left (:) Manual stack of left indices for quicksort recursion integer(kind=int32), intent(inout) :: stack_right (:) Manual stack of right indices for quicksort recursion public pure subroutine swap_int (a, b) Swap two integer values in-place. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: a First integer to swap integer(kind=int32), intent(inout) :: b Second integer to swap public pure subroutine which (mask, n, idx_out, m_max, m_out, ierr) Finds the indices of the true values in a logical mask. Arguments Type Intent Optional Attributes Name logical, intent(in) :: mask (:) Logical array of size n. integer(kind=int32), intent(in) :: n Size of the mask. integer(kind=int32), intent(out) :: idx_out (:) Integer array to store the indices of true values. integer(kind=int32), intent(in) :: m_max Maximum size of idx_out. integer(kind=int32), intent(out) :: m_out Actual size of idx_out (number of true values found). integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input public pure subroutine loess_smooth_2d (n_total, n_target, x_ref, y_ref, indices_used, n_used, x_query, kernel_sigma, kernel_cutoff, y_out, ierr) Performs LOESS smoothing on a set of data points.\nSmooths y_ref at x_query using reference points x_ref, y_ref, and kernel parameters.\nThe user must pre-filter data and provide only valid indices in indices_used. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_total Total number of reference points. integer(kind=int32), intent(in) :: n_target Number of target points to smooth. real(kind=real64), intent(in) :: x_ref (n_total) Reference x-coordinates. real(kind=real64), intent(in) :: y_ref (n_total) Reference y-coordinates (length n_total). integer(kind=int32), intent(in) :: indices_used (n_used) Indices of reference points used for smoothing (only valid indices). integer(kind=int32), intent(in) :: n_used Number of indices actually used for smoothing. real(kind=real64), intent(in) :: x_query (n_target) Target x-coordinates to smooth. real(kind=real64), intent(in) :: kernel_sigma Bandwidth parameter for the kernel. real(kind=real64), intent(in) :: kernel_cutoff Cutoff for the kernel. real(kind=real64), intent(out) :: y_out (n_target) Output smoothed values (length n_target). integer(kind=int32), intent(out) :: ierr Error code: 0=ok, 201=invalid input, 202=empty input","tags":"","url":"module/f42_utils.html"},{"title":"array_utils – TensorOmics","text":"Module for array utilities Uses tox_errors iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: ARRAY_FILE_MAGIC = int(z'46413230', int32) Magic number for array files Subroutines public  subroutine check_okay_ioerror (ioerror, ierr, msg, unit) Check I/O error and set ierr accordingly Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ioerror IO error set by fortran integer(kind=int32), intent(out) :: ierr Error code integer(kind=int32), intent(in) :: msg Error code readable version used for setting integer(kind=int32), intent(in) :: unit pass unit allowing it to be closed public  subroutine check_okay_dims (dims, expected, ierr) check if array dimensions match the expected dimensions Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) array of actual dimensions integer(kind=int32), intent(in) :: expected expected number of dimensions integer(kind=int32), intent(out) :: ierr error code public  subroutine check_okay_ndims (ndims, expected, unit, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims number of dimensions integer(kind=int32), intent(in) :: expected expected number of dimensions integer(kind=int32), intent(in) :: unit unit representation integer(kind=int32), intent(out) :: ierr error code public  subroutine write_file_header (filename, unit, type_code, ndim, dims, ierr, clen) Opens unit and writes fileheader with all metadata to the given filename Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename filename to write to integer(kind=int32), intent(out) :: unit Fortran unit number for the file integer(kind=int32), intent(in) :: type_code type code of the array (1=int, 2=real, 3=char) integer(kind=int32), intent(in) :: ndim number of dimensions integer(kind=int32), intent(in) :: dims (ndim) dimensions of the array integer(kind=int32), intent(inout) :: ierr error code integer(kind=int32), intent(in), optional :: clen character length (only for character arrays) public  subroutine read_file_header (filename, unit, type_code, ndims, dims, clen, ierr) Opens unit and reads file header with all metadata from given file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename filename to read from integer(kind=int32), intent(out) :: unit Fortran unit number for the file integer(kind=int32), intent(out) :: type_code type code of the array (1=int, 2=real, 3=char) integer(kind=int32), intent(out) :: ndims number of dimensions integer(kind=int32), allocatable :: dims (:) dimensions of the array integer(kind=int32), intent(out) :: clen character length (only for character arrays) integer(kind=int32), intent(out) :: ierr error code public  subroutine get_array_metadata (filename, dims_out, dims_out_capacity, ndims, ierr, clen) Get the metadata of an array file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: dims_out (dims_out_capacity) Array to store output dimensions integer(kind=int32), intent(in) :: dims_out_capacity Capacity of the dims_out array integer(kind=int32), intent(out) :: ndims number of dimensions integer(kind=int32), intent(out) :: ierr Error code integer(kind=int32), intent(out), optional :: clen length of each string (needed for char arrays) public  subroutine ascii_to_string (ascii_array, clen, str) subroutine to convert an ASCII array to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ascii_array (clen) Array of ASCII characters integer(kind=int32), intent(in) :: clen Length of the ASCII array character(len=:), intent(out), allocatable :: str Output string public  subroutine string_to_ascii_arr (flat, array_size, ascii_arr, clen) converts a string array to an ascii array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flat (array_size) input array with characters integer(kind=int32), intent(in) :: array_size size of the input array integer(kind=int32), intent(out) :: ascii_arr (array_size*clen) ascii output array integer(kind=int32), intent(in) :: clen length of the longest string","tags":"","url":"module/array_utils.html"},{"title":"tox_errors – TensorOmics","text":"error handling module for tensor-omics Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: ERR_OK = 0 no error, operation successful integer(kind=int32), public, parameter :: ERR_FILE_OPEN = 101 could not open file integer(kind=int32), public, parameter :: ERR_READ_MAGIC = 102 could not read magic number integer(kind=int32), public, parameter :: ERR_READ_TYPE = 103 could not read array type code integer(kind=int32), public, parameter :: ERR_READ_NDIMS = 104 could not read number of dimensions integer(kind=int32), public, parameter :: ERR_READ_DIMS = 105 could not read array dimensions integer(kind=int32), public, parameter :: ERR_READ_CHARLEN = 106 could not read character length integer(kind=int32), public, parameter :: ERR_READ_DATA = 107 could not read array data integer(kind=int32), public, parameter :: ERR_WRITE_MAGIC = 112 could not write magic number integer(kind=int32), public, parameter :: ERR_WRITE_TYPE = 113 could not write array type code integer(kind=int32), public, parameter :: ERR_WRITE_NDIMS = 114 could not write number of dimensions integer(kind=int32), public, parameter :: ERR_WRITE_DIMS = 115 could not write array dimensions integer(kind=int32), public, parameter :: ERR_WRITE_CHARLEN = 116 could not write character length integer(kind=int32), public, parameter :: ERR_WRITE_DATA = 117 could not write array data integer(kind=int32), public, parameter :: ERR_INVALID_FORMAT = 200 invalid format detected integer(kind=int32), public, parameter :: ERR_INVALID_INPUT = 201 invalid input arguments integer(kind=int32), public, parameter :: ERR_EMPTY_INPUT = 202 empty input arrays integer(kind=int32), public, parameter :: ERR_DIM_MISMATCH = 203 dimensions do not match expected shape integer(kind=int32), public, parameter :: ERR_NAN_INF = 204 NaN or Inf found where not allowed integer(kind=int32), public, parameter :: ERR_UNSUPPORTED_TYPE = 205 unsupported data type encountered integer(kind=int32), public, parameter :: ERR_SIZE_MISMATCH = 206 Array size mismatch integer(kind=int32), public, parameter :: ERR_ALLOC_FAIL = 301 memory allocation failed integer(kind=int32), public, parameter :: ERR_POINTER_NULL = 302 null pointer dereference integer(kind=int32), public, parameter :: ERR_UNIT_NOT_CONNECTED = 5002 Fortran runtime error: unit not connected integer(kind=int32), public, parameter :: ERR_INTERNAL = 9001 unexpected internal state or logic error integer(kind=int32), public, parameter :: ERR_UNKNOWN = 9999 unknown error Functions public pure function is_err (ierr) result(not_ok) check if the error code indicates error Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ierr Return Value logical public pure function is_ok (ierr) result(ok) check if the error code indicates success Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ierr Return Value logical Subroutines public pure subroutine set_ok (ierr) set the error code to OK, use at beginning of procedures Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: ierr public pure subroutine set_err (ierr, code) set the error code to specific code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ierr integer(kind=int32), intent(in) :: code public pure subroutine set_err_once (ierr, code) set the error code only if it is currently OK, use to prevent overwriting first error Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ierr integer(kind=int32), intent(in) :: code public pure subroutine validate_dimension_size (n, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(out) :: ierr","tags":"","url":"module/tox_errors.html"},{"title":"serialize_char – TensorOmics","text":"Module providing serialization and deserialization routines for character arrays\nof up to 5 dimensions, arrays are serialized to a custom binary format with a magic number and type/dimension metadata. Uses tox_errors iso_fortran_env array_utils Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: ARRAY_TYPE_CHAR = 3 Subroutines public  subroutine serialize_char_1d (arr, filename, ierr) Serialize a 1D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_char_2d (arr, filename, ierr) Serialize a 2D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_char_3d (arr, filename, ierr) Serialize a 3D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_char_4d (arr, filename, ierr) Serialize a 4D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_char_5d (arr, filename, ierr) Serialize a 5D character array to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arr (:,:,:,:,:) array to save character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code public  subroutine serialize_char_nd (flat, dims, ndim, clen, filename, ierr) Serialize a character array of arbitrary dimensions to a binary file.\nThe file will contain a magic number, type code, dimension, shape, character length, and the array data. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flat (:) flat array to save integer(kind=int32), intent(in) :: dims (:) dimensions of the array integer(kind=int32), intent(in) :: ndim number of dimensions integer(kind=int32), intent(in) :: clen Length of each string character(len=*), intent(in) :: filename output filename integer(kind=int32), intent(out) :: ierr error code","tags":"","url":"module/serialize_char.html"},{"title":"config – TensorOmics","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: alignment = 32","tags":"","url":"module/config.html"},{"title":"kd_tree – TensorOmics","text":"Uses f42_utils tox_errors iso_fortran_env Subroutines public pure subroutine build_kd_index (points, num_dimensions, num_points, kd_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, recursion_stack, ierr) Build a k-d tree index using a stack-based, non-recursive approach.\nInitialize kd_indices to 1:num_points (original indices)\nChoose split dimension by cycling through dimension_order\nFind median index\nPartition kd_indices(left_idx:right_idx) by points(current_dim, kd_indices(:))\nPush right and left intervals onto stack Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: points (num_dimensions,num_points) Data points integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_points Number of points integer(kind=int32), intent(out) :: kd_indices (num_points) Output index array (k-d tree order) integer(kind=int32), intent(in) :: dimension_order (num_dimensions) Dimension order (by variance) integer(kind=int32), intent(out) :: workspace (num_points) Workspace array real(kind=real64), intent(out) :: value_buffer (num_points) Workspace for sorting integer(kind=int32), intent(out) :: permutation (num_points) Workspace for sorting integer(kind=int32), intent(out) :: left_stack (num_points) Workspace for sorting integer(kind=int32), intent(out) :: right_stack (num_points) Workspace for sorting integer(kind=int32), intent(out) :: recursion_stack (3,num_points) Stack for l, r, depth integer(kind=int32), intent(out) :: ierr Error code public pure subroutine build_spherical_kd (vectors, num_dimensions, num_vectors, sphere_indices, dimension_order, workspace, value_buffer, permutation, left_stack, right_stack, recursion_stack, ierr) Build spherical k-d tree index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: vectors (num_dimensions,num_vectors) Input unit vectors integer(kind=int32), intent(in) :: num_dimensions Number of dimensions integer(kind=int32), intent(in) :: num_vectors Number of vectors integer(kind=int32), intent(out) :: sphere_indices (num_vectors) Output index array integer(kind=int32), intent(out) :: dimension_order (num_dimensions) Dimension order integer(kind=int32), intent(out) :: workspace (num_vectors) Workspace array real(kind=real64), intent(out) :: value_buffer (num_vectors) Value buffer integer(kind=int32), intent(out) :: permutation (num_vectors) Permutation array integer(kind=int32), intent(out) :: left_stack (num_vectors) Left stack integer(kind=int32), intent(out) :: right_stack (num_vectors) Right stack integer(kind=int32), intent(out) :: recursion_stack (3,num_vectors) Stack for recursive calls integer(kind=int32), intent(out) :: ierr Error code public pure subroutine get_kd_point (points, kd_indices, position, point_values, ierr) Get point from KD index Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: points (:,:) Input points integer(kind=int32), intent(in) :: kd_indices (:) KD index array integer(kind=int32), intent(in) :: position Position in index real(kind=real64), intent(out) :: point_values (:) Output point values integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/kd_tree.html"},{"title":"int_deserialize_mod – TensorOmics","text":"Module for deserializing integer arrays from files Uses tox_errors array_utils iso_fortran_env iso_c_binding Subroutines public  subroutine deserialize_int_1d (arr, filename, ierr) Deserialize a flat integer array from a file\nDirectly deserialize a 1D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_int_2d (arr, filename, ierr) Directly deserialize a 2D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_int_3d (arr, filename, ierr) Directly deserialize a 3D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_int_4d (arr, filename, ierr) Directly deserialize a 4D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the File integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_int_5d (arr, filename, ierr) Directly deserialize a 5D integer array from a file Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/int_deserialize_mod.html"},{"title":"tox_gene_centroids – TensorOmics","text":"Module for computing expression centroids of gene families. Uses tox_errors iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: GROUP_ORTHOLOGS = 0 integer(kind=int32), public, parameter :: GROUP_ALL = 1 Subroutines public pure subroutine mean_vector (expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid, ierr) Computes the element-wise mean for a given set of vectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the input matrix. integer(kind=int32), intent(in) :: gene_indices (n_selected_genes) An array containing the column indices of the selected genes in 'expression_vectors'. integer(kind=int32), intent(in) :: n_selected_genes The number of genes in the current family to be averaged. real(kind=real64), intent(out) :: centroid (n_axes) The output vector representing the computed centroid. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error public pure subroutine group_centroid (expression_vectors, n_axes, n_genes, gene_to_family, n_families, centroid_matrix, mode, selected_indices, ierr, ortholog_set) Iterates over families, filters gene indices, and computes centroids. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: expression_vectors (n_axes,n_genes) The input matrix of all gene expression vectors (n_axes x n_genes). integer(kind=int32), intent(in) :: n_axes Number of axes (tissues/dimensions). integer(kind=int32), intent(in) :: n_genes Total number of genes in the 'expression_vectors' matrix. integer(kind=int32), intent(in) :: gene_to_family (n_genes) An array mapping each gene (by index) to a family ID. integer(kind=int32), intent(in) :: n_families Total number of gene families to compute centroids for. real(kind=real64), intent(out) :: centroid_matrix (n_axes,n_families) The output matrix (n_axes x n_families) to store the computed centroids. integer(kind=int32), intent(in) :: mode A integer constant indicating the mode of operation (\"all\" or \"orthologs\"). integer(kind=int32), intent(out) :: selected_indices (n_genes) An output array for storing indices. integer(kind=int32), intent(out) :: ierr Error code: 0 - success, non-zero = error logical, intent(in), optional :: ortholog_set (n_genes) A logical array indicating if a gene is part of a specific subset (e.g., orthologs).","tags":"","url":"module/tox_gene_centroids.html"},{"title":"real_deserialize_mod – TensorOmics","text":"Module for deserializing real (double precision) arrays from binary files Uses tox_errors array_utils iso_fortran_env iso_c_binding Subroutines public  subroutine deserialize_real_1d (arr, filename, ierr) Directly deserialize a 1D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_real_2d (arr, filename, ierr) Directly deserialize a 2D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_real_3d (arr, filename, ierr) Directly deserialize a 3D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_real_4d (arr, filename, ierr) Directly deserialize a 4D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code public  subroutine deserialize_real_5d (arr, filename, ierr) Directly deserialize a 5D real array from a file (array already allocated) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: arr (:,:,:,:,:) Pre-allocated array to read the data into character(len=*), intent(in) :: filename Name of the file integer(kind=int32), intent(out) :: ierr Error code","tags":"","url":"module/real_deserialize_mod.html"},{"title":"binary_search_tree.F90 – TensorOmics","text":"Flat-index-based Binary Search Tree (BST) utilities for 1D range queries. This module provides routines to build a BST index (via sorting), access sorted values,\nand perform efficient range queries over a real-valued array. Source Code !! Flat-index-based Binary Search Tree (BST) utilities for 1D range queries. !! !! This module provides routines to build a BST index (via sorting), access sorted values, !! and perform efficient range queries over a real-valued array. module binary_search_tree use f42_utils , only : sort_array use iso_fortran_env , only : int32 , real64 use tox_errors , only : ERR_OK , ERR_INVALID_INPUT , ERR_EMPTY_INPUT , ERR_DIM_MISMATCH , ERR_SIZE_MISMATCH , is_ok , set_err_once , set_ok , validate_dimension_size implicit none public :: build_bst_index , get_sorted_value , bst_range_query contains !> Build the BST index by sorting indices using values in x. pure subroutine build_bst_index ( values , num_values , sorted_indices , left_stack , right_stack , ierr ) integer ( int32 ), intent ( in ) :: num_values !! Number of elements in values array real ( real64 ), intent ( in ) :: values ( num_values ) !! Input real array to be indexed integer ( int32 ), intent ( out ) :: sorted_indices ( num_values ) !! Output permutation index integer ( int32 ), intent ( out ) :: left_stack ( num_values ) !! Manual stack for left indices integer ( int32 ), intent ( out ) :: right_stack ( num_values ) !! Manual stack for right indices integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: idx call set_ok ( ierr ) call validate_dimension_size ( num_values , ierr ) if (. not . is_ok ( ierr )) return do idx = 1 , num_values sorted_indices ( idx ) = idx end do call sort_array ( values , sorted_indices , left_stack , right_stack ) end subroutine build_bst_index !> Get the value at the sorted position. function get_sorted_value ( values , sorted_indices , position , ierr ) result ( sorted_value ) real ( real64 ), intent ( in ) :: values (:) !! Input real array integer ( int32 ), intent ( in ) :: sorted_indices (:) !! Permutation index array integer ( int32 ), intent ( in ) :: position !! Sorted position (1-based) integer ( int32 ), intent ( out ) :: ierr !! Error code real ( real64 ) :: sorted_value call set_ok ( ierr ) ! Input validation if ( position < 1 . or . position > size ( sorted_indices )) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( sorted_indices ( position ) < 1 . or . sorted_indices ( position ) > size ( values )) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) return end if sorted_value = values ( sorted_indices ( position )) end function get_sorted_value !> Perform a 1D range query over the sorted index. pure subroutine bst_range_query ( values , sorted_indices , num_values , lower_bound , upper_bound , & output_indices , num_matches , ierr ) integer ( int32 ), intent ( in ) :: num_values !! Number of elements real ( real64 ), intent ( in ) :: values ( num_values ) !! Input real array integer ( int32 ), intent ( in ) :: sorted_indices ( num_values ) !! Permutation index array (sorted) real ( real64 ), intent ( in ) :: lower_bound !! Lower bound of range (inclusive) real ( real64 ), intent ( in ) :: upper_bound !! Upper bound of range (inclusive) integer ( int32 ), intent ( out ) :: output_indices ( num_values ) !! Output array of matching indices integer ( int32 ), intent ( out ) :: num_matches !! Number of matches found integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: idx call set_ok ( ierr ) call validate_dimension_size ( num_values , ierr ) if (. not . is_ok ( ierr )) return if ( lower_bound > upper_bound ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if num_matches = 0 do idx = 1 , num_values if ( values ( sorted_indices ( idx )) >= lower_bound . and . & values ( sorted_indices ( idx )) <= upper_bound ) then num_matches = num_matches + 1 output_indices ( num_matches ) = sorted_indices ( idx ) else if ( values ( sorted_indices ( idx )) > upper_bound ) then exit end if end do end subroutine bst_range_query end module binary_search_tree !> Wrapper for getting range query usable by R subroutine bst_range_query_r ( values , sorted_indices , num_values , lower_bound , upper_bound , & output_indices , num_matches , ierr ) use binary_search_tree , only : bst_range_query use iso_fortran_env , only : int32 , real64 use tox_errors , only : ERR_OK implicit none integer ( int32 ), intent ( in ) :: num_values !! Number of elements real ( real64 ), intent ( in ) :: values ( num_values ) !! Input real array integer ( int32 ), intent ( in ) :: sorted_indices ( num_values ) !! Permutation index array real ( real64 ), intent ( in ) :: lower_bound !! Lower bound of range real ( real64 ), intent ( in ) :: upper_bound !! Upper bound of range integer ( int32 ), intent ( out ) :: output_indices ( num_values ) !! Output array of matching indices integer ( int32 ), intent ( out ) :: num_matches !! Number of matches found integer ( int32 ), intent ( out ) :: ierr !! Error code call bst_range_query ( values , sorted_indices , num_values , lower_bound , upper_bound , & output_indices , num_matches , ierr ) end subroutine bst_range_query_r !> Wrapper for building BST index usable by R subroutine build_bst_index_r ( values , num_values , sorted_indices , left_stack , right_stack , ierr ) use binary_search_tree , only : build_bst_index use iso_fortran_env , only : int32 , real64 use tox_errors , only : ERR_OK implicit none integer ( int32 ), intent ( in ) :: num_values !! Number of elements real ( real64 ), intent ( in ) :: values ( num_values ) !! Input real array integer ( int32 ), intent ( out ) :: sorted_indices ( num_values ) !! Output permutation index integer ( int32 ), intent ( out ) :: left_stack ( num_values ) !! Manual stack for left indices integer ( int32 ), intent ( out ) :: right_stack ( num_values ) !! Manual stack for right indices integer ( int32 ), intent ( out ) :: ierr !! Error code call build_bst_index ( values , num_values , sorted_indices , left_stack , right_stack , ierr ) end subroutine build_bst_index_r !> Wrapper using C for getting range query usable by python subroutine bst_range_query_C ( values , sorted_indices , num_values , lower_bound , upper_bound , & output_indices , num_matches , ierr ) bind ( C , name = 'bst_range_query_C' ) use iso_c_binding , only : c_int , c_double , c_f_pointer , c_loc use binary_search_tree , only : bst_range_query use tox_errors , only : ERR_OK implicit none real ( c_double ), intent ( in ) :: values ( num_values ) !! Input real array (C-style) integer ( c_int ), intent ( in ) :: sorted_indices ( num_values ) !! Permutation index array (C-style) integer ( c_int ), value :: num_values !! Number of elements real ( c_double ), value :: lower_bound !! Lower bound of range real ( c_double ), value :: upper_bound !! Upper bound of range integer ( c_int ), intent ( out ) :: output_indices ( num_values ) !! Output array (C-style) integer ( c_int ), intent ( out ) :: num_matches !! Number of matches found integer ( c_int ), intent ( out ) :: ierr !! Error code call bst_range_query ( values , sorted_indices , num_values , lower_bound , upper_bound , & output_indices , num_matches , ierr ) end subroutine bst_range_query_C !> Wrapper using C for building BST index usable by python subroutine build_bst_index_C ( values , num_values , sorted_indices , left_stack , right_stack , ierr ) & bind ( C , name = 'build_bst_index_C' ) use iso_c_binding , only : c_int , c_double , c_f_pointer , c_loc use binary_search_tree use tox_errors , only : ERR_OK implicit none integer ( c_int ), value :: num_values !! Number of elements real ( c_double ), intent ( in ) :: values ( num_values ) !! Input real array (C-style) integer ( c_int ), intent ( out ) :: sorted_indices ( num_values ) !! Output permutation index (C-style) integer ( c_int ), intent ( out ) :: left_stack ( num_values ) !! Manual stack for left indices integer ( c_int ), intent ( out ) :: right_stack ( num_values ) !! Manual stack for right indices integer ( c_int ), intent ( out ) :: ierr !! Error code call build_bst_index ( values , num_values , sorted_indices , left_stack , right_stack , ierr ) end subroutine build_bst_index_C","tags":"","url":"sourcefile/binary_search_tree.f90.html"},{"title":"precompiler_constants.F90 – TensorOmics","text":"Source Code #ifndef DEFAULT_ALIGNMENT #define DEFAULT_ALIGNMENT 32 #endif","tags":"","url":"sourcefile/precompiler_constants.f90.html"},{"title":"serialize_real.F90 – TensorOmics","text":"Source Code module serialize_real use , intrinsic :: iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_loc use array_utils , only : write_file_header use tox_errors implicit none public :: serialize_real_1d , serialize_real_2d , serialize_real_3d , & serialize_real_4d , serialize_real_5d , serialize_real_nd integer ( int32 ), parameter :: ARRAY_TYPE_REAL = 2 contains !> Serialize a 1D real(real64) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_real_1d ( arr , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: dims ( 1 ) integer ( int32 ) :: ioerror dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_REAL , 1 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 2D real(real64) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_real_2d ( arr , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: dims ( 2 ) integer ( int32 ) :: ioerror call set_ok ( ierr ) call set_ok ( ioerror ) dims = shape ( arr ) call write_file_header ( filename , unit , ARRAY_TYPE_REAL , 2 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 3D real(real64) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_real_3d ( arr , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror integer ( int32 ) :: unit integer ( int32 ) :: dims ( 3 ) call set_ok ( ierr ) call set_ok ( ioerror ) dims = shape ( arr ) call write_file_header ( filename , unit , ARRAY_TYPE_REAL , 3 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 4D real(real64) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_real_4d ( arr , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ), INTENT ( OUT ) :: ierr !! error code integer ( int32 ) :: ioerror integer ( int32 ) :: unit integer ( int32 ) :: dims ( 4 ) call set_ok ( ierr ) call set_ok ( ioerror ) dims = shape ( arr ) call write_file_header ( filename , unit , ARRAY_TYPE_REAL , 4 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 5D real(real64) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_real_5d ( arr , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:,:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror integer ( int32 ) :: unit integer ( int32 ) :: dims ( 5 ) call set_ok ( ierr ) call set_ok ( ioerror ) dims = shape ( arr ) call write_file_header ( filename , unit , ARRAY_TYPE_REAL , 5 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> @brief Writes serialized real array from R to file with metdata. subroutine serialize_real_nd ( arr , dims , ndim , filename , ierr ) real ( real64 ), intent ( in ) :: arr (:) !! array to save integer ( int32 ), intent ( in ) :: dims (:) !! Dimensions of the array integer ( int32 ), intent ( in ) :: ndim !! Number of dimensions character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ), INTENT ( OUT ) :: ierr !! error code integer ( int32 ) :: ioerror , unit call set_ok ( ierr ) call set_ok ( ioerror ) if ( size ( dims ) /= ndim ) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) return end if call write_file_header ( filename , unit , ARRAY_TYPE_REAL , ndim , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine end module serialize_real !> Serialize a flat integer array with specified dimensions and number of dimensions to a binary file. !! R can not pass a multidimensional array directly, so we use a flat array and dimensions. Therefore, exposing serialize_int_*d to R is not needed. subroutine serialize_real_flat_r ( arr , array_size , dims , ndim , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : int32 , real64 use array_utils , only : ascii_to_string use serialize_real , only : serialize_real_nd use tox_errors , only : set_ok implicit none integer ( int32 ), intent ( in ) :: ndim !! Number of dimensions integer ( int32 ), intent ( in ) :: array_size !! Size of the flat array real ( real64 ), intent ( in ) :: arr ( array_size ) !! Flat real array to serialize integer ( int32 ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( int32 ), intent ( in ) :: fn_len !! length of the filename array integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename character ( len = :), allocatable :: filename integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i , total_len call set_ok ( ierr ) call ascii_to_string ( filename_ascii , fn_len , filename ) ! calculate total size total_len = 1 do i = 1 , ndim total_len = total_len * dims ( i ) end do call serialize_real_nd ( arr ( 1 : total_len ), dims ( 1 : ndim ), ndim , filename , ierr ) end subroutine subroutine serialize_real_nd_C ( arr , dims , ndim , filename_ascii , fn_len , ierr ) bind ( C , name = \"serialize_real_nd_C\" ) use iso_c_binding , only : c_ptr , c_int , c_f_pointer , c_double use array_utils , only : ascii_to_string use serialize_real , only : serialize_real_nd use tox_errors , only : set_ok use iso_fortran_env , only : int32 implicit none ! Input parameters type ( c_ptr ), value :: arr !! Pointer to the flat real array integer ( c_int ), value :: ndim !! Number of dimensions integer ( c_int ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( c_int ), value :: fn_len !! Length of the filename array integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( c_int ), intent ( out ) :: ierr ! Local character ( len = :), allocatable :: filename real ( c_double ), pointer :: arr_f (:) integer ( int32 ) :: i call ascii_to_string ( filename_ascii , fn_len , filename ) ! 1D-Array from C pointer call c_f_pointer ( arr , arr_f , [ product ( dims ( 1 : ndim ))]) ! save call serialize_real_nd ( arr_f , dims , ndim , filename , ierr ) end subroutine","tags":"","url":"sourcefile/serialize_real.f90.html"},{"title":"tox_normalization.F90 – TensorOmics","text":"Source Code !> Module with normalization routines for tensor omics. module tox_normalization use , intrinsic :: iso_fortran_env , only : real64 , int32 use tox_errors , only : set_ok , set_err , ERR_EMPTY_INPUT , ERR_INVALID_INPUT , is_err contains !> Complete normalization pipeline for gene expression data. !! Performs: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation. !! Final result is in buf_log. If fold change is needed, call calc_fchange separately. pure subroutine normalization_pipeline ( n_genes , n_tissues , input_matrix , buf_stddev , buf_quant , buf_avg , buf_log , temp_col , rank_means , perm , stack_left , stack_right , max_stack , group_s , group_c , n_grps , ierr ) !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Number of replicate groups integer ( int32 ), intent ( in ) :: n_grps !| Stack size for quicksort integer ( int32 ), intent ( in ) :: max_stack !| Flattened input matrix (n_genes * n_tissues), column-major real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Buffer for std dev normalization (n_genes * n_tissues) real ( real64 ), intent ( out ) :: buf_stddev ( n_genes * n_tissues ) !| Buffer for quantile normalization (n_genes * n_tissues) real ( real64 ), intent ( out ) :: buf_quant ( n_genes * n_tissues ) !| Buffer for replicate averaging (n_genes * n_grps) real ( real64 ), intent ( out ) :: buf_avg ( n_genes * n_grps ) !| Buffer for log2(x+1) transformation (n_genes * n_grps) real ( real64 ), intent ( out ) :: buf_log ( n_genes * n_grps ) !| Temporary column vector for sorting (n_genes) real ( real64 ), intent ( out ) :: temp_col ( n_genes ) !| Buffer for rank means (n_genes) real ( real64 ), intent ( out ) :: rank_means ( n_genes ) !| Permutation vector for sorting (n_genes) integer ( int32 ), intent ( out ) :: perm ( n_genes ) !| Left stack for quicksort (max_stack) integer ( int32 ), intent ( out ) :: stack_left ( max_stack ) !| Right stack for quicksort (max_stack) integer ( int32 ), intent ( out ) :: stack_right ( max_stack ) !| Start column index for each replicate group (n_grps) integer ( int32 ), intent ( in ) :: group_s ( n_grps ) !| Number of columns per replicate group (n_grps) integer ( int32 ), intent ( in ) :: group_c ( n_grps ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! Error handling call set_ok ( ierr ) if ( n_genes <= 0 . or . n_tissues <= 0 . or . n_grps <= 0 . or . max_stack <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! Step 1: Normalize per-gene by std dev call normalize_by_std_dev ( n_genes , n_tissues , input_matrix , buf_stddev , ierr ) if ( is_err ( ierr )) return ! Step 2: Quantile normalization call quantile_normalization ( n_genes , n_tissues , buf_stddev , buf_quant , temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) if ( is_err ( ierr )) return ! Step 3: Average replicates call calc_tiss_avg ( n_genes , n_grps , group_s , group_c , buf_quant , buf_avg , ierr ) if ( is_err ( ierr )) return ! Step 4: Log2(x+1) transformation call log2_transformation ( n_genes , n_tissues , buf_avg , buf_log , ierr ) if ( is_err ( ierr )) return end subroutine normalization_pipeline !> Normalizes each gene's expression vector using `sqrt(mean(x&#94;2))` !| across tissues (not classical standard deviation). pure subroutine normalize_by_std_dev ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) implicit none !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Flattened input matrix of gene expression values (column-major) real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Output normalized matrix (same shape as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes * n_tissues ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! Local variables integer ( int32 ) :: i_gene , i_tissue real ( real64 ) :: std_dev , temp_sum ! Error handling call set_ok ( ierr ) if ( n_genes <= 0 . or . n_tissues <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! Loop over each gene do i_gene = 1 , n_genes temp_sum = 0.0d0 do i_tissue = 1 , n_tissues temp_sum = temp_sum + input_matrix (( i_tissue - 1 ) * n_genes + i_gene ) ** 2 end do std_dev = sqrt ( temp_sum / dble ( n_tissues )) if ( std_dev == 0.0d0 ) std_dev = 1.0d0 do i_tissue = 1 , n_tissues output_matrix (( i_tissue - 1 ) * n_genes + i_gene ) = input_matrix (( i_tissue - 1 ) * n_genes + i_gene ) / std_dev end do end do end subroutine normalize_by_std_dev !> Quantile normalization of a gene expression matrix (F42-compliant). !| Computes average expression per rank across tissues. pure subroutine quantile_normalization ( n_genes , n_tissues , input_matrix , output_matrix , & temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) use f42_utils , only : sort_array implicit none !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Flattened input matrix (column-major) real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Output normalized matrix (same shape as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes * n_tissues ) !| Temporary vector for column sorting (size n_genes) real ( real64 ), intent ( out ) :: temp_col ( n_genes ) !| Preallocated vector to store rank means (size n_genes) real ( real64 ), intent ( out ) :: rank_means ( n_genes ) !| Permutation vector (size n_genes) integer ( int32 ), intent ( out ) :: perm ( n_genes ) !| Stack size passed from R integer ( int32 ), intent ( in ) :: max_stack !| Manual quicksort stack (≥ log2(n_genes) + 10) integer ( int32 ), intent ( out ) :: stack_left ( max_stack ) !| Manual quicksort stack (same size as stack_left) integer ( int32 ), intent ( out ) :: stack_right ( max_stack ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! Locals integer ( int32 ) :: i_gene , i_tissue ! Error handling call set_ok ( ierr ) if ( n_genes <= 0 . or . n_tissues <= 0 . or . max_stack <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! Initialize rank means rank_means = 0.0d0 ! === First pass: accumulate values by rank across tissues === do i_tissue = 1 , n_tissues ! Prepare current column and initialize permutation do i_gene = 1 , n_genes temp_col ( i_gene ) = input_matrix (( i_tissue - 1 ) * n_genes + i_gene ) perm ( i_gene ) = i_gene end do ! Sort current column with index tracking call sort_array ( temp_col , perm , stack_left , stack_right ) ! Accumulate values for each rank do i_gene = 1 , n_genes rank_means ( i_gene ) = rank_means ( i_gene ) + temp_col ( perm ( i_gene )) end do end do ! Average the rank values do i_gene = 1 , n_genes rank_means ( i_gene ) = rank_means ( i_gene ) / dble ( n_tissues ) end do ! === Second pass: assign averaged values by rank === do i_tissue = 1 , n_tissues ! Prepare column and reset permutation do i_gene = 1 , n_genes temp_col ( i_gene ) = input_matrix (( i_tissue - 1 ) * n_genes + i_gene ) perm ( i_gene ) = i_gene end do call sort_array ( temp_col , perm , stack_left , stack_right ) do i_gene = 1 , n_genes output_matrix (( i_tissue - 1 ) * n_genes + perm ( i_gene )) = rank_means ( i_gene ) end do end do end subroutine quantile_normalization !> Apply `log2(x + 1)` transformation to each element of the input matrix. !| This subroutine performs element-wise `log2(x + 1)` transformation on a !| matrix flattened in column-major order. The `log2` is computed via: !| `log(x + 1) / log(2)`, which is numerically equivalent and avoids the !| non-portable `log2` intrinsic for compatibility with WebAssembly (WASM). pure subroutine log2_transformation ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) implicit none !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Flattened input matrix (size: n_genes * n_tissues) real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Output matrix (same size as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes * n_tissues ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! Locals integer ( int32 ) :: i_elem real ( real64 ), parameter :: LOG2 = log ( 2.0d0 ) ! Error handling call set_ok ( ierr ) if ( n_genes <= 0 . or . n_tissues <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! Loop through all elements in the flattened input matrix do i_elem = 1 , n_genes * n_tissues ! Apply the log2(x + 1) transformation output_matrix ( i_elem ) = log ( input_matrix ( i_elem ) + 1.0d0 ) / LOG2 end do end subroutine log2_transformation !> Calculate tissue averages by averaging replicates within each group. !| For each group of tissue replicates, this subroutine computes the average !| expression per gene. The input matrix is column-major, flattened as a 1D array. pure subroutine calc_tiss_avg ( n_gene , n_grps , group_s , group_c , input_matrix , output_matrix , ierr ) implicit none !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_gene !| Number of tissue groups integer ( int32 ), intent ( in ) :: n_grps !| Start column index for each group (length: n_grps) integer ( int32 ), intent ( in ) :: group_s ( n_grps ) !| Number of columns per group (length: n_grps) integer ( int32 ), intent ( in ) :: group_c ( n_grps ) !| Flattened input matrix (length: n_gene * n_col) real ( real64 ), intent ( in ) :: input_matrix ( n_gene * sum ( group_c )) !| Flattened output matrix (length: n_gene * n_grps) real ( real64 ), intent ( out ) :: output_matrix ( n_gene * n_grps ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! === Local variables === integer ( int32 ) :: i_gene , i_group , i_col , j_col real ( real64 ) :: sum_val integer ( int32 ) :: start_idx , count_cols ! Error handling call set_ok ( ierr ) if ( n_gene <= 0 . or . n_grps <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! === Loop over each group === do i_group = 1 , n_grps start_idx = group_s ( i_group ) count_cols = group_c ( i_group ) do i_gene = 1 , n_gene sum_val = 0.0d0 do j_col = 0 , count_cols - 1 i_col = start_idx + j_col sum_val = sum_val + input_matrix (( i_col - 1 ) * n_gene + i_gene ) end do output_matrix (( i_group - 1 ) * n_gene + i_gene ) = sum_val / dble ( count_cols ) end do end do end subroutine calc_tiss_avg !> Calculate `log2 fold changes` between condition and control columns. !| For each control-condition pair, this subroutine computes the `log2 fold change` !| by subtracting the expression value in the control column from the corresponding !| value in the condition column, for all genes. !| !| The input matrix must be column-major and flattened as a 1D array. pure subroutine calc_fchange ( n_genes , n_cols , n_pairs , control_cols , cond_cols , i_matrix , o_matrix , ierr ) implicit none ! === Arguments === !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of columns in the input matrix integer ( int32 ), intent ( in ) :: n_cols !| Number of control-condition pairs integer ( int32 ), intent ( in ) :: n_pairs !| Control column indices (length n_pairs) integer ( int32 ), intent ( in ) :: control_cols ( n_pairs ) !| Condition column indices (length n_pairs) integer ( int32 ), intent ( in ) :: cond_cols ( n_pairs ) !| Input matrix, flattened (length: n_genes × n_cols) real ( real64 ), intent ( in ) :: i_matrix ( n_genes * n_cols ) !| Output matrix for fold changes (length: n_genes × n_pairs) real ( real64 ), intent ( out ) :: o_matrix ( n_genes * n_pairs ) !| Error code integer ( int32 ), intent ( out ) :: ierr ! === Locals === integer ( int32 ) :: i_gene , i_pair integer ( int32 ) :: control_col , cond_col ! Error handling call set_ok ( ierr ) if ( n_genes <= 0 . or . n_cols <= 0 . or . n_pairs <= 0 ) then call set_err ( ierr , ERR_EMPTY_INPUT ) return end if ! === Loop over each pair === do i_pair = 1 , n_pairs control_col = control_cols ( i_pair ) cond_col = cond_cols ( i_pair ) do i_gene = 1 , n_genes o_matrix (( i_pair - 1 ) * n_genes + i_gene ) = & i_matrix (( cond_col - 1 ) * n_genes + i_gene ) - & i_matrix (( control_col - 1 ) * n_genes + i_gene ) end do end do end subroutine calc_fchange end module tox_normalization !> R/Fortran wrapper for normalization by standard deviation. !| Provides an interface for R (.Fortran) and Fortran code to call the normalization routine. subroutine normalize_by_std_dev_r ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Input matrix (n_genes x n_tissues) real ( real64 ), intent ( in ) :: input_matrix ( n_genes , n_tissues ) !| Output normalized matrix (same shape as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes , n_tissues ) !| Error code integer ( int32 ), intent ( out ) :: ierr call normalize_by_std_dev ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) end subroutine normalize_by_std_dev_r !> C/Python wrapper for normalization by standard deviation. !| Provides a C/Python-compatible interface to the normalization routine. subroutine normalize_by_std_dev_c ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) bind ( C , name = \"normalize_by_std_dev_c\" ) use iso_c_binding , only : c_int , c_double , c_f_pointer , c_loc use tox_normalization !| Number of genes (rows) integer ( c_int ), value :: n_genes !| Number of tissues (columns) integer ( c_int ), value :: n_tissues !| Input matrix (flattened, n_genes * n_tissues) real ( c_double ), intent ( in ), target :: input_matrix ( n_genes * n_tissues ) !| Output normalized matrix (flattened, same shape as input) real ( c_double ), intent ( out ), target :: output_matrix ( n_genes * n_tissues ) !| Error code integer ( c_int ), intent ( out ) :: ierr call normalize_by_std_dev ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) end subroutine normalize_by_std_dev_c !> R/Fortran wrapper for quantile normalization. !| Provides an interface for R (.Fortran) and Fortran code to call the quantile normalization routine. subroutine quantile_normalization_r ( n_genes , n_tissues , input_matrix , output_matrix , & temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Stack size for sorting integer ( int32 ), intent ( in ) :: max_stack !| Input matrix (n_genes x n_tissues) real ( real64 ), intent ( in ) :: input_matrix ( n_genes , n_tissues ) !| Output normalized matrix (same shape as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes , n_tissues ) !| Temporary vector for column sorting (size n_genes) real ( real64 ), intent ( out ) :: temp_col ( n_genes ) !| Preallocated vector to store rank means (size n_genes) real ( real64 ), intent ( out ) :: rank_means ( n_genes ) !| Permutation vector (size n_genes) integer ( int32 ), intent ( out ) :: perm ( n_genes ) !| Manual quicksort stack (size max_stack) integer ( int32 ), intent ( out ) :: stack_left ( max_stack ) !| Manual quicksort stack (size max_stack) integer ( int32 ), intent ( out ) :: stack_right ( max_stack ) !| Error code integer ( int32 ), intent ( out ) :: ierr call quantile_normalization ( n_genes , n_tissues , input_matrix , output_matrix , & temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) end subroutine quantile_normalization_r !> C/Python wrapper for quantile normalization. !| Provides a C/Python-compatible interface to the quantile normalization routine. subroutine quantile_normalization_c ( n_genes , n_tissues , input_matrix , output_matrix , & temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) & bind ( C , name = \"quantile_normalization_c\" ) use iso_c_binding , only : c_int , c_double use tox_normalization !| Number of genes (rows) integer ( c_int ), intent ( in ), value :: n_genes !| Number of tissues (columns) integer ( c_int ), intent ( in ), value :: n_tissues !| Stack size for sorting integer ( c_int ), intent ( in ), value :: max_stack !| Input matrix (n_genes x n_tissues) real ( c_double ), intent ( in ), target :: input_matrix ( n_genes , n_tissues ) !| Output normalized matrix (same shape as input) real ( c_double ), intent ( out ), target :: output_matrix ( n_genes , n_tissues ) !| Temporary vector for column sorting (size n_genes) real ( c_double ), intent ( out ), target :: temp_col ( n_genes ) !| Preallocated vector to store rank means (size n_genes) real ( c_double ), intent ( out ), target :: rank_means ( n_genes ) !| Permutation vector (size n_genes) integer ( c_int ), intent ( out ), target :: perm ( n_genes ) !| Manual quicksort stack (size max_stack) integer ( c_int ), intent ( out ), target :: stack_left ( max_stack ) !| Manual quicksort stack (size max_stack) integer ( c_int ), intent ( out ), target :: stack_right ( max_stack ) !| Error code integer ( c_int ), intent ( out ) :: ierr call quantile_normalization ( n_genes , n_tissues , input_matrix , output_matrix , & temp_col , rank_means , perm , stack_left , stack_right , max_stack , ierr ) end subroutine quantile_normalization_c !> R/Fortran wrapper for log2 transformation. !| Provides an interface for R (.Fortran) and Fortran code to call the log2 transformation routine. !| Applies log2(x+1) to each element of the input matrix. Arguments match R's .Fortran calling convention and expect flat arrays. subroutine log2_transformation_r ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Input matrix (flattened, n_genes * n_tissues) real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Output matrix (flattened, same shape as input) real ( real64 ), intent ( out ) :: output_matrix ( n_genes * n_tissues ) !| Error code integer ( int32 ), intent ( out ) :: ierr call log2_transformation ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) end subroutine log2_transformation_r !> C/Python wrapper for log2 transformation. !| Provides a C/Python-compatible interface to the log2 transformation routine. !| Expects flat arrays, matching C calling conventions. Suitable for use with ctypes. !| Applies log2(x+1) to each element of the input matrix. subroutine log2_transformation_c ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) bind ( C , name = \"log2_transformation_c\" ) use iso_c_binding , only : c_int , c_double use tox_normalization !| Number of genes (rows) integer ( c_int ), intent ( in ), value :: n_genes !| Number of tissues (columns) integer ( c_int ), intent ( in ), value :: n_tissues !| Input matrix (flattened, n_genes * n_tissues) real ( c_double ), intent ( in ), target :: input_matrix ( n_genes * n_tissues ) !| Output matrix (flattened, same shape as input) real ( c_double ), intent ( out ), target :: output_matrix ( n_genes * n_tissues ) !| Error code integer ( c_int ), intent ( out ) :: ierr call log2_transformation ( n_genes , n_tissues , input_matrix , output_matrix , ierr ) end subroutine log2_transformation_c !> R/Fortran wrapper for tissue average calculation. !| Provides an interface for R (.Fortran) and Fortran code to call the tissue average calculation routine. !| Computes average expression per gene for each group of tissue replicates. Arguments match R's .Fortran calling convention. subroutine calc_tiss_avg_r ( n_gene , n_grps , group_s , group_c , input_matrix , output_matrix , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_gene !| Number of tissue groups integer ( int32 ), intent ( in ) :: n_grps !| Start column index for each group (length: n_grps) integer ( int32 ), intent ( in ) :: group_s ( n_grps ) !| Number of columns per group (length: n_grps) integer ( int32 ), intent ( in ) :: group_c ( n_grps ) !| Input matrix (flattened, n_gene * sum(group_c)) real ( real64 ), intent ( in ) :: input_matrix ( n_gene * sum ( group_c )) !| Output matrix (flattened, n_gene * n_grps) real ( real64 ), intent ( out ) :: output_matrix ( n_gene * n_grps ) !| Error code integer ( int32 ), intent ( out ) :: ierr call calc_tiss_avg ( n_gene , n_grps , group_s , group_c , input_matrix , output_matrix , ierr ) end subroutine calc_tiss_avg_r !> C/Python wrapper for tissue average calculation. !| Provides a C/Python-compatible interface to the tissue average calculation routine. !| Suitable for use with ctypes. Computes average expression per gene for each group of tissue replicates. subroutine calc_tiss_avg_c ( n_gene , n_grps , group_s , group_c , input_matrix , output_matrix , ierr ) bind ( C , name = \"calc_tiss_avg_c\" ) use iso_c_binding , only : c_int , c_double use tox_normalization !| Number of genes (rows) integer ( c_int ), intent ( in ), value :: n_gene !| Number of tissue groups integer ( c_int ), intent ( in ), value :: n_grps !| Start column index for each group (length: n_grps) integer ( c_int ), intent ( in ), target :: group_s ( n_grps ) !| Number of columns per group (length: n_grps) integer ( c_int ), intent ( in ), target :: group_c ( n_grps ) !| Input matrix (flattened, n_gene * sum(group_c)) real ( c_double ), intent ( in ), target :: input_matrix ( n_gene * sum ( group_c )) !| Output matrix (flattened, n_gene * n_grps) real ( c_double ), intent ( out ) :: output_matrix ( n_gene * n_grps ) !| Error code integer ( c_int ), intent ( out ) :: ierr call calc_tiss_avg ( n_gene , n_grps , group_s , group_c , input_matrix , output_matrix , ierr ) end subroutine calc_tiss_avg_c !> R/Fortran wrapper for fold change calculation. !| Provides an interface for R (.Fortran) and Fortran code to call the fold change calculation routine. !| Computes log2 fold changes between condition and control columns for all genes. Arguments match R's .Fortran calling convention. subroutine calc_fchange_r ( n_genes , n_cols , n_pairs , control_cols , cond_cols , i_matrix , o_matrix , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of columns in the input matrix integer ( int32 ), intent ( in ) :: n_cols !| Number of control-condition pairs integer ( int32 ), intent ( in ) :: n_pairs !| Control column indices (length n_pairs) integer ( int32 ), intent ( in ) :: control_cols ( n_pairs ) !| Condition column indices (length n_pairs) integer ( int32 ), intent ( in ) :: cond_cols ( n_pairs ) !| Input matrix (flattened, n_genes * n_cols) real ( real64 ), intent ( in ) :: i_matrix ( n_genes * n_cols ) !| Output matrix for fold changes (flattened, n_genes * n_pairs) real ( real64 ), intent ( out ) :: o_matrix ( n_genes * n_pairs ) !| Error code integer ( int32 ), intent ( out ) :: ierr call calc_fchange ( n_genes , n_cols , n_pairs , control_cols , cond_cols , i_matrix , o_matrix , ierr ) end subroutine calc_fchange_r !> C/Python wrapper for fold change calculation. !| Provides a C/Python-compatible interface to the fold change calculation routine. !| Suitable for use with ctypes. Computes log2 fold changes between condition and control columns for all genes. subroutine calc_fchange_c ( n_genes , n_cols , n_pairs , control_cols , cond_cols , i_matrix , o_matrix , ierr ) bind ( C , name = \"calc_fchange_c\" ) use iso_c_binding , only : c_int , c_double use tox_normalization !| Number of genes (rows) integer ( c_int ), intent ( in ), value :: n_genes !| Number of columns in the input matrix integer ( c_int ), intent ( in ), value :: n_cols !| Number of control-condition pairs integer ( c_int ), intent ( in ), value :: n_pairs !| Control column indices (length n_pairs) integer ( c_int ), intent ( in ), target :: control_cols ( n_pairs ) !| Condition column indices (length n_pairs) integer ( c_int ), intent ( in ), target :: cond_cols ( n_pairs ) !| Input matrix (flattened, n_genes * n_cols) real ( c_double ), intent ( in ), target :: i_matrix ( n_genes * n_cols ) !| Output matrix for fold changes (flattened, n_genes * n_pairs) real ( c_double ), intent ( out ) :: o_matrix ( n_genes * n_pairs ) !| Error code integer ( c_int ), intent ( out ) :: ierr call calc_fchange ( n_genes , n_cols , n_pairs , control_cols , cond_cols , i_matrix , o_matrix , ierr ) end subroutine calc_fchange_c !> R/Fortran wrapper for normalization pipeline. !| Provides an interface for R (.Fortran) and Fortran code to call the normalization pipeline routine. !| Performs: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation. !| Final result is in buf_log. If fold change is needed, call calc_fchange separately. subroutine normalization_pipeline_r ( n_genes , n_tissues , input_matrix , buf_stddev , buf_quant , buf_avg , buf_log , temp_col , rank_means , perm , stack_left , stack_right , max_stack , group_s , group_c , n_grps , ierr ) use tox_normalization !| Number of genes (rows) integer ( int32 ), intent ( in ) :: n_genes !| Number of tissues (columns) integer ( int32 ), intent ( in ) :: n_tissues !| Number of replicate groups integer ( int32 ), intent ( in ) :: n_grps !| Flattened input matrix (n_genes * n_tissues), column-major real ( real64 ), intent ( in ) :: input_matrix ( n_genes * n_tissues ) !| Buffer for std dev normalization (n_genes * n_tissues) real ( real64 ), intent ( out ) :: buf_stddev ( n_genes * n_tissues ) !| Buffer for quantile normalization (n_genes * n_tissues) real ( real64 ), intent ( out ) :: buf_quant ( n_genes * n_tissues ) !| Buffer for replicate averaging (n_genes * n_grps) real ( real64 ), intent ( out ) :: buf_avg ( n_genes * n_grps ) !| Buffer for log2(x+1) transformation (n_genes * n_grps) real ( real64 ), intent ( out ) :: buf_log ( n_genes * n_grps ) !| Temporary column vector for sorting (n_genes) real ( real64 ), intent ( out ) :: temp_col ( n_genes ) !| Buffer for rank means (n_genes) real ( real64 ), intent ( out ) :: rank_means ( n_genes ) !| Permutation vector for sorting (n_genes) integer ( int32 ), intent ( out ) :: perm ( n_genes ) !| Stack size for quicksort integer ( int32 ), intent ( in ) :: max_stack !| Left stack for quicksort (max_stack) integer ( int32 ), intent ( out ) :: stack_left ( max_stack ) !| Right stack for quicksort (max_stack) integer ( int32 ), intent ( out ) :: stack_right ( max_stack ) !| Start column index for each replicate group (n_grps) integer ( int32 ), intent ( in ) :: group_s ( n_grps ) !| Number of columns per replicate group (n_grps) integer ( int32 ), intent ( in ) :: group_c ( n_grps ) !| Error code integer ( int32 ), intent ( out ) :: ierr call normalization_pipeline ( n_genes , n_tissues , input_matrix , buf_stddev , buf_quant , buf_avg , buf_log , temp_col , rank_means , perm , stack_left , stack_right , max_stack , group_s , group_c , n_grps , ierr ) end subroutine normalization_pipeline_r !> C/Python wrapper for normalization pipeline. !| Provides a C/Python-compatible interface to the normalization pipeline routine. !| Suitable for use with ctypes. Performs: std dev normalization, quantile normalization, replicate averaging, log2(x+1) transformation. !| Final result is in buf_log. If fold change is needed, call calc_fchange separately. subroutine normalization_pipeline_c ( n_genes , n_tissues , input_matrix , buf_stddev , buf_quant , buf_avg , buf_log , temp_col , rank_means , perm , stack_left , stack_right , max_stack , group_s , group_c , n_grps , ierr ) bind ( C , name = \"normalization_pipeline_c\" ) use iso_c_binding , only : c_int , c_double , c_bool use tox_normalization !| Number of genes (rows) integer ( c_int ), intent ( in ), value :: n_genes !| Number of tissues (columns) integer ( c_int ), intent ( in ), value :: n_tissues !| Number of replicate groups integer ( c_int ), intent ( in ), value :: n_grps !| Flattened input matrix (n_genes * n_tissues), column-major real ( c_double ), intent ( in ), target :: input_matrix ( n_genes * n_tissues ) !| Buffer for std dev normalization (n_genes * n_tissues) real ( c_double ), intent ( out ), target :: buf_stddev ( n_genes * n_tissues ) !| Buffer for quantile normalization (n_genes * n_tissues) real ( c_double ), intent ( out ), target :: buf_quant ( n_genes * n_tissues ) !| Buffer for replicate averaging (n_genes * n_grps) real ( c_double ), intent ( out ), target :: buf_avg ( n_genes * n_grps ) !| Buffer for log2(x+1) transformation (n_genes * n_grps) real ( c_double ), intent ( out ), target :: buf_log ( n_genes * n_grps ) !| Temporary column vector for sorting (n_genes) real ( c_double ), intent ( out ), target :: temp_col ( n_genes ) !| Buffer for rank means (n_genes) real ( c_double ), intent ( out ), target :: rank_means ( n_genes ) !| Permutation vector for sorting (n_genes) integer ( c_int ), intent ( out ), target :: perm ( n_genes ) !| Stack size for quicksort integer ( c_int ), intent ( in ), value :: max_stack !| Left stack for quicksort (max_stack) integer ( c_int ), intent ( out ), target :: stack_left ( max_stack ) !| Right stack for quicksort (max_stack) integer ( c_int ), intent ( out ), target :: stack_right ( max_stack ) !| Start column index for each replicate group (n_grps) integer ( c_int ), intent ( in ), target :: group_s ( n_grps ) !| Number of columns per replicate group (n_grps) integer ( c_int ), intent ( in ), target :: group_c ( n_grps ) !| Error code integer ( c_int ), intent ( out ) :: ierr call normalization_pipeline ( n_genes , n_tissues , input_matrix , buf_stddev , buf_quant , buf_avg , buf_log , temp_col , rank_means , perm , stack_left , stack_right , max_stack , group_s , group_c , n_grps , ierr ) end subroutine normalization_pipeline_c","tags":"","url":"sourcefile/tox_normalization.f90.html"},{"title":"deserialize_char.F90 – TensorOmics","text":"Source Code !> Module for deserializing character arrays from files module char_deserialize_mod use , intrinsic :: iso_fortran_env , only : int32 , real64 use array_utils , only : ascii_to_string , read_file_header , check_okay_ioerror , check_okay_ndims use tox_errors implicit none private public :: deserialize_char_1d , deserialize_char_2d , deserialize_char_3d , deserialize_char_flat , & deserialize_char_4d , deserialize_char_5d contains !> Subroutine to deserialize a flat character array from a file subroutine deserialize_char_flat ( flat , dims , clen , filename , ierr ) character ( len = :), pointer , intent ( out ) :: flat (:) !! Output flat character array integer ( int32 ), allocatable , intent ( out ) :: dims (:) !! Output dimensions of the array integer ( int32 ), intent ( out ) :: clen !! Maximum length of character string character ( len =* ), intent ( in ) :: filename !! Name of the file to read integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: ioerror !! Internal I/O error code integer ( int32 ) :: unit , magic , type_code , ndim call set_ok ( ierr ) call set_ok ( ioerror ) ! open file and read header call read_file_header ( filename , unit , type_code , ndim , dims , clen , ierr ) if (. not . is_ok ( ierr )) return ! Allocate output array with stored character length allocate ( character ( len = clen ) :: flat ( product ( dims ))) ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) flat call check_okay_ioerror ( ioerror , ierr , ERR_READ_DATA , unit ) if (. not . is_ok ( ierr )) then deallocate ( flat ) return end if close ( unit ) end subroutine deserialize_char_flat !> Directly deserialize a 1D character array from a file (array already allocated) subroutine deserialize_char_1d ( arr , filename , ierr ) character ( len =* ), intent ( out ) :: arr (:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file to read from integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 1 , unit , ierr ) if (. not . is_ok ( ierr )) return ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_char_1d !> Directly deserialize a 2D character array from a file (array already allocated) subroutine deserialize_char_2d ( arr , filename , ierr ) character ( len =* ), intent ( out ) :: arr (:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 2 , unit , ierr ) if (. not . is_ok ( ierr )) return ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_char_2d !> Directly deserialize a 3D character array from a file (array already allocated) subroutine deserialize_char_3d ( arr , filename , ierr ) character ( len =* ), intent ( out ) :: arr (:,:,:) !!Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 3 , unit , ierr ) if (. not . is_ok ( ierr )) return ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_char_3d !> Directly deserialize a 4D character array from a file (array already allocated) subroutine deserialize_char_4d ( arr , filename , ierr ) character ( len =* ), intent ( out ) :: arr (:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 4 , unit , ierr ) if (. not . is_ok ( ierr )) return ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_char_4d !> Directly deserialize a 5D character array from a file (array already allocated) subroutine deserialize_char_5d ( arr , filename , ierr ) character ( len =* ), intent ( out ) :: arr (:,:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 5 , unit , ierr ) if (. not . is_ok ( ierr )) return ! Read the entire array as a contiguous block read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_char_5d end module char_deserialize_mod !> Subroutine to deserialize a flat character array from a file and return it as an ASCII array callable by R !> @note The array is returned flat and needs to be reshaped in R subroutine deserialize_char_flat_r ( ascii_arr , arr_size , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : int32 use char_deserialize_mod , only : deserialize_char_flat use array_utils , only : ascii_to_string , string_to_ascii_arr use tox_errors , only : set_ok , is_ok implicit none ! Arrays are allocated by R integer ( int32 ), intent ( in ) :: fn_len !! Length of the filename array integer ( int32 ), intent ( in ) :: arr_size !! Size of the ASCII array integer ( int32 ), intent ( out ) :: ascii_arr ( arr_size ) !! Output array of ASCII characters, preallocated by R integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( int32 ), intent ( out ) :: ierr !! Error code character ( len = :), allocatable :: filename !! Filename as a string character ( len = :), pointer :: flat (:) !! Flat character array integer ( int32 ), allocatable :: dims (:) !! Output dimensions of the array integer ( int32 ) :: clen !! Maximum length of character string integer ( int32 ) :: total_array_size !! Total size of the ASCII array call set_ok ( ierr ) call ascii_to_string ( filename_ascii , fn_len , filename ) ! Deserialize flat character array (already trimmed in deserialize_char_flat) call deserialize_char_flat ( flat , dims , clen , filename , ierr ) if (. not . is_ok ( ierr )) then if ( associated ( flat )) DEALLOCATE ( flat ) return end if total_array_size = product ( dims ) ! Write data to ASCII array call string_to_ascii_arr ( flat , total_array_size , ascii_arr , clen ) deallocate ( flat ) end subroutine deserialize_char_flat_r !> C binding for the subroutine to deserialize a flat character array from a file !> @note The array is returned flat and needs to be reshaped in C/python subroutine deserialize_char_flat_C ( ascii_arr , clen , total_array_size , & filename_ascii , fn_len , ierr ) bind ( C , name = \"deserialize_char_flat_C\" ) use iso_c_binding , only : c_int use iso_fortran_env , only : int32 use char_deserialize_mod , only : deserialize_char_flat use array_utils , only : ascii_to_string , string_to_ascii_arr use tox_errors , only : is_ok , set_ok implicit none ! Arguments integer ( c_int ), value :: clen !! Length of each character string integer ( c_int ), value :: total_array_size !! Total size of the ASCII array integer ( c_int ), intent ( out ) :: ascii_arr ( clen * total_array_size ) !! Output array of ASCII characters, preallocated by C/Python (flat) integer ( c_int ), value :: fn_len !! Length of the filename array integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( c_int ), intent ( out ) :: ierr !! error code character ( len = :), allocatable :: filename character ( len = :), pointer :: flat (:) integer ( c_int ), allocatable :: dims (:) integer ( int32 ) :: i , j , actual_clen call set_ok ( ierr ) call ascii_to_string ( filename_ascii , fn_len , filename ) ! Deserialize call deserialize_char_flat ( flat , dims , actual_clen , filename , ierr ) if (. not . is_ok ( ierr )) then if ( associated ( flat )) deallocate ( flat ) return end if ! Convert to ASCII (null-padding), flatten manually call string_to_ascii_arr ( flat , total_array_size , ascii_arr , clen ) deallocate ( flat ) end subroutine","tags":"","url":"sourcefile/deserialize_char.f90.html"},{"title":"serialize_int.F90 – TensorOmics","text":"Source Code !> Module for serializing integer arrays to binary files. module serialize_int use , intrinsic :: iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_loc use array_utils , only : write_file_header use tox_errors implicit none public :: serialize_int_1d , serialize_int_2d , serialize_int_3d , & serialize_int_4d , serialize_int_5d , serialize_int_nd integer ( int32 ), parameter :: ARRAY_TYPE_INT = 1 contains !> Serialize a 1D integer(int32) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_int_1d ( arr , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: ioerror integer ( int32 ) :: dims ( 1 ) dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_INT , 1 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 2D integer(int32) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_int_2d ( arr , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: ioerror integer ( int32 ) :: dims ( 2 ) dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_INT , 2 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 3D integer(int32) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_int_3d ( arr , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: ioerror integer ( int32 ) :: dims ( 3 ) dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_INT , 3 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 4D integer(int32) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_int_4d ( arr , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror integer ( int32 ) :: dims ( 4 ) integer ( int32 ) :: unit dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_INT , 4 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 5D integer(int32) array to a binary file. !! The file will contain a magic number, type code, dimension, shape, and the array data. subroutine serialize_int_5d ( arr , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:,:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit integer ( int32 ) :: ioerror integer ( int32 ) :: dims ( 5 ) dims = shape ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_INT , 5 , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a flat integer array with specified dimensions and number of dimensions to a binary file. !> @note this is called by R subroutine serialize_int_nd ( arr , dims , ndim , filename , ierr ) integer ( int32 ), intent ( in ) :: arr (:) !! Flat integer array to serialize integer ( int32 ), intent ( in ) :: dims (:) !! Dimensions of the array integer ( int32 ), intent ( in ) :: ndim !! Number of dimensions character ( len =* ), intent ( in ) :: filename !! filename integer ( int32 ) :: unit integer ( int32 ), INTENT ( OUT ) :: ierr !! error code integer ( int32 ) :: ioerror call set_ok ( ierr ) call set_ok ( ioerror ) if ( size ( dims ) /= ndim ) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) end if call write_file_header ( filename , unit , ARRAY_TYPE_INT , ndim , dims , ierr ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine end module serialize_int !> Serialize a flat integer array with specified dimensions and number of dimensions to a binary file. !! R can not pass a multidimensional array directly, so we use a flat array and dimensions. Therefore, exposing serialize_int_*d to R is not needed. subroutine serialize_int_flat_r ( arr , array_size , dims , ndim , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : int32 use array_utils use serialize_int , only : serialize_int_nd use tox_errors , only : set_ok implicit none integer ( int32 ), intent ( in ) :: ndim !! Number of dimensions integer ( int32 ), intent ( in ) :: array_size !! Size of the flat array integer ( int32 ), intent ( in ) :: arr ( array_size ) !! Flat integer array to serialize integer ( int32 ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( int32 ), intent ( in ) :: fn_len !! Length of the filename array integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( int32 ), intent ( out ) :: ierr !! Error code character ( len = :), allocatable :: filename integer ( int32 ) :: i , total_len call set_ok ( ierr ) call ascii_to_string ( filename_ascii , fn_len , filename ) total_len = 1 do i = 1 , ndim total_len = total_len * dims ( i ) end do call serialize_int_nd ( arr ( 1 : total_len ), dims ( 1 : ndim ), ndim , filename , ierr ) end subroutine !> C binding for the subroutine to serialize a flat integer array to a binary file. subroutine serialize_int_nd_C ( arr , dims , ndim , filename_ascii , fn_len , ierr ) bind ( C , name = \"serialize_int_nd_C\" ) use iso_c_binding , only : c_ptr , c_int , c_f_pointer use array_utils , only : ascii_to_string use serialize_int , only : serialize_int_nd use tox_errors , only : set_ok use iso_fortran_env , only : int32 implicit none ! input type ( c_ptr ), value :: arr !! Pointer to the flat integer array integer ( c_int ), value :: ndim !! Number of dimensions integer ( c_int ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( c_int ), value :: fn_len !! Length of the filename array integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( c_int ), intent ( out ) :: ierr !! Error code ! Local character ( len = :), allocatable :: filename integer ( c_int ), pointer :: arr_f (:) call set_ok ( ierr ) call ascii_to_string ( filename_ascii , fn_len , filename ) call c_f_pointer ( arr , arr_f , [ product ( dims ( 1 : ndim ))]) ! save call serialize_int_nd ( arr_f , dims , ndim , filename , ierr ) end subroutine","tags":"","url":"sourcefile/serialize_int.f90.html"},{"title":"tox_conversions.F90 – TensorOmics","text":"Source Code module tox_conversions use iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_int , c_double , c_null_char , c_double_complex , c_char use tox_errors , only : ERR_ALLOC_FAIL , is_err , set_ok , set_err implicit none contains !> Converts a c_double value to real64, elemental -> any shape elemental subroutine c_double_as_real64 ( c_val , f_val ) real ( c_double ), intent ( in ) :: c_val !! the element containing the c variant of the number real ( real64 ), intent ( out ) :: f_val !! the element that will hold the real64 representation of the c_double f_val = real ( c_val , kind = real64 ) end subroutine c_double_as_real64 !> Converts a real64 value to c_double, elemental -> any shape elemental subroutine real64_as_c_double ( f_val , c_val ) real ( real64 ), intent ( in ) :: f_val !! the element containing the fortran variant of the number real ( c_double ), intent ( out ) :: c_val !! the element that will hold the c_double representation of the real64 c_val = real ( f_val , kind = c_double ) end subroutine real64_as_c_double !> Converts a c_double_complex value to fortran complex(real64), elemental -> any shape elemental subroutine c_complex_as_complex ( c_val , f_val ) complex ( c_double_complex ), intent ( in ) :: c_val !! the element containing the c variant of the number complex ( real64 ), intent ( out ) :: f_val !! the element that will hold the complex(real64) representation of the c_double_complex f_val = cmplx ( real ( c_val ), aimag ( c_val ), kind = real64 ) end subroutine c_complex_as_complex !> Converts a fortran complex(real64) value to c_double_complex, elemental -> any shape elemental subroutine complex_as_c_complex ( f_val , c_val ) complex ( real64 ), intent ( in ) :: f_val !! the element containing the fortran variant of the number complex ( c_double_complex ), intent ( out ) :: c_val !! the element that will hold the c_double_complex representation of the complex(real64) c_val = cmplx ( real ( f_val ), aimag ( f_val ), kind = c_double_complex ) end subroutine complex_as_c_complex !> Converts a c_int value to int32, elemental -> any shape elemental subroutine c_int_as_int32 ( c_val , f_val ) integer ( c_int ), intent ( in ) :: c_val !! the element containing the c variant of the number integer ( int32 ), intent ( out ) :: f_val !! the element that will hold the int32 representation of the c_int f_val = int ( c_val , kind = int32 ) end subroutine c_int_as_int32 !> Converts a int32 value to c_int, elemental -> any shape elemental subroutine int32_as_c_int ( f_val , c_val ) integer ( int32 ), intent ( in ) :: f_val !! the element containing the fortran variant of the number integer ( c_int ), intent ( out ) :: c_val !! the element that will hold the c_int representation of the int32 c_val = int ( f_val , kind = c_int ) end subroutine int32_as_c_int !> Converts a c_int value to logical, elemental -> any shape elemental subroutine c_int_as_logical ( c_val , f_val ) integer ( c_int ), intent ( in ) :: c_val !! the element containing the c variant of the number logical , intent ( out ) :: f_val !! the element that will hold the logical representation of the c_int: `0` means `.false.`, else `.true.` f_val = c_val /= 0 end subroutine c_int_as_logical !> Converts a logical value to c_int, elemental -> any shape elemental subroutine logical_as_c_int ( f_val , c_val ) logical , intent ( in ) :: f_val !! the element containing the fortran variant of the number integer ( c_int ), intent ( out ) :: c_val !! the element that will hold the c_int representation of the logical: `0` if `.false.`, else `1` if ( f_val ) then c_val = 1 else c_val = 0 end if end subroutine logical_as_c_int !> Converts a c_char value to fortran character, elemental -> any shape elemental subroutine c_char_as_char ( c_val , f_val ) character ( kind = c_char , len = 1 ), intent ( in ) :: c_val !! the element containing the c variant of the character character ( len = 1 ), intent ( out ) :: f_val !! the element that will hold the fortran char representation of the c_char f_val = c_val end subroutine c_char_as_char !> Converts a character value to c_char, elemental -> any shape elemental subroutine char_as_c_char ( f_val , c_val ) character ( len = 1 ), intent ( in ) :: f_val !! the element containing the fortran variant of the character character ( kind = c_char , len = 1 ), intent ( out ) :: c_val !! the element that will hold the c_char (ASCII) representation of the character c_val = f_val end subroutine char_as_c_char !> Converts a 1D c_char array to string pure subroutine c_char_1d_as_string ( c_char_array , str_out , ierr ) character ( kind = c_char , len = 1 ), dimension (:), intent ( in ) :: c_char_array !! c int array, representing characters character ( len = :), allocatable , intent ( out ) :: str_out !! Fortran string, length determined by occuring null char in `c_char_array` integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i , str_len , array_len call set_ok ( ierr ) array_len = size ( c_char_array , 1 ) ! identify string length str_len = array_len do i = 1 , array_len if ( c_char_array ( i ) == c_null_char ) then str_len = i - 1 exit end if end do ! create string allocate ( character ( len = str_len ) :: str_out , stat = ierr ) if ( is_err ( ierr )) then call set_err ( ierr , ERR_ALLOC_FAIL ) return end if do i = 1 , str_len call c_char_as_char ( c_char_array ( i ), str_out ( i : i )) end do end subroutine c_char_1d_as_string !> Converts a string to 1D c_char array pure subroutine string_as_c_char_1d ( str , c_char_array ) character ( len =* ), intent ( in ) :: str !! Fortran string to be converted character ( kind = c_char , len = 1 ), dimension (:), intent ( out ) :: c_char_array !! c int array, representing chars of `str`, will always end with null char. If array too small, it will hold fitting trimmed `str`. integer ( int32 ) :: i_str , str_len ! determine string length to be converted, +1 because of the null char in c str_len = min ( len_trim ( str ) + 1 , size ( c_char_array , 1 )) - 1 do i_str = 1 , str_len call c_char_as_char ( str ( i_str : i_str ), c_char_array ( i_str )) end do if ( size ( c_char_array , 1 ) > 0 ) then c_char_array ( str_len + 1 ) = c_null_char end if end subroutine string_as_c_char_1d !> Converts a 2D c_char array to 1D string array pure subroutine c_char_2d_as_string ( c_char_array , str_out , ierr ) character ( kind = c_char , len = 1 ), dimension (:, :), intent ( in ) :: c_char_array !! c int array, columns as ascii arrays character ( len = :), dimension (:), allocatable , intent ( out ) :: str_out !! Fortran array of resulting strings integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i_str , n_rows , n_strings character ( len = :), allocatable :: string call set_ok ( ierr ) n_rows = size ( c_char_array , 1 ) n_strings = size ( c_char_array , 2 ) allocate ( character ( len = n_rows ) :: str_out ( n_strings ), stat = ierr ) if ( is_err ( ierr )) then call set_err ( ierr , ERR_ALLOC_FAIL ) return end if ! create strings do i_str = 1 , n_strings call c_char_1d_as_string ( c_char_array (:, i_str ), string , ierr ) if ( is_err ( ierr )) return str_out ( i_str ) = string end do end subroutine c_char_2d_as_string !> Converts a 1D string array to 2D c_char array pure subroutine string_as_c_char_2d ( strings , c_char_array ) character ( len =* ), dimension (:), intent ( in ) :: strings !! Fortran array of strings character ( kind = c_char , len = 1 ), dimension (:, :), intent ( out ) :: c_char_array !! c int array, columns as ascii arrays integer ( int32 ) :: i_str , n_strings do i_str = 1 , size ( strings , 1 ) call string_as_c_char_1d ( strings ( i_str ), c_char_array (:, i_str )) end do end subroutine string_as_c_char_2d end module tox_conversions","tags":"","url":"sourcefile/tox_conversions.f90.html"},{"title":"tox_relative_axis_plane_tools.F90 – TensorOmics","text":"Source Code !> Module for tools related to relative axis planes (RAPs), i.e. planes in higher-dimensional gene expression space module relative_axis_plane_tools use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: ieee_arithmetic use tox_errors , only : ERR_OK , ERR_INVALID_INPUT , set_ok , set_err_once , is_ok implicit none contains !> Project selected vectors (e.g. expression vectors) onto the RAP constructed from a selected set of axes. pure subroutine omics_vector_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) real ( real64 ), dimension ( n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with expression vectors integer ( int32 ), intent ( in ) :: n_axes !! number of axes integer ( int32 ), intent ( in ) :: n_vecs !! number of vectors per axis logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` logical , dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( int32 ), intent ( in ) :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( real64 ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i_vec , i_axis , i_vec_proj , i_axis_proj ! Error handling call set_ok ( ierr ) if ( n_selected_vecs < 1 . or . n_selected_axes < 1 ) then projections = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( n_selected_vecs > n_vecs . or . n_selected_axes > n_axes ) then projections = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if i_vec_proj = 1 do i_vec = 1 , n_vecs if ( vecs_selection_mask ( i_vec )) then i_axis_proj = 1 do i_axis = 1 , n_axes if ( axes_selection_mask ( i_axis )) then projections ( i_axis_proj , i_vec_proj ) = vecs ( i_axis , i_vec ) i_axis_proj = i_axis_proj + 1 end if end do i_vec_proj = i_vec_proj + 1 end if end do call project_selected_vecs_onto_rap ( projections , n_selected_axes , n_selected_vecs ) end subroutine omics_vector_RAP_projection !> Project selected vector fields (e.g. shift vectors) onto the RAP constructed from a selected set of axes. pure subroutine omics_field_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) real ( real64 ), dimension ( 2 * n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer ( int32 ), intent ( in ) :: n_axes !! number of axes integer ( int32 ), intent ( in ) :: n_vecs !! number of vectors per axis logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` logical , dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( int32 ), intent ( in ) :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( real64 ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i_vec , i_axis , i_vec_proj , i_axis_proj ! Error handling call set_ok ( ierr ) if ( n_selected_vecs < 1 . or . n_selected_axes < 1 ) then projections = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( n_selected_vecs > n_vecs . or . n_selected_axes > n_axes ) then projections = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if i_vec_proj = 1 do i_vec = 1 , n_vecs if ( vecs_selection_mask ( i_vec )) then i_axis_proj = 1 do i_axis = 1 , n_axes if ( axes_selection_mask ( i_axis )) then ! compute shift vector as difference between origin and target projections ( i_axis_proj , i_vec_proj ) = vecs ( i_axis , i_vec ) - vecs ( i_axis + n_axes , i_vec ) i_axis_proj = i_axis_proj + 1 end if end do i_vec_proj = i_vec_proj + 1 end if end do call project_selected_vecs_onto_rap ( projections , n_selected_axes , n_selected_vecs ) end subroutine omics_field_RAP_projection !> Projects selected vectors onto its RAP pure subroutine project_selected_vecs_onto_rap ( selected_vecs , n_selected_axes , n_selected_vecs ) real ( real64 ), dimension ( n_selected_axes , n_selected_vecs ), intent ( inout ) :: selected_vecs !! matrix with vectors for selected axes integer ( int32 ), intent ( in ) :: n_selected_axes !! number of selected axes integer ( int32 ), intent ( in ) :: n_selected_vecs !! number of selected vectors per axis ! project selected vectors onto RAP integer ( int32 ) :: i_vec , i_axis real ( real64 ) :: diagonal_component do i_vec = 1 , n_selected_vecs ! calculate diagonal component to be subtracted from vectors for projection diagonal_component = 0.0_real64 do i_axis = 1 , n_selected_axes diagonal_component = diagonal_component + selected_vecs ( i_axis , i_vec ) end do diagonal_component = diagonal_component / n_selected_axes ! transform vector to its projection do i_axis = 1 , n_selected_axes selected_vecs ( i_axis , i_vec ) = selected_vecs ( i_axis , i_vec ) - diagonal_component end do end do end subroutine project_selected_vecs_onto_rap !> Compute the signed clock hand angle between two RAP-projected and normalized vectors. !! Calculates the signed rotation angle between two normalized vectors in RAP space. !! For 2D/3D: automatic directionality calculation. For >3D: uses selected axes for directionality. pure subroutine clock_hand_angle_between_vectors ( v1 , v2 , n_dims , signed_angle , selected_axes_for_signed , ierr ) real ( real64 ), dimension ( n_dims ), intent ( in ) :: v1 !! First normalized vector in RAP space real ( real64 ), dimension ( n_dims ), intent ( in ) :: v2 !! Second normalized vector in RAP space integer ( int32 ), intent ( in ) :: n_dims !! Dimension of both vectors real ( real64 ), intent ( out ) :: signed_angle !! Signed angle between vectors in radians [-π, π] integer ( int32 ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer ( int32 ), intent ( out ) :: ierr !! Error code real ( real64 ) :: dot_product , unsigned_angle , orientation_sign integer ( int32 ) :: i ! Error handling call set_ok ( ierr ) if ( n_dims < 1 ) then signed_angle = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! Validate that indices are in range if ( any ( selected_axes_for_signed < 1 ) . or . any ( selected_axes_for_signed > n_dims )) then signed_angle = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! Validate that indices are unique if n_dims > 3 if ( n_dims > 3 ) then if ( selected_axes_for_signed ( 1 ) == selected_axes_for_signed ( 2 ) . or . & selected_axes_for_signed ( 1 ) == selected_axes_for_signed ( 3 ) . or . & selected_axes_for_signed ( 2 ) == selected_axes_for_signed ( 3 )) then signed_angle = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if end if ! Calculate dot product of normalized vectors dot_product = 0.0_real64 do i = 1 , n_dims dot_product = dot_product + v1 ( i ) * v2 ( i ) end do ! Clamp dot product to [-1, 1] to handle numerical precision issues dot_product = max ( - 1.0_real64 , min ( 1.0_real64 , dot_product )) ! Calculate unsigned angle using arccos unsigned_angle = acos ( dot_product ) ! Calculate orientation sign for directionality select case ( n_dims ) case ( 2 ) ! For 2D: use determinant directly orientation_sign = sign ( 1.0_real64 , v1 ( 1 ) * v2 ( 2 ) - v1 ( 2 ) * v2 ( 1 )) case ( 3 ) ! For 3D, use [1,2,3] directly orientation_sign = cross_product_orientation_sign ( v1 , v2 , n_dims , [ 1 , 2 , 3 ]) case ( 4 :) ! For >3D, use selected_axes_for_signed orientation_sign = cross_product_orientation_sign ( v1 , v2 , n_dims , selected_axes_for_signed ) case default orientation_sign = 1.0_real64 end select ! Apply sign to unsigned angle signed_angle = orientation_sign * unsigned_angle end subroutine clock_hand_angle_between_vectors !> Compute signed rotation angles between RAP-projected and normalized vector pairs. !! Takes separate arrays of RAP-projected and normalized vectors (e.g. expression centroids and paralogs) and computes the signed rotation angle between corresponding pairs. !! This measures both magnitude and directionality of angular separation in RAP space. pure subroutine clock_hand_angles_for_shift_vectors ( origins , targets , n_dims , n_vecs , & vecs_selection_mask , & n_selected_vecs , selected_axes_for_signed , & signed_angles , ierr ) real ( real64 ), dimension ( n_dims , n_vecs ), intent ( in ) :: origins !! First set of RAP-projected, normalized vectors (e.g. expression centroids) real ( real64 ), dimension ( n_dims , n_vecs ), intent ( in ) :: targets !! Second set of RAP-projected, normalized vectors (e.g. paralogs) integer ( int32 ), intent ( in ) :: n_dims !! Dimension of each vector in RAP space integer ( int32 ), intent ( in ) :: n_vecs !! Number of vector pairs logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! .true. for vector pairs where angle should be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! Count of .true. values in vecs_selection_mask integer ( int32 ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real ( real64 ), dimension ( n_selected_vecs ), intent ( out ) :: signed_angles !! Signed rotation angles between vector pairs in radians [-π, π] integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: i_vec , i_result ! Error handling call set_ok ( ierr ) if ( n_selected_vecs < 1 . or . n_dims < 1 ) then signed_angles = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if i_result = 1 do i_vec = 1 , n_vecs if ( vecs_selection_mask ( i_vec )) then call clock_hand_angle_between_vectors ( origins (:, i_vec ), targets (:, i_vec ), n_dims , & signed_angles ( i_result ), selected_axes_for_signed , ierr ) if (. not . is_ok ( ierr )) return i_result = i_result + 1 end if end do end subroutine clock_hand_angles_for_shift_vectors !> Compute fractional contribution of each axis to a RAP-projected and normalized shift vector. !! Shared utility: computes fractional contribution of each axis to a RAP-projected and normalized vector. pure subroutine compute_relative_axis_contributions ( vec , n_axes , contributions , ierr ) use , intrinsic :: ieee_arithmetic real ( real64 ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized vector (expression or shift) integer ( int32 ), intent ( in ) :: n_axes !! Number of axes (length of vec and contributions) real ( real64 ), dimension ( n_axes ), intent ( out ) :: contributions !! Fractional contribution of each axis (output), values in [0,1], sum to 1 integer ( int32 ), intent ( out ) :: ierr !! Error code real ( real64 ) :: total_abs integer ( int32 ) :: i_axis ! Error handling call set_ok ( ierr ) if ( n_axes < 1 ) then contributions = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if total_abs = 0.0_real64 do i_axis = 1 , n_axes if ( ieee_is_nan ( vec ( i_axis )) . or . . not . ieee_is_finite ( vec ( i_axis ))) then contributions = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if total_abs = total_abs + abs ( vec ( i_axis )) end do if ( total_abs < 1.0e-8_real64 ) then contributions = 0.0_real64 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if do i_axis = 1 , n_axes contributions ( i_axis ) = abs ( vec ( i_axis )) / total_abs end do end subroutine compute_relative_axis_contributions !> Compute fractional contribution of each axis to a RAP-projected and normalized shift vector. !! Wrapper for shift vectors (e.g. difference between two RAP-projected vectors) pure subroutine relative_axes_changes_from_shift_vector ( vec , n_axes , contributions , ierr ) real ( real64 ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized shift vector integer ( int32 ), intent ( in ) :: n_axes !! Number of axes real ( real64 ), dimension ( n_axes ), intent ( out ) :: contributions !! Fractional contribution of each axis (output), values in [0,1], sum to 1 integer ( int32 ), intent ( out ) :: ierr !! Error code call compute_relative_axis_contributions ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_changes_from_shift_vector !> Compute fractional contribution of each axis to a RAP-projected and normalized expression vector. !! Wrapper for single RAP-projected expression vectors pure subroutine relative_axes_expression_from_expression_vector ( vec , n_axes , contributions , ierr ) real ( real64 ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized expression vector integer ( int32 ), intent ( in ) :: n_axes !! Number of axes real ( real64 ), dimension ( n_axes ), intent ( out ) :: contributions !! Fractional contribution of each axis (output), values in [0,1], sum to 1 integer ( int32 ), intent ( out ) :: ierr !! Error code call compute_relative_axis_contributions ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_expression_from_expression_vector !> Compute orientation sign from cross product of two vectors, using selected axes pure function cross_product_orientation_sign ( a , b , n_dims , selected_axes ) result ( orientation_sign ) real ( real64 ), intent ( in ) :: a ( n_dims ), b ( n_dims ) integer ( int32 ), intent ( in ) :: n_dims integer ( int32 ), intent ( in ) :: selected_axes ( 3 ) real ( real64 ) :: orientation_sign real ( real64 ) :: cross1 , cross2 , cross3 , dotprod cross1 = a ( selected_axes ( 2 )) * b ( selected_axes ( 3 )) - a ( selected_axes ( 3 )) * b ( selected_axes ( 2 )) cross2 = a ( selected_axes ( 3 )) * b ( selected_axes ( 1 )) - a ( selected_axes ( 1 )) * b ( selected_axes ( 3 )) cross3 = a ( selected_axes ( 1 )) * b ( selected_axes ( 2 )) - a ( selected_axes ( 2 )) * b ( selected_axes ( 1 )) dotprod = cross1 * a ( selected_axes ( 1 )) + cross2 * a ( selected_axes ( 2 )) + cross3 * a ( selected_axes ( 3 )) orientation_sign = sign ( 1.0_real64 , dotprod ) end function cross_product_orientation_sign end module relative_axis_plane_tools ! Updated wrappers to pass and return ierr subroutine relative_axes_changes_from_shift_vector_r ( vec , n_axes , contributions , ierr ) use relative_axis_plane_tools , only : relative_axes_changes_from_shift_vector use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized shift vector integer ( int32 ), intent ( in ) :: n_axes !! Number of axes real ( real64 ), dimension ( n_axes ), intent ( out ) :: contributions !! Relative axis contributions (output), values in [0,1], sum to 1 integer ( int32 ), intent ( out ) :: ierr !! Error code call relative_axes_changes_from_shift_vector ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_changes_from_shift_vector_r subroutine relative_axes_changes_from_shift_vector_c ( vec , n_axes , contributions , ierr ) bind ( C , name = \"relative_axes_changes_from_shift_vector_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : relative_axes_changes_from_shift_vector implicit none real ( c_double ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized shift vector integer ( c_int ), intent ( in ), value :: n_axes !! Number of axes real ( c_double ), dimension ( n_axes ), intent ( out ) :: contributions !! Relative axis contributions (output), values in [0,1], sum to 1 integer ( c_int ), intent ( out ) :: ierr !! Error code call relative_axes_changes_from_shift_vector ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_changes_from_shift_vector_c subroutine relative_axes_expression_from_expression_vector_r ( vec , n_axes , contributions , ierr ) use relative_axis_plane_tools , only : relative_axes_expression_from_expression_vector use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized expression vector integer ( int32 ), intent ( in ) :: n_axes !! Number of axes real ( real64 ), dimension ( n_axes ), intent ( out ) :: contributions !! Relative axis contributions (output), values in [0,1], sum to 1 integer ( int32 ), intent ( out ) :: ierr !! Error code call relative_axes_expression_from_expression_vector ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_expression_from_expression_vector_r subroutine relative_axes_expression_from_expression_vector_c ( vec , n_axes , contributions , ierr ) bind ( C , name = \"relative_axes_expression_from_expression_vector_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : relative_axes_expression_from_expression_vector implicit none real ( c_double ), dimension ( n_axes ), intent ( in ) :: vec !! RAP-projected and normalized expression vector integer ( c_int ), intent ( in ), value :: n_axes !! Number of axes real ( c_double ), dimension ( n_axes ), intent ( out ) :: contributions !! Relative axis contributions (output), values in [0,1], sum to 1 integer ( c_int ), intent ( out ) :: ierr !! Error code call relative_axes_expression_from_expression_vector ( vec , n_axes , contributions , ierr ) end subroutine relative_axes_expression_from_expression_vector_c subroutine omics_vector_RAP_projection_r ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) use relative_axis_plane_tools , only : omics_vector_RAP_projection use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with expression vectors integer ( int32 ), intent ( in ) :: n_axes !! number of axes integer ( int32 ), intent ( in ) :: n_vecs !! number of vectors per axis logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` logical , dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( int32 ), intent ( in ) :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( real64 ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( int32 ), intent ( out ) :: ierr !! Error code call omics_vector_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) end subroutine omics_vector_RAP_projection_r subroutine omics_vector_RAP_projection_c ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) bind ( C , name = \"omics_vector_RAP_projection_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : omics_vector_RAP_projection implicit none real ( c_double ), dimension ( n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with expression vectors integer ( c_int ), intent ( in ), value :: n_axes !! number of axes integer ( c_int ), intent ( in ), value :: n_vecs !! number of vectors per axis integer ( c_int ), dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( c_int ), intent ( in ), value :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` integer ( c_int ), dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( c_int ), intent ( in ), value :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( c_double ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( c_int ), intent ( out ) :: ierr !! Error code call omics_vector_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask /= 0 , n_selected_vecs , axes_selection_mask /= 0 , n_selected_axes , projections , ierr ) end subroutine omics_vector_RAP_projection_c subroutine omics_field_RAP_projection_r ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) use relative_axis_plane_tools , only : omics_field_RAP_projection use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer ( int32 ), intent ( in ) :: n_axes !! number of axes integer ( int32 ), intent ( in ) :: n_vecs !! number of vectors per axis logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` logical , dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( int32 ), intent ( in ) :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( real64 ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( int32 ), intent ( out ) :: ierr !! Error code call omics_field_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) end subroutine omics_field_RAP_projection_r subroutine omics_field_RAP_projection_c ( vecs , n_axes , n_vecs , vecs_selection_mask , n_selected_vecs , axes_selection_mask , n_selected_axes , projections , ierr ) bind ( C , name = \"omics_field_RAP_projection_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : omics_field_RAP_projection implicit none real ( c_double ), dimension ( 2 * n_axes , n_vecs ), intent ( in ) :: vecs !! matrix with vector fields, first n rows mean vector origin, last n rows vector targets integer ( c_int ), intent ( in ), value :: n_axes !! number of axes integer ( c_int ), intent ( in ), value :: n_vecs !! number of vectors per axis integer ( c_int ), dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! `.true.` for vectors where projection is to be computed integer ( c_int ), intent ( in ), value :: n_selected_vecs !! count of `.true.` values in `vecs_selection_mask` integer ( c_int ), dimension ( n_axes ), intent ( in ) :: axes_selection_mask !! `.true.` for axes to be included in RAP integer ( c_int ), intent ( in ), value :: n_selected_axes !! count of `.true.` values in `axes_selection_mask` real ( c_double ), dimension ( n_selected_axes , n_selected_vecs ), intent ( out ) :: projections !! projected vectors integer ( c_int ), intent ( out ) :: ierr !! Error code call omics_field_RAP_projection ( vecs , n_axes , n_vecs , vecs_selection_mask /= 0 , n_selected_vecs , axes_selection_mask /= 0 , n_selected_axes , projections , ierr ) end subroutine omics_field_RAP_projection_c subroutine clock_hand_angle_between_vectors_r ( v1 , v2 , n_dims , signed_angle , selected_axes_for_signed , ierr ) use relative_axis_plane_tools , only : clock_hand_angle_between_vectors use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_dims ), intent ( in ) :: v1 !! First normalized vector in RAP space real ( real64 ), dimension ( n_dims ), intent ( in ) :: v2 !! Second normalized vector in RAP space integer ( int32 ), intent ( in ) :: n_dims !! Dimension of both vectors real ( real64 ), intent ( out ) :: signed_angle !! Signed angle between vectors in radians [-π, π] integer ( int32 ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer ( int32 ), intent ( out ) :: ierr !! Error code call clock_hand_angle_between_vectors ( v1 , v2 , n_dims , signed_angle , selected_axes_for_signed , ierr ) end subroutine clock_hand_angle_between_vectors_r subroutine clock_hand_angle_between_vectors_c ( v1 , v2 , n_dims , signed_angle , selected_axes_for_signed , ierr ) bind ( C , name = \"clock_hand_angle_between_vectors_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : clock_hand_angle_between_vectors implicit none real ( c_double ), dimension ( n_dims ), intent ( in ) :: v1 !! First normalized vector in RAP space real ( c_double ), dimension ( n_dims ), intent ( in ) :: v2 !! Second normalized vector in RAP space integer ( c_int ), intent ( in ), value :: n_dims !! Dimension of both vectors real ( c_double ), intent ( out ) :: signed_angle !! Signed angle between vectors in radians [-π, π] integer ( c_int ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) integer ( c_int ), intent ( out ) :: ierr !! Error code call clock_hand_angle_between_vectors ( v1 , v2 , n_dims , signed_angle , selected_axes_for_signed , ierr ) end subroutine clock_hand_angle_between_vectors_c subroutine clock_hand_angles_for_shift_vectors_r ( origins , targets , n_dims , n_vecs , vecs_selection_mask , n_selected_vecs , selected_axes_for_signed , signed_angles , ierr ) use relative_axis_plane_tools , only : clock_hand_angles_for_shift_vectors use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none real ( real64 ), dimension ( n_dims , n_vecs ), intent ( in ) :: origins !! First set of RAP-projected, normalized vectors (e.g. expression centroids) real ( real64 ), dimension ( n_dims , n_vecs ), intent ( in ) :: targets !! Second set of RAP-projected, normalized vectors (e.g. paralogs) integer ( int32 ), intent ( in ) :: n_dims !! Dimension of each vector in RAP space integer ( int32 ), intent ( in ) :: n_vecs !! Number of vector pairs logical , dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! .true. for vector pairs where angle should be computed integer ( int32 ), intent ( in ) :: n_selected_vecs !! Count of .true. values in vecs_selection_mask integer ( int32 ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real ( real64 ), dimension ( n_selected_vecs ), intent ( out ) :: signed_angles !! Signed rotation angles between vector pairs in radians [-π, π] integer ( int32 ), intent ( out ) :: ierr !! Error code call clock_hand_angles_for_shift_vectors ( origins , targets , n_dims , n_vecs , vecs_selection_mask , n_selected_vecs , selected_axes_for_signed , signed_angles , ierr ) end subroutine clock_hand_angles_for_shift_vectors_r subroutine clock_hand_angles_for_shift_vectors_c ( origins , targets , n_dims , n_vecs , vecs_selection_mask , n_selected_vecs , selected_axes_for_signed , signed_angles , ierr ) bind ( C , name = \"clock_hand_angles_for_shift_vectors_c\" ) use iso_c_binding , only : c_double , c_int use relative_axis_plane_tools , only : clock_hand_angles_for_shift_vectors implicit none real ( c_double ), dimension ( n_dims , n_vecs ), intent ( in ) :: origins !! First set of RAP-projected, normalized vectors (e.g. expression centroids) real ( c_double ), dimension ( n_dims , n_vecs ), intent ( in ) :: targets !! Second set of RAP-projected, normalized vectors (e.g. paralogs) integer ( c_int ), intent ( in ), value :: n_dims !! Dimension of each vector in RAP space integer ( c_int ), intent ( in ), value :: n_vecs !! Number of vector pairs integer ( c_int ), dimension ( n_vecs ), intent ( in ) :: vecs_selection_mask !! .true. for vector pairs where angle should be computed integer ( c_int ), intent ( in ), value :: n_selected_vecs !! Count of .true. values in vecs_selection_mask integer ( c_int ), dimension ( 3 ), intent ( in ) :: selected_axes_for_signed !! Indices of 3 axes to use for directionality calculation (ignored if n_dims <= 3) real ( c_double ), dimension ( n_selected_vecs ), intent ( out ) :: signed_angles !! Signed rotation angles between vector pairs in radians [-π, π] integer ( c_int ), intent ( out ) :: ierr !! Error code call clock_hand_angles_for_shift_vectors ( origins , targets , n_dims , n_vecs , vecs_selection_mask /= 0 , n_selected_vecs , selected_axes_for_signed , signed_angles , ierr ) end subroutine clock_hand_angles_for_shift_vectors_c","tags":"","url":"sourcefile/tox_relative_axis_plane_tools.f90.html"},{"title":"tox_get_outliers.F90 – TensorOmics","text":"Source Code !> Module to identify gene outliers based on their distances to family centroids. module tox_get_outliers use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: ieee_arithmetic , only : ieee_is_nan use f42_utils , only : loess_smooth_2d , sort_array use tox_errors , only : ERR_OK , ERR_INVALID_INPUT , set_ok , set_err_once implicit none contains !> Compute family scaling factors (dscale) to normalize distances. !| Uses LOESS on the median/stddev of intra-family distances for scaling, regardless of orthologs. pure subroutine compute_family_scaling ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , family_distances , ierr ) !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( real64 ), intent ( out ) :: dscale ( n_families ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: indices_used ( n_families ) !| Permutation array for sorting gene distances integer ( int32 ), intent ( inout ) :: perm_tmp ( n_genes ) !| Stack array for left indices during sorting integer ( int32 ), intent ( inout ) :: stack_left_tmp ( n_genes ) !| Stack array for right indices during sorting integer ( int32 ), intent ( inout ) :: stack_right_tmp ( n_genes ) !| Pre-allocated work array for family distances (dimension n_genes) real ( real64 ), intent ( out ) :: family_distances ( n_genes ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr integer ( int32 ) :: i , family_idx , n_in_family , n_orth_in_fam real ( real64 ) :: median_dist , stddev_dist , mean_dist , sumsq real ( real64 ), parameter :: default_sigma = 0.5_real64 , default_cutoff = 3.0_real64 real ( real64 ) :: sigma , cutoff integer ( int32 ) :: j , m integer ( int32 ) :: n_valid real ( real64 ) :: loess_pred ( 1 , 1 ) dscale = 0.0_real64 call set_ok ( ierr ) ! Use default values for LOESS sigma = default_sigma cutoff = default_cutoff ! Check for invalid family indices do i = 1 , n_genes if ( gene_to_fam ( i ) < 1 . or . gene_to_fam ( i ) > n_families ) then dscale = - 1.0_real64 ! Set to -1 to indicate error, do not use if ierr /= 0 call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if end do ! First pass: compute median and stddev for each family, and build indices_used for LOESS n_valid = 0 do family_idx = 1 , n_families n_in_family = 0 do i = 1 , n_genes if ( gene_to_fam ( i ) == family_idx ) then n_in_family = n_in_family + 1 family_distances ( n_in_family ) = abs ( distances ( i )) end if end do if ( n_in_family <= 1 ) then loess_x ( family_idx ) = 0.0_real64 loess_y ( family_idx ) = 0.0_real64 cycle end if do j = 1 , n_in_family perm_tmp ( j ) = j stack_left_tmp ( j ) = 0 stack_right_tmp ( j ) = 0 end do call sort_array ( family_distances ( 1 : n_in_family ), perm_tmp ( 1 : n_in_family ), stack_left_tmp ( 1 : n_in_family ), & stack_right_tmp ( 1 : n_in_family )) if ( mod ( n_in_family , 2 ) == 0 ) then median_dist = 0.5_real64 * ( family_distances ( perm_tmp ( n_in_family / 2 )) + family_distances ( perm_tmp ( n_in_family / 2 + 1 ))) else median_dist = family_distances ( perm_tmp (( n_in_family + 1 ) / 2 )) end if mean_dist = sum ( family_distances ( 1 : n_in_family )) / n_in_family sumsq = sum (( family_distances ( 1 : n_in_family ) - mean_dist ) ** 2 ) stddev_dist = sqrt ( sumsq / ( n_in_family - 1 )) loess_x ( family_idx ) = median_dist loess_y ( family_idx ) = stddev_dist n_valid = n_valid + 1 indices_used ( n_valid ) = family_idx end do ! n_valid is now the number of valid families for LOESS ! Only use indices_used(1:n_valid) in LOESS calls ! Second pass: assign dscale per family do family_idx = 1 , n_families n_in_family = 0 do i = 1 , n_genes if ( gene_to_fam ( i ) == family_idx ) then n_in_family = n_in_family + 1 family_distances ( n_in_family ) = abs ( distances ( i )) end if end do if ( n_in_family <= 1 ) then dscale ( family_idx ) = 0.0_real64 cycle ! Skip single-gene or empty families end if if ( n_valid > 0 ) then ! Sort the family distances to compute median do j = 1 , n_in_family perm_tmp ( j ) = j end do call sort_array ( family_distances ( 1 : n_in_family ), perm_tmp ( 1 : n_in_family ), stack_left_tmp ( 1 : n_in_family ), & stack_right_tmp ( 1 : n_in_family )) if ( mod ( n_in_family , 2 ) == 0 ) then median_dist = 0.5_real64 * ( family_distances ( perm_tmp ( n_in_family / 2 )) + family_distances ( perm_tmp ( n_in_family / 2 + 1 ))) else median_dist = family_distances ( perm_tmp (( n_in_family + 1 ) / 2 )) end if ! Only pass first n_valid elements of LOESS arrays call loess_smooth_2d ( n_families , 1 , loess_x , loess_y , indices_used ( 1 : n_valid ), n_valid , [ median_dist ], & sigma , cutoff , loess_pred , ierr ) dscale ( family_idx ) = loess_pred ( 1 , 1 ) else dscale ( family_idx ) = 0.0_real64 end if end do ! ierr already set by set_ok() at the beginning end subroutine compute_family_scaling !> Helper routine that allocates internal arrays and calls compute_family_scaling. !| This makes usage easier since users don't need to care about internal array requirements. pure subroutine compute_family_scaling_alloc ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , ierr ) !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( real64 ), intent ( out ) :: dscale ( n_families ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: indices_used ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr ! Local work arrays real ( real64 ) :: family_distances ( n_genes ) integer ( int32 ) :: perm_tmp ( n_genes ) integer ( int32 ) :: stack_left_tmp ( n_genes ) integer ( int32 ) :: stack_right_tmp ( n_genes ) call compute_family_scaling ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , & family_distances , ierr ) end subroutine compute_family_scaling_alloc !> Compute the hybrid RDI for each gene. !| RDI = Euclidean distance / family scaling factor pure subroutine compute_rdi ( n_genes , distances , gene_to_fam , dscale , rdi , sorted_rdi , perm , & stack_left , stack_right ) implicit none !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Array of Euclidean distances for each gene to its centroid real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Array of scaling factors for each family real ( real64 ), intent ( in ) :: dscale (:) !| Output array of RDI values for each gene real ( real64 ), intent ( out ) :: rdi ( n_genes ) !| Work array for sorting (dimension n_genes) real ( real64 ), intent ( inout ) :: sorted_rdi ( n_genes ) !| Permutation array for sorting (dimension n_genes, should be pre-initialized with 1:n_genes) integer ( int32 ), intent ( inout ) :: perm ( n_genes ) !| Stack array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: stack_left ( n_genes ) !| Stack array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: stack_right ( n_genes ) integer ( int32 ) :: i , family_idx real ( real64 ), parameter :: tol = epsilon ( 1.0_real64 ) ! Calculate RDI for each gene do i = 1 , n_genes family_idx = gene_to_fam ( i ) ! Handle invalid family indices if ( family_idx < 1 . or . family_idx > size ( dscale )) then rdi ( i ) = - 1.0_real64 ! Error indicator cycle end if ! Detect NaN input (portable) if ( ieee_is_nan ( distances ( i ))) then rdi ( i ) = distances ( i ) else if ( abs ( dscale ( family_idx )) < tol ) then rdi ( i ) = 0.0_real64 ! If scaling is zero, set RDI to zero (not outlier) else ! Calculate RDI rdi ( i ) = abs ( distances ( i )) / dscale ( family_idx ) end if end do ! Create a copy of RDI for sorting (excluding error values) sorted_rdi = rdi ! Filter out error values (negative RDIs) where ( sorted_rdi < 0.0_real64 ) sorted_rdi = 0.0_real64 end where ! Sort RDI values using the tox_sorting module call sort_array ( sorted_rdi , perm , stack_left , stack_right ) end subroutine compute_rdi !> Identify gene outliers based on the top percentile of RDI values. !| Expects sorted_rdi to be filtered (no negative values) and sorted in ascending order before calling. !| If sorted_rdi contains negatives or is not sorted, results may be invalid. pure subroutine identify_outliers ( n_genes , rdi , sorted_rdi , is_outlier , threshold , percentile ) implicit none !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Array of RDI values for each gene real ( real64 ), intent ( in ) :: rdi ( n_genes ) !| Sorted RDI array (must be filtered to remove negatives and sorted in ascending order before calling) real ( real64 ), intent ( in ) :: sorted_rdi ( n_genes ) !| Output boolean array indicating outliers logical , intent ( out ) :: is_outlier ( n_genes ) !| Output threshold value used for detection real ( real64 ), intent ( out ) :: threshold !| (optional) Percentile threshold (default: 95 for top 5%) real ( real64 ), intent ( in ), optional :: percentile integer ( int32 ) :: i , idx real ( real64 ) :: perc_pos , percentile_val ! Set default percentile if not present if ( present ( percentile )) then percentile_val = percentile else percentile_val = 9 5.0_real64 end if ! Initialize output is_outlier = . false . ! Calculate the position corresponding to the desired percentile perc_pos = ( n_genes * percentile_val ) / 10 0.0_real64 idx = ceiling ( perc_pos ) ! Clamp idx to valid range if ( idx < 1 ) idx = 1 if ( idx > n_genes ) idx = n_genes ! Get the threshold value from the sorted array (sorted_rdi must be ascending) threshold = sorted_rdi ( idx ) ! Mark genes as outliers if their RDI exceeds the threshold (and is positive) do i = 1 , n_genes is_outlier ( i ) = ( rdi ( i ) >= threshold . and . rdi ( i ) > 0.0_real64 ) end do end subroutine identify_outliers !> Main routine to detect outliers using RDI and LOESS-based scaling. pure subroutine detect_outliers ( n_genes , n_families , distances , gene_to_fam , & work_array , perm , stack_left , stack_right , & is_outlier , loess_x , loess_y , loess_n , ierr , & percentile ) implicit none !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene to its centroid real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Work array for sorting (dimension n_genes) real ( real64 ), intent ( inout ) :: work_array ( n_genes ) !| Permutation array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: perm ( n_genes ) !| Stack array for left indices during sorting integer ( int32 ), intent ( inout ) :: stack_left ( n_genes ) !| Stack array for right indices during sorting integer ( int32 ), intent ( inout ) :: stack_right ( n_genes ) !| Output boolean array indicating outliers logical , intent ( out ) :: is_outlier ( n_genes ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: loess_n ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr !| (optional) Percentile threshold for outlier detection (default: 95) real ( real64 ), intent ( in ), optional :: percentile ! Local variables real ( real64 ) :: dscale ( n_families ) real ( real64 ) :: rdi ( n_genes ) real ( real64 ) :: threshold integer ( int32 ) :: i real ( real64 ) :: percentile_val ! Set default percentile if not present if ( present ( percentile )) then percentile_val = percentile else percentile_val = 9 5.0_real64 end if ! Always initialize permutation array do i = 1 , n_genes perm ( i ) = i end do call compute_family_scaling_alloc ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , loess_n , ierr ) if ( ierr /= 0 ) return call compute_rdi ( n_genes , distances , gene_to_fam , dscale , rdi , work_array , perm , stack_left , stack_right ) call identify_outliers ( n_genes , rdi , work_array , is_outlier , threshold , percentile_val ) end subroutine detect_outliers end module tox_get_outliers !> R wrapper for compute_family_scaling (expert version with pre-allocated arrays). !| Calls compute_family_scaling with standard Fortran types for R interface. !| This version requires pre-allocated work arrays for maximum performance and control. subroutine compute_family_scaling_expert_r ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , family_distances , ierr ) use tox_get_outliers use iso_fortran_env , only : real64 , int32 !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( real64 ), intent ( out ) :: dscale ( n_families ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: indices_used ( n_families ) !| Permutation array for sorting gene distances integer ( int32 ), intent ( inout ) :: perm_tmp ( n_genes ) !| Stack array for left indices during sorting integer ( int32 ), intent ( inout ) :: stack_left_tmp ( n_genes ) !| Stack array for right indices during sorting integer ( int32 ), intent ( inout ) :: stack_right_tmp ( n_genes ) !| Pre-allocated work array for family distances (dimension n_genes) real ( real64 ), intent ( out ) :: family_distances ( n_genes ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr call compute_family_scaling ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , family_distances , ierr ) end subroutine compute_family_scaling_expert_r !> R wrapper for compute_family_scaling (main version with automatic allocation). !| Calls compute_family_scaling_alloc with standard Fortran types for R interface. !| This is the recommended version for most users as it handles memory allocation automatically. subroutine compute_family_scaling_r ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , ierr ) use tox_get_outliers use iso_fortran_env , only : real64 , int32 !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( real64 ), intent ( out ) :: dscale ( n_families ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: indices_used ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr call compute_family_scaling_alloc ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , ierr ) end subroutine compute_family_scaling_r !> R wrapper for compute_rdi. !| Calls compute_rdi with standard Fortran types for R interface. !| Outputs both unsorted and sorted RDI, permutation, and sorting workspace arrays for downstream use. subroutine compute_rdi_r ( n_genes , n_families , distances , gene_to_fam , dscale , rdi , sorted_rdi , perm , stack_left , stack_right ) use tox_get_outliers use iso_fortran_env , only : real64 , int32 !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene to its centroid real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Array of scaling factors for each family real ( real64 ), intent ( in ) :: dscale ( n_families ) !| Output array of RDI values for each gene real ( real64 ), intent ( out ) :: rdi ( n_genes ) !| Work array for sorting (dimension n_genes) real ( real64 ), intent ( inout ) :: sorted_rdi ( n_genes ) !| Permutation array for sorting (dimension n_genes, should be pre-initialized with 1:n_genes) integer ( int32 ), intent ( inout ) :: perm ( n_genes ) !| Stack array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: stack_left ( n_genes ) !| Stack array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: stack_right ( n_genes ) call compute_rdi ( n_genes , distances , gene_to_fam , dscale , rdi , sorted_rdi , perm , stack_left , stack_right ) end subroutine compute_rdi_r !> R wrapper for identify_outliers. !| Calls identify_outliers with standard Fortran types for R interface. subroutine identify_outliers_r ( n_genes , rdi , sorted_rdi , is_outlier , threshold , percentile ) use tox_get_outliers use iso_fortran_env , only : real64 , int32 !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Array of RDI values for each gene real ( real64 ), intent ( in ) :: rdi ( n_genes ) !| Sorted RDI array (must be filtered to remove negatives and sorted in ascending order before calling) real ( real64 ), intent ( in ) :: sorted_rdi ( n_genes ) !| Output boolean array indicating outliers logical , intent ( out ) :: is_outlier ( n_genes ) !| Output threshold value used for detection real ( real64 ), intent ( out ) :: threshold !| Percentile threshold (default: 95 for top 5%) real ( real64 ), intent ( in ) :: percentile call identify_outliers ( n_genes , rdi , sorted_rdi , is_outlier , threshold , percentile ) end subroutine identify_outliers_r !> R wrapper for detect_outliers. !| Calls detect_outliers with standard Fortran types for R interface. subroutine detect_outliers_r ( n_genes , n_families , distances , gene_to_fam , & work_array , perm , stack_left , stack_right , & is_outlier , loess_x , loess_y , loess_n , ierr , & percentile ) use tox_get_outliers use iso_fortran_env , only : real64 , int32 !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Array of Euclidean distances for each gene to its centroid real ( real64 ), intent ( in ) :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Work array for sorting (dimension n_genes) real ( real64 ), intent ( inout ) :: work_array ( n_genes ) !| Permutation array for sorting (dimension n_genes) integer ( int32 ), intent ( inout ) :: perm ( n_genes ) !| Stack array for left indices during sorting integer ( int32 ), intent ( inout ) :: stack_left ( n_genes ) !| Stack array for right indices during sorting integer ( int32 ), intent ( inout ) :: stack_right ( n_genes ) !| Output boolean array indicating outliers logical , intent ( out ) :: is_outlier ( n_genes ) !| Reference x-coordinates. real ( real64 ), intent ( inout ) :: loess_x ( n_families ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( inout ) :: loess_y ( n_families ) !| Indices of reference points used for smoothing. integer ( int32 ), intent ( inout ) :: loess_n ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( int32 ), intent ( out ) :: ierr !| (optional) Percentile threshold for outlier detection (default: 95) real ( real64 ), intent ( in ), optional :: percentile call detect_outliers ( n_genes , n_families , distances , gene_to_fam , & work_array , perm , stack_left , stack_right , & is_outlier , loess_x , loess_y , loess_n , ierr , & percentile ) end subroutine detect_outliers_r ! C wrappers for RDI/outlier routines !> C wrapper for compute_family_scaling (expert version with pre-allocated arrays). !| Calls compute_family_scaling with C-compatible types for external interface. !| This version requires pre-allocated work arrays for maximum performance and control. subroutine compute_family_scaling_expert_c ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , & family_distances , ierr ) bind ( C , name = \"compute_family_scaling_expert_c\" ) use iso_c_binding , only : c_int , c_double use tox_get_outliers !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes , n_families !| Array of Euclidean distances for each gene real ( c_double ), intent ( in ), target :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( c_int ), intent ( in ), target :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( c_double ), intent ( out ), target :: dscale ( n_families ) !| Reference x-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_x ( n_families ) !| Reference y-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_y ( n_families ) !| Indices of reference points used for smoothing integer ( c_int ), intent ( inout ), target :: indices_used ( n_families ) !| Permutation array for sorting gene distances integer ( c_int ), intent ( inout ), target :: perm_tmp ( n_genes ) !| Stack array for left indices during sorting integer ( c_int ), intent ( inout ), target :: stack_left_tmp ( n_genes ) !| Stack array for right indices during sorting integer ( c_int ), intent ( inout ), target :: stack_right_tmp ( n_genes ) !| Pre-allocated work array for family distances (dimension n_genes) real ( c_double ), intent ( out ), target :: family_distances ( n_genes ) !| Error code: 0=ok, 201=invalid family indices integer ( c_int ), intent ( out ) :: ierr call compute_family_scaling ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , perm_tmp , stack_left_tmp , stack_right_tmp , family_distances , ierr ) end subroutine compute_family_scaling_expert_c !> C wrapper for compute_family_scaling (main version with automatic allocation). !| Calls compute_family_scaling_alloc with C-compatible types for external interface. !| This is the recommended version for most users as it handles memory allocation automatically. subroutine compute_family_scaling_c ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , ierr ) bind ( C , name = \"compute_family_scaling_c\" ) use iso_c_binding , only : c_int , c_double use tox_get_outliers !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes , n_families !| Array of Euclidean distances for each gene real ( c_double ), intent ( in ), target :: distances ( n_genes ) !| Mapping of each gene to its family (1-based) integer ( c_int ), intent ( in ), target :: gene_to_fam ( n_genes ) !| Output: array of scaling factors per family real ( c_double ), intent ( out ), target :: dscale ( n_families ) !| Reference x-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_x ( n_families ) !| Reference y-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_y ( n_families ) !| Indices of reference points used for smoothing integer ( c_int ), intent ( inout ), target :: indices_used ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( c_int ), intent ( out ) :: ierr call compute_family_scaling_alloc ( n_genes , n_families , distances , gene_to_fam , dscale , & loess_x , loess_y , indices_used , ierr ) end subroutine compute_family_scaling_c !> C wrapper for compute_rdi. !| Calls compute_rdi with C-compatible types for external interface. !| Outputs both unsorted and sorted RDI, permutation, and sorting workspace arrays for downstream use. subroutine compute_rdi_c ( n_genes , n_families , distances , gene_to_fam , dscale , rdi , sorted_rdi , perm , stack_left , stack_right ) bind ( C , name = \"compute_rdi_c\" ) use iso_c_binding , only : c_int , c_double use tox_get_outliers !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes , n_families !| Array of Euclidean distances for each gene to its centroid real ( c_double ), intent ( in ), target :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( c_int ), intent ( in ), target :: gene_to_fam ( n_genes ) !| Array of scaling factors for each family real ( c_double ), intent ( in ), target :: dscale ( n_families ) !| Output array of RDI values for each gene (unsorted) real ( c_double ), intent ( out ), target :: rdi ( n_genes ) !| Output array of sorted RDI values (filtered, sorted) real ( c_double ), intent ( out ), target :: sorted_rdi ( n_genes ) !| Output permutation array for sorting (dimension n_genes) integer ( c_int ), intent ( out ), target :: perm ( n_genes ) !| Output stack array for left indices during sorting integer ( c_int ), intent ( out ), target :: stack_left ( n_genes ) !| Output stack array for right indices during sorting integer ( c_int ), intent ( out ), target :: stack_right ( n_genes ) call compute_rdi ( n_genes , distances , gene_to_fam , dscale , rdi , sorted_rdi , perm , stack_left , stack_right ) end subroutine compute_rdi_c !> C wrapper for identify_outliers. !| Calls identify_outliers with C-compatible types for external interface. subroutine identify_outliers_c ( n_genes , rdi , sorted_rdi , is_outlier_int , threshold , percentile ) & bind ( C , name = \"identify_outliers_c\" ) use iso_c_binding , only : c_int , c_double use tox_get_outliers !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes !| Array of RDI values for each gene real ( c_double ), intent ( in ), target :: rdi ( n_genes ) !| Sorted RDI array (must be sorted in ascending order before calling) real ( c_double ), intent ( in ), target :: sorted_rdi ( n_genes ) !| Output integer array indicating outliers (1=outlier, 0=not) integer ( c_int ), intent ( out ), target :: is_outlier_int ( n_genes ) !| Output threshold value used for detection real ( c_double ), intent ( out ) :: threshold !| Percentile threshold for outlier detection real ( c_double ), intent ( in ), value :: percentile logical :: is_outlier ( n_genes ) integer :: i ! Convert integer (0/1) to logical (.false./.true.) for is_outlier do i = 1 , n_genes is_outlier ( i ) = ( is_outlier_int ( i ) /= 0 ) end do call identify_outliers ( n_genes , rdi , sorted_rdi , is_outlier , threshold , percentile ) ! Convert logical (.true./.false.) to integer (1/0) do i = 1 , n_genes if ( is_outlier ( i )) then is_outlier_int ( i ) = 1 else is_outlier_int ( i ) = 0 end if end do end subroutine identify_outliers_c !> C wrapper for detect_outliers. !| Calls detect_outliers with C-compatible types for external interface. subroutine detect_outliers_c ( n_genes , n_families , distances , gene_to_fam , & work_array , perm , stack_left , stack_right , & is_outlier_int , loess_x , loess_y , loess_n , ierr , & percentile ) bind ( C , name = \"detect_outliers_c\" ) use iso_c_binding , only : c_int , c_double use tox_get_outliers !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes , n_families !| Array of Euclidean distances for each gene to its centroid real ( c_double ), intent ( in ), target :: distances ( n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( c_int ), intent ( in ), target :: gene_to_fam ( n_genes ) !| Work array for sorting (dimension n_genes) real ( c_double ), intent ( inout ), target :: work_array ( n_genes ) !| Permutation array for sorting (dimension n_genes) integer ( c_int ), intent ( inout ), target :: perm ( n_genes ) !| Stack array for left indices during sorting integer ( c_int ), intent ( inout ), target :: stack_left ( n_genes ) !| Stack array for right indices during sorting integer ( c_int ), intent ( inout ), target :: stack_right ( n_genes ) !| Output integer array indicating outliers (1=outlier, 0=not) integer ( c_int ), intent ( out ), target :: is_outlier_int ( n_genes ) !| Reference x-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_x ( n_families ) !| Reference y-coordinates for LOESS real ( c_double ), intent ( inout ), target :: loess_y ( n_families ) !| Indices of reference points used for smoothing integer ( c_int ), intent ( inout ), target :: loess_n ( n_families ) !| Error code: 0=ok, 201=invalid family indices integer ( c_int ), intent ( out ) :: ierr !| Percentile threshold for outlier detection real ( c_double ), intent ( in ), value :: percentile logical :: is_outlier ( n_genes ) integer :: i call detect_outliers ( n_genes , n_families , distances , gene_to_fam , & work_array , perm , stack_left , stack_right , & is_outlier , loess_x , loess_y , loess_n , ierr , & percentile ) ! Convert logical (.true./.false.) to integer (1/0) for is_outlier do i = 1 , n_genes if ( is_outlier ( i )) then is_outlier_int ( i ) = 1 else is_outlier_int ( i ) = 0 end if end do end subroutine detect_outliers_c","tags":"","url":"sourcefile/tox_get_outliers.f90.html"},{"title":"tox_euclidean_distance.F90 – TensorOmics","text":"Source Code !> Module with Euclidean distance computation routines for tensor omics. module tox_euclidean_distance use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none contains !> Compute the Euclidean distance between two vectors. !| Calculates the L2 norm: result = sqrt(sum((vec1_i - vec2_i)&#94;2)) pure subroutine euclidean_distance ( vec1 , vec2 , d , result ) !| Dimension of both vectors integer ( int32 ), intent ( in ) :: d !| First expression vector real ( real64 ), intent ( in ) :: vec1 ( d ) !| Second expression vector real ( real64 ), intent ( in ) :: vec2 ( d ) !| Output scalar distance real ( real64 ), intent ( out ) :: result integer ( int32 ) :: i real ( real64 ) :: sum_squared_diff sum_squared_diff = 0.0_real64 do i = 1 , d sum_squared_diff = sum_squared_diff + ( vec1 ( i ) - vec2 ( i )) ** 2 end do result = sqrt ( sum_squared_diff ) end subroutine euclidean_distance !> Compute distance from each gene to its corresponding family centroid. !| For each gene, extracts its expression vector and the centroid of its assigned family, then computes the Euclidean distance between them. pure subroutine distance_to_centroid ( n_genes , n_families , genes , centroids , & gene_to_fam , distances , d ) !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Expression vector dimension integer ( int32 ), intent ( in ) :: d !| Gene expression matrix (d × n_genes), column-major real ( real64 ), intent ( in ) :: genes ( d , n_genes ) !| Family centroid matrix (d × n_families), column-major real ( real64 ), intent ( in ) :: centroids ( d , n_families ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output distances array real ( real64 ), intent ( out ) :: distances ( n_genes ) integer ( int32 ) :: i , family_idx do i = 1 , n_genes family_idx = gene_to_fam ( i ) if ( family_idx < 1 . or . family_idx > n_families ) then distances ( i ) = - 1.0_real64 ! Error indicator cycle end if call euclidean_distance ( genes (:, i ), centroids (:, family_idx ), d , distances ( i )) end do end subroutine distance_to_centroid end module tox_euclidean_distance !> R wrapper for euclidean_distance. !| Calls euclidean_distance with standard Fortran types for R interface. subroutine euclidean_distance_r ( vec1 , vec2 , d , result ) use tox_euclidean_distance !| Dimension of both vectors integer ( int32 ), intent ( in ) :: d !| First expression vector real ( real64 ), intent ( in ) :: vec1 ( d ) !| Second expression vector real ( real64 ), intent ( in ) :: vec2 ( d ) !| Output scalar distance real ( real64 ), intent ( out ) :: result call euclidean_distance ( vec1 , vec2 , d , result ) end subroutine euclidean_distance_r !> C wrapper for euclidean_distance. !| Exposes euclidean_distance to C via iso_c_binding types. subroutine euclidean_distance_c ( vec1 , vec2 , d , result ) bind ( C , name = \"euclidean_distance_c\" ) use iso_c_binding , only : c_int , c_double use tox_euclidean_distance !| Dimension of both vectors integer ( c_int ), intent ( in ), value :: d !| First expression vector real ( c_double ), intent ( in ), target :: vec1 ( d ) !| Second expression vector real ( c_double ), intent ( in ), target :: vec2 ( d ) !| Output scalar distance real ( c_double ), intent ( out ) :: result call euclidean_distance ( vec1 , vec2 , d , result ) end subroutine euclidean_distance_c !> R wrapper for distance_to_centroid. !| Calls distance_to_centroid with standard Fortran types for R interface. subroutine distance_to_centroid_r ( n_genes , n_families , genes , centroids , & gene_to_fam , distances , d ) use tox_euclidean_distance !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families integer ( int32 ), intent ( in ) :: n_families !| Expression vector dimension integer ( int32 ), intent ( in ) :: d !| Gene expression matrix (d × n_genes), column-major real ( real64 ), intent ( in ) :: genes ( d , n_genes ) !| Family centroid matrix (d × n_families), column-major real ( real64 ), intent ( in ) :: centroids ( d , n_families ) !| Gene-to-family mapping (1-based indexing) integer ( int32 ), intent ( in ) :: gene_to_fam ( n_genes ) !| Output distances array real ( real64 ), intent ( out ) :: distances ( n_genes ) call distance_to_centroid ( n_genes , n_families , genes , centroids , & gene_to_fam , distances , d ) end subroutine distance_to_centroid_r !> C wrapper for distance_to_centroid. !| Exposes distance_to_centroid to C via iso_c_binding types. subroutine distance_to_centroid_c ( n_genes , n_families , genes , centroids , & gene_to_fam , distances , d ) bind ( C , name = \"distance_to_centroid_c\" ) use iso_c_binding , only : c_int , c_double use tox_euclidean_distance !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes !| Total number of gene families integer ( c_int ), intent ( in ), value :: n_families !| Expression vector dimension integer ( c_int ), intent ( in ), value :: d !| Gene expression matrix (d × n_genes), column-major real ( c_double ), intent ( in ), target :: genes ( d , n_genes ) !| Family centroid matrix (d × n_families), column-major real ( c_double ), intent ( in ), target :: centroids ( d , n_genes ) !| Gene-to-family mapping (1-based indexing) integer ( c_int ), intent ( in ), target :: gene_to_fam ( n_genes ) !| Output distances array real ( c_double ), intent ( out ), target :: distances ( n_genes ) call distance_to_centroid ( n_genes , n_families , genes , centroids , & gene_to_fam , distances , d ) end subroutine distance_to_centroid_c","tags":"","url":"sourcefile/tox_euclidean_distance.f90.html"},{"title":"tox_shift_vectors.F90 – TensorOmics","text":"Source Code !> Module for computing the shift vector field for all genes. module tox_shift_vectors use , intrinsic :: iso_fortran_env , only : real64 , int32 use tox_errors , only : ERR_INVALID_INPUT , ERR_EMPTY_INPUT , set_ok , set_err_once contains !> Compute the shift vector field for all genes. !| Computes the shift vectors by substracting the corresponding family centroid from the expression vector. pure subroutine compute_shift_vector_field ( d , n_genes , n_families , expression_vectors , family_centroids , & gene_to_centroid , shift_vectors , ierr ) implicit none !| Expression vector dimension integer ( int32 ), intent ( in ) :: d !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of families integer ( int32 ), intent ( in ) :: n_families !| Gene expression matrix (d × n_genes) real ( real64 ), intent ( in ) :: expression_vectors ( d , n_genes ) !| Family centroid matrix (d × n_families) real ( real64 ), intent ( in ) :: family_centroids ( d , n_families ) !| Mapping from genes to family centroids to genes of `expression_vectors` -> `family_centroids(:, gene_to_centroid(n))` returns the family centroid of `expression_vectors(:,n)` integer ( int32 ), intent ( in ) :: gene_to_centroid ( n_genes ) !| Output, real matrix array, size = 2d x `n_genes`, stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d real ( real64 ), intent ( out ) :: shift_vectors ( 2 * d , n_genes ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr !| Local variables integer ( int32 ) :: current_gene , current_centroid , i ! Initialize error code call set_ok ( ierr ) ! Check for correct 0 dimension if ( d == 0 . or . n_genes == 0 . or . n_families == 0 ) then call set_err_once ( ierr , ERR_EMPTY_INPUT ) return end if ! For each gene do do current_gene = 1 , n_genes ! Check if `gene_to_centroid` mapping is in valid range (length of `family_centroids` array) if ( gene_to_centroid ( current_gene ) < 1 . or . gene_to_centroid ( current_gene ) > n_families ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! Get current centroid index from `current_gene` current_centroid = gene_to_centroid ( current_gene ) ! Copy family centroid to first half of the `shift_vectors` shift_vectors ( 1 : d , current_gene ) = family_centroids (:, current_centroid ) ! Substract family centroid from `expression_vector` and write it to second half of the `shift_vectors` do i = 1 , d shift_vectors ( d + i , current_gene ) = expression_vectors ( i , current_gene ) - family_centroids ( i , current_centroid ) end do end do end subroutine end module !> R wrapper for `compute_shift_vector_field` !| Calls `compute_shift_vector_field` with standard Fortran types for R interface. !| When using these R wrapper functions, copies of the arrays will be created. No direct modification of the original R objects occurs.. pure subroutine compute_shift_vector_field_r ( d , n_genes , n_families , expression_vectors , family_centroids , & gene_to_centroid , shift_vectors , ierr ) use tox_shift_vectors !| Expression vector dimension integer ( int32 ), intent ( in ) :: d !| Total number of genes integer ( int32 ), intent ( in ) :: n_genes !| Total number of families integer ( int32 ), intent ( in ) :: n_families !| Gene expression matrix `(d × n_genes)` real ( real64 ), intent ( in ) :: expression_vectors ( d , n_genes ) !| Family centroid matrix `(d × n_families)` real ( real64 ), intent ( in ) :: family_centroids ( d , n_families ) !| Mapping from genes to family centroids to genes of `expression_vectors` -> `family_centroids(:, gene_to_centroid(n))` returns the family centroid of `expression_vectors(:,n)` integer ( int32 ), intent ( in ) :: gene_to_centroid ( n_genes ) !| Output, real matrix array, size = 2d x `n_genes`, stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d real ( real64 ), intent ( out ) :: shift_vectors ( 2 * d , n_genes ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr call compute_shift_vector_field ( d , n_genes , n_families , expression_vectors , family_centroids , & gene_to_centroid , shift_vectors , ierr ) end subroutine compute_shift_vector_field_r !> C wrapper for `compute_shift_vector_field`. !| Exposes `compute_shift_vector_field` to C via iso_c_binding types with explicit dimensions. !| When using these C wrapper functions, no copies of the arrays will be created. The Fortran routine will operate directly on the memory provided by the caller. pure subroutine compute_shift_vector_field_c ( d , n_genes , n_families , expression_vectors , family_centroids , gene_to_centroid , & shift_vectors , ierr ) bind ( C , name = \"compute_shift_vector_field_c\" ) use iso_c_binding use tox_shift_vectors !| Expression vector dimension integer ( c_int ), intent ( in ), value :: d !| Total number of genes integer ( c_int ), intent ( in ), value :: n_genes !| Total number of families integer ( c_int ), intent ( in ), value :: n_families !| Gene expression matrix `(d × n_genes)` real ( c_double ), intent ( in ), target :: expression_vectors ( d , n_genes ) !| Family centroid matrix `(d × n_families)` real ( c_double ), intent ( in ), target :: family_centroids ( d , n_families ) !| Mapping from genes to families (family IDs for each gene in `expression_vectors`) integer ( c_int ), intent ( in ), target :: gene_to_centroid ( n_genes ) !| Output, real matrix array, size = 2d x `n_genes`, stores the centroid of the gene's family in rows 1..d and the shift vectors in rows d+1...2d real ( c_double ), intent ( out ), target :: shift_vectors ( 2 * d , n_genes ) !| Error code: 0 - success, non-zero = error integer ( c_int ), intent ( out ) :: ierr call compute_shift_vector_field ( d , n_genes , n_families , expression_vectors , family_centroids , & gene_to_centroid , shift_vectors , ierr ) end subroutine compute_shift_vector_field_c","tags":"","url":"sourcefile/tox_shift_vectors.f90.html"},{"title":"tox_tissue_versatility.F90 – TensorOmics","text":"Source Code !> Module for calculating normalized tissue (axis) versatility. !| This module implements the angle-based metric for tissue versatility, !| quantifying how uniformly a gene is expressed across selected axes (tissues). module avmod use , intrinsic :: iso_fortran_env , only : real64 , int32 use tox_errors , only : ERR_EMPTY_INPUT , set_ok , set_err_once implicit none contains !> Computes normalized tissue versatility for selected expression vectors. !| The metric is based on the angle between each gene expression vector and the space diagonal. !| Versatility is normalized to [0, 1], where 0 means uniform expression and 1 means expression in only one axis. pure subroutine compute_tissue_versatility ( n_axes , n_vectors , expression_vectors , exp_vecs_selection_index , & n_selected_vectors , axes_selection , n_selected_axes , & tissue_versatilities , tissue_angles_deg , ierr ) !| Number of axes (tissues/dimensions) integer ( int32 ), intent ( in ) :: n_axes !| Number of expression vectors (genes) integer ( int32 ), intent ( in ) :: n_vectors !| Number of selected axes (count of .TRUE. in axes_selection) integer ( int32 ), intent ( in ) :: n_selected_axes !| Number of selected expression vectors (count of .TRUE. in exp_vecs_selection_index) integer ( int32 ), intent ( in ) :: n_selected_vectors !| 2D array (n_axes, n_vectors), each column is a gene expression vector real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_vectors ) !| Logical array (n_vectors), .TRUE. for vectors to process logical , intent ( in ) :: exp_vecs_selection_index ( n_vectors ) !| Logical array (n_axes), .TRUE. for axes to include in calculation logical , intent ( in ) :: axes_selection ( n_axes ) !| Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities real ( real64 ), intent ( out ) :: tissue_versatilities ( n_selected_vectors ) !| Output, real array, length = n_selected_vectors, stores the calculated angles in degrees real ( real64 ), intent ( out ) :: tissue_angles_deg ( n_selected_vectors ) !| Error code: 0 = success, non-zero = error integer ( int32 ), intent ( out ) :: ierr ! Local variables integer ( int32 ) :: i_vec , i_axis , out_idx real ( real64 ) :: norm_diag , dot_prod , norm_v , cos_phi , angle_rad , norm_factor real ( real64 ), parameter :: rad2deg = 18 0.0_real64 / acos ( - 1.0_real64 ) ! Initialize error code call set_ok ( ierr ) ! Compute the norm of the space diagonal (only active axes) if ( n_selected_axes <= 0 ) then ! Set error code to 202 (Empty input arrays) call set_err_once ( ierr , ERR_EMPTY_INPUT ) return end if norm_diag = sqrt ( real ( n_selected_axes , real64 )) ! Precompute normalization factor for tissue versatility norm_factor = 1.0_real64 - 1.0_real64 / norm_diag ! Loop over selected expression vectors ! Note: If the expression vector is zero in all selected axes, tissue versatility (TV) is set to 1 (maximum specificity) and the angle is set to acos(0) = 90 degrees. out_idx = 0 do i_vec = 1 , n_vectors if (. not . exp_vecs_selection_index ( i_vec )) cycle ! Skip if not selected ! Compute dot product and norm for the vector in active axes dot_prod = 0.0_real64 norm_v = 0.0_real64 do i_axis = 1 , n_axes if ( axes_selection ( i_axis )) then dot_prod = dot_prod + expression_vectors ( i_axis , i_vec ) norm_v = norm_v + expression_vectors ( i_axis , i_vec ) ** 2 end if end do out_idx = out_idx + 1 ! If the vector is zero or numerically negligible, set TV = 1 (maximum specificity) ! Use sqrt(epsilon) for extra-robust threshold to avoid numerical instability in cos_phi calculation if ( norm_v <= sqrt ( epsilon ( 1.0_real64 ))) then tissue_versatilities ( out_idx ) = 1.0_real64 tissue_angles_deg ( out_idx ) = 9 0.0_real64 cycle else cos_phi = dot_prod / ( sqrt ( norm_v ) * norm_diag ) end if ! Clamp cos_phi for numerical safety cos_phi = max ( - 1.0_real64 , min ( 1.0_real64 , cos_phi )) if ( abs ( cos_phi - 1.0_real64 ) < 1e-12_real64 ) cos_phi = 1.0_real64 angle_rad = acos ( cos_phi ) tissue_versatilities ( out_idx ) = ( 1.0_real64 - cos_phi ) / norm_factor tissue_angles_deg ( out_idx ) = angle_rad * rad2deg if ( abs ( tissue_angles_deg ( out_idx )) < 1e-12_real64 ) tissue_angles_deg ( out_idx ) = 0.0_real64 end do end subroutine compute_tissue_versatility end module avmod !> R wrapper for compute_tissue_versatility. !| Calls compute_tissue_versatility with standard Fortran types for R interface. pure subroutine compute_tissue_versatility_r ( n_axes , n_vectors , expression_vectors , exp_vecs_selection_index , & n_selected_vectors , axes_selection , n_selected_axes , & tissue_versatilities , tissue_angles_deg , ierr ) use avmod !| Number of axes (tissues/dimensions) integer ( int32 ), intent ( in ) :: n_axes !| Number of expression vectors (genes) integer ( int32 ), intent ( in ) :: n_vectors !| Number of selected axes (count of .TRUE. in axes_selection) integer ( int32 ), intent ( in ) :: n_selected_axes !| Number of selected expression vectors (count of .TRUE. in exp_vecs_selection_index) integer ( int32 ), intent ( in ) :: n_selected_vectors !| 2D array (n_axes, n_vectors), each column is a gene expression vector real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_vectors ) !| Logical array (n_vectors), .TRUE. for vectors to process logical , intent ( in ) :: exp_vecs_selection_index ( n_vectors ) !| Logical array (n_axes), .TRUE. for axes to include in calculation logical , intent ( in ) :: axes_selection ( n_axes ) !| Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities real ( real64 ), intent ( out ) :: tissue_versatilities ( n_selected_vectors ) !| Output, real array, length = n_selected_vectors, stores the calculated angles in degrees real ( real64 ), intent ( out ) :: tissue_angles_deg ( n_selected_vectors ) !| Error code: 0 = success, non-zero = error integer ( int32 ), intent ( out ) :: ierr call compute_tissue_versatility ( n_axes , n_vectors , expression_vectors , exp_vecs_selection_index , n_selected_vectors , axes_selection , & n_selected_axes , tissue_versatilities , tissue_angles_deg , ierr ) end subroutine compute_tissue_versatility_r !> C wrapper for compute_tissue_versatility. !| Exposes compute_tissue_versatility to C via iso_c_binding types with explicit dimensions. pure subroutine compute_tissue_versatility_c ( n_axes , n_vectors , expression_vectors , exp_vecs_selection_index , & n_selected_vectors , axes_selection , n_selected_axes , & tissue_versatilities , tissue_angles_deg , ierr ) bind ( C , name = \"compute_tissue_versatility_c\" ) use iso_c_binding , only : c_int , c_double use avmod !| Number of axes (tissues/dimensions) integer ( c_int ), intent ( in ), value :: n_axes !| Number of expression vectors (genes) integer ( c_int ), intent ( in ), value :: n_vectors !| 2D array (n_axes, n_vectors), each column is a gene expression vector (column-major) real ( c_double ), intent ( in ), target :: expression_vectors ( n_axes , n_vectors ) !| Integer array (n_vectors), 0/1 values. 0=not selected, 1=selected. Interpreted as logical internally. integer ( c_int ), intent ( in ), target :: exp_vecs_selection_index ( n_vectors ) !| Number of selected expression vectors (count of 1s in exp_vecs_selection_index) integer ( c_int ), intent ( in ), value :: n_selected_vectors !| Integer array (n_axes), 0/1 values. 0=not selected, 1=selected. Interpreted as logical internally. integer ( c_int ), intent ( in ), target :: axes_selection ( n_axes ) !| Number of selected axes (count of 1s in axes_selection) integer ( c_int ), intent ( in ), value :: n_selected_axes !| Output, real array, length = n_selected_vectors, stores the calculated tissue versatilities for selected vectors real ( c_double ), intent ( out ), target :: tissue_versatilities ( n_selected_vectors ) !| Output, real array, length = n_selected_vectors, stores the calculated angles in degrees for selected vectors real ( c_double ), intent ( out ), target :: tissue_angles_deg ( n_selected_vectors ) !| Error code: 0 = success, non-zero = error integer ( c_int ), intent ( out ) :: ierr call compute_tissue_versatility ( n_axes , n_vectors , expression_vectors , exp_vecs_selection_index /= 0 , n_selected_vectors , & axes_selection /= 0 , n_selected_axes , tissue_versatilities , tissue_angles_deg , ierr ) end subroutine compute_tissue_versatility_c","tags":"","url":"sourcefile/tox_tissue_versatility.f90.html"},{"title":"f42_utils.F90 – TensorOmics","text":"Source Code !> Utility module for data analysis. !| This module provides general-purpose utility functions for data analysis, to be used as needed. module f42_utils use , intrinsic :: iso_fortran_env , only : real64 , int32 use tox_errors , only : ERR_OK , ERR_INVALID_INPUT , ERR_EMPTY_INPUT , set_ok , set_err_once implicit none public :: sort_real , sort_integer , sort_character public :: sort_array interface sort_array module procedure sort_real , sort_integer , sort_character end interface sort_array contains !> Sort a real array indirectly using quicksort. !| Creates a sorted version of the array by reordering the `perm` vector. The original data in `array` remains unchanged. pure subroutine sort_real ( array , perm , stack_left , stack_right ) !| Real input array to sort real ( real64 ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) call quicksort_real ( array , perm , size ( array ), stack_left , stack_right ) end subroutine sort_real !> Sort an integer array indirectly using quicksort. !| Similar to `sort_real`, but for integer input. pure subroutine sort_integer ( array , perm , stack_left , stack_right ) !| Integer input array to sort integer ( int32 ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) call quicksort_int ( array , perm , size ( array ), stack_left , stack_right ) end subroutine sort_integer !> Sort a character array indirectly using quicksort. !| Uses lexicographic ordering and permutation vector sorting. pure subroutine sort_character ( array , perm , stack_left , stack_right ) !| Character input array to sort character ( len =* ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) call quicksort_char ( array , perm , size ( array ), stack_left , stack_right ) end subroutine sort_character !> Internal quicksort implementation for real arrays. !| Sorts indirectly using the permutation vector `perm`. Manual stack replaces recursion. pure subroutine quicksort_real ( array , perm , n , stack_left , stack_right ) !| Real input array to sort real ( real64 ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Size of the array integer ( int32 ), intent ( in ) :: n !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) integer ( int32 ) :: left , right , i , j , top , pivot_idx real ( real64 ) :: pivot_val top = 1 stack_left ( top ) = 1 stack_right ( top ) = n ! Iterative quicksort using explicit stack do while ( top > 0 ) left = stack_left ( top ) right = stack_right ( top ) top = top - 1 if ( left >= right ) cycle ! Select pivot and initialize pointers pivot_idx = ( left + right ) / 2 pivot_val = array ( perm ( pivot_idx )) i = left j = right ! Partitioning loop do do while ( array ( perm ( i )) < pivot_val ) i = i + 1 end do do while ( array ( perm ( j )) > pivot_val ) j = j - 1 end do if ( i <= j ) then call swap_int ( perm ( i ), perm ( j )) i = i + 1 j = j - 1 end if if ( i > j ) exit end do ! Push new ranges onto stack if ( left < j ) then top = top + 1 stack_left ( top ) = left stack_right ( top ) = j end if if ( i < right ) then top = top + 1 stack_left ( top ) = i stack_right ( top ) = right end if end do end subroutine quicksort_real !> Internal quicksort implementation for integer arrays. !| Indirectly sorts `array` using `perm`, same algorithm as `quicksort_real`. pure subroutine quicksort_int ( array , perm , n , stack_left , stack_right ) !| Integer input array to sort integer ( int32 ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Size of the array integer ( int32 ), intent ( in ) :: n !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) integer ( int32 ) :: left , right , i , j , top , pivot_idx integer ( int32 ) :: pivot_val top = 1 stack_left ( top ) = 1 stack_right ( top ) = n do while ( top > 0 ) left = stack_left ( top ) right = stack_right ( top ) top = top - 1 if ( left >= right ) cycle pivot_idx = ( left + right ) / 2 pivot_val = array ( perm ( pivot_idx )) i = left j = right do do while ( array ( perm ( i )) < pivot_val ) i = i + 1 end do do while ( array ( perm ( j )) > pivot_val ) j = j - 1 end do if ( i <= j ) then call swap_int ( perm ( i ), perm ( j )) i = i + 1 j = j - 1 end if if ( i > j ) exit end do if ( left < j ) then top = top + 1 stack_left ( top ) = left stack_right ( top ) = j end if if ( i < right ) then top = top + 1 stack_left ( top ) = i stack_right ( top ) = right end if end do end subroutine quicksort_int !> Internal quicksort implementation for character arrays. !| Lexicographic quicksort using string comparison, indirect via `perm`. pure subroutine quicksort_char ( array , perm , n , stack_left , stack_right ) !| Character input array to sort character ( len =* ), intent ( in ) :: array (:) !| Permutation vector that will be sorted integer ( int32 ), intent ( inout ) :: perm (:) !| Size of the array integer ( int32 ), intent ( in ) :: n !| Manual stack of left indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_left (:) !| Manual stack of right indices for quicksort recursion integer ( int32 ), intent ( inout ) :: stack_right (:) integer ( int32 ) :: left , right , i , j , top , pivot_idx character ( len = len ( array )) :: pivot_val top = 1 stack_left ( top ) = 1 stack_right ( top ) = n do while ( top > 0 ) left = stack_left ( top ) right = stack_right ( top ) top = top - 1 if ( left >= right ) cycle pivot_idx = ( left + right ) / 2 pivot_val = array ( perm ( pivot_idx )) i = left j = right do do while ( array ( perm ( i )) < pivot_val ) i = i + 1 end do do while ( array ( perm ( j )) > pivot_val ) j = j - 1 end do if ( i <= j ) then call swap_int ( perm ( i ), perm ( j )) i = i + 1 j = j - 1 end if if ( i > j ) exit end do if ( left < j ) then top = top + 1 stack_left ( top ) = left stack_right ( top ) = j end if if ( i < right ) then top = top + 1 stack_left ( top ) = i stack_right ( top ) = right end if end do end subroutine quicksort_char !> Swap two integer values in-place. pure subroutine swap_int ( a , b ) !| First integer to swap integer ( int32 ), intent ( inout ) :: a !| Second integer to swap integer ( int32 ), intent ( inout ) :: b integer ( int32 ) :: temp temp = a ; a = b ; b = temp end subroutine swap_int !> Finds the indices of the true values in a logical mask. pure subroutine which ( mask , n , idx_out , m_max , m_out , ierr ) !| Logical array of size n. logical , intent ( in ) :: mask (:) !| Size of the mask. integer ( int32 ), intent ( in ) :: n !| Integer array to store the indices of true values. integer ( int32 ), intent ( out ) :: idx_out (:) !| Maximum size of idx_out. integer ( int32 ), intent ( in ) :: m_max !| Actual size of idx_out (number of true values found). integer ( int32 ), intent ( out ) :: m_out !| Error code: 0=ok, 201=invalid input, 202=empty input integer ( int32 ), intent ( out ) :: ierr integer ( int32 ) :: i , count ! Initialize error code call set_ok ( ierr ) ! Validate inputs if ( n <= 0 . or . m_max <= 0 ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) m_out = 0 idx_out = 0 return end if if ( size ( mask ) < n . or . size ( idx_out ) < m_max ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) m_out = 0 idx_out = 0 return end if count = 0 idx_out = 0 ! Initialize to avoid garbage values do i = 1 , n if ( mask ( i )) then count = count + 1 if ( count <= m_max ) then idx_out ( count ) = i end if end if end do m_out = count end subroutine which !> Performs LOESS smoothing on a set of data points. !| Smooths y_ref at x_query using reference points x_ref, y_ref, and kernel parameters. !| The user must pre-filter data and provide only valid indices in indices_used. pure subroutine loess_smooth_2d ( n_total , n_target , x_ref , y_ref , indices_used , n_used , x_query , & kernel_sigma , kernel_cutoff , y_out , ierr ) !| Total number of reference points. integer ( int32 ), intent ( in ) :: n_total !| Number of target points to smooth. integer ( int32 ), intent ( in ) :: n_target !| Reference x-coordinates. real ( real64 ), intent ( in ) :: x_ref ( n_total ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( in ) :: y_ref ( n_total ) !| Indices of reference points used for smoothing (only valid indices). integer ( int32 ), intent ( in ) :: indices_used ( n_used ) !| Number of indices actually used for smoothing. integer ( int32 ), intent ( in ) :: n_used !| Target x-coordinates to smooth. real ( real64 ), intent ( in ) :: x_query ( n_target ) !| Bandwidth parameter for the kernel. real ( real64 ), intent ( in ) :: kernel_sigma !| Cutoff for the kernel. real ( real64 ), intent ( in ) :: kernel_cutoff !| Output smoothed values (length n_target). real ( real64 ), intent ( out ) :: y_out ( n_target ) !| Error code: 0=ok, 201=invalid input, 202=empty input integer ( int32 ), intent ( out ) :: ierr integer ( int32 ) :: q , i , idx real ( real64 ) :: query_x , ref_x , delta , sum_weights , weight real ( real64 ) :: min_dist integer ( int32 ) :: min_idx logical :: exact_match_found , use_kernel ! Initialize error code call set_ok ( ierr ) ! Input validation if ( n_total <= 0 . or . n_target <= 0 ) then call set_err_once ( ierr , ERR_EMPTY_INPUT ) y_out = 0.0_real64 return end if if ( n_used <= 0 ) then call set_err_once ( ierr , ERR_EMPTY_INPUT ) y_out = 0.0_real64 return end if if ( kernel_sigma < 0.0_real64 . or . kernel_cutoff < 0.0_real64 ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) y_out = 0.0_real64 return end if ! Validate array sizes if ( size ( x_ref ) < n_total . or . size ( y_ref ) < n_total . or . & size ( indices_used ) < n_used . or . size ( x_query ) < n_target . or . & size ( y_out ) < n_target ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) y_out = 0.0_real64 return end if ! Validate indices are within bounds do i = 1 , n_used if ( indices_used ( i ) < 1 . or . indices_used ( i ) > n_total ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) y_out = 0.0_real64 return end if end do ! Check if we should use kernel smoothing use_kernel = ( kernel_sigma > 0.0_real64 ) do q = 1 , n_target query_x = x_query ( q ) sum_weights = 0.0_real64 y_out ( q ) = 0.0_real64 min_dist = huge ( 1.0_real64 ) min_idx = indices_used ( 1 ) exact_match_found = . false . ! Process all reference points do i = 1 , n_used idx = indices_used ( i ) ref_x = x_ref ( idx ) delta = abs ( query_x - ref_x ) ! Check for exact match if ( delta == 0.0_real64 ) then y_out ( q ) = y_ref ( idx ) exact_match_found = . true . exit end if ! Track closest point for potential fallback if ( delta < min_dist ) then min_dist = delta min_idx = idx end if ! Apply kernel smoothing if enabled and within cutoff if ( use_kernel . and . delta <= kernel_cutoff * kernel_sigma ) then weight = exp ( - ( delta / kernel_sigma ) ** 2 ) sum_weights = sum_weights + weight y_out ( q ) = y_out ( q ) + weight * y_ref ( idx ) end if end do ! Finalize result if no exact match was found if (. not . exact_match_found ) then if ( sum_weights > 0.0_real64 ) then ! We have weighted average from kernel smoothing y_out ( q ) = y_out ( q ) / sum_weights else ! Fallback: use nearest neighbor y_out ( q ) = y_ref ( min_idx ) end if end if end do end subroutine loess_smooth_2d end module f42_utils ! === R WRAPPERS === !> R wrapper for loess_smooth_2d. !| Direct wrapper - user must pre-filter indices in R before calling. subroutine loess_smooth_2d_r ( n_total , n_target , x_ref , y_ref , indices_used , n_used , x_query , & kernel_sigma , kernel_cutoff , y_out , ierr ) use f42_utils , only : loess_smooth_2d use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none !| Total number of reference points. integer ( int32 ), intent ( in ) :: n_total !| Number of target points to smooth. integer ( int32 ), intent ( in ) :: n_target !| Reference x-coordinates. real ( real64 ), intent ( in ) :: x_ref ( n_total ) !| Reference y-coordinates (length n_total). real ( real64 ), intent ( in ) :: y_ref ( n_total ) !| Indices of reference points used for smoothing (pre-filtered). integer ( int32 ), intent ( in ) :: indices_used ( n_used ) !| Number of indices actually used for smoothing. integer ( int32 ), intent ( in ) :: n_used !| Target x-coordinates to smooth. real ( real64 ), intent ( in ) :: x_query ( n_target ) !| Bandwidth parameter for the kernel. real ( real64 ), intent ( in ) :: kernel_sigma !| Cutoff for the kernel. real ( real64 ), intent ( in ) :: kernel_cutoff !| Output smoothed values (length n_target). real ( real64 ), intent ( out ) :: y_out ( n_target ) !| Error code: 0=ok, 201=invalid input, 202=empty input integer ( int32 ), intent ( out ) :: ierr call loess_smooth_2d ( n_total , n_target , x_ref , y_ref , indices_used , n_used , x_query , & kernel_sigma , kernel_cutoff , y_out , ierr ) end subroutine loess_smooth_2d_r ! === C WRAPPERS === !> C wrapper for which. !| Converts integer mask to logical and calls which. subroutine which_c ( mask , n , idx_out , m_max , m_out , ierr ) bind ( C , name = \"which_c\" ) use iso_c_binding use , intrinsic :: iso_fortran_env , only : int32 use f42_utils , only : which implicit none !| Size of the mask. integer ( c_int ), intent ( in ), value :: n !| Maximum size of idx_out. integer ( c_int ), intent ( in ), value :: m_max !| Integer mask array (0/1 values). integer ( c_int ), intent ( in ) :: mask ( n ) !| Output array for indices of true values. integer ( c_int ), intent ( out ) :: idx_out ( m_max ) !| Actual size of idx_out (number of true values found). integer ( c_int ), intent ( out ) :: m_out !| Error code: 0=ok, 201=invalid input, 202=empty input integer ( c_int ), intent ( out ) :: ierr logical :: mask_f ( n ) integer ( int32 ) :: i , ierr_f do i = 1 , n mask_f ( i ) = ( mask ( i ) /= 0 ) end do call which ( mask_f , n , idx_out , m_max , m_out , ierr_f ) ierr = ierr_f end subroutine which_c !> C wrapper for loess_smooth_2d. !| Direct wrapper - user must pre-filter indices in C before calling. subroutine loess_smooth_2d_c ( n_total , n_target , x_ref , y_ref , indices_used , n_used , x_query , & kernel_sigma , kernel_cutoff , y_out , ierr ) bind ( C , name = \"loess_smooth_2d_c\" ) use iso_c_binding , only : c_int , c_double use , intrinsic :: iso_fortran_env , only : int32 use f42_utils , only : loess_smooth_2d implicit none !| Total number of reference points. integer ( c_int ), intent ( in ), value :: n_total !| Number of target points to smooth. integer ( c_int ), intent ( in ), value :: n_target !| Reference x-coordinates. real ( c_double ), intent ( in ) :: x_ref ( n_total ) !| Reference y-coordinates (length n_total). real ( c_double ), intent ( in ) :: y_ref ( n_total ) !| Indices of reference points used for smoothing (pre-filtered). integer ( c_int ), intent ( in ) :: indices_used ( n_used ) !| Number of indices actually used for smoothing. integer ( c_int ), intent ( in ), value :: n_used !| Target x-coordinates to smooth. real ( c_double ), intent ( in ) :: x_query ( n_target ) !| Bandwidth parameter for the kernel. real ( c_double ), intent ( in ), value :: kernel_sigma !| Cutoff for the kernel. real ( c_double ), intent ( in ), value :: kernel_cutoff !| Output smoothed values (length n_target). real ( c_double ), intent ( out ) :: y_out ( n_target ) !| Error code: 0=ok, 201=invalid input, 202=empty input integer ( c_int ), intent ( out ) :: ierr integer ( int32 ) :: ierr_f call loess_smooth_2d ( n_total , n_target , x_ref , y_ref , indices_used , n_used , x_query , & kernel_sigma , kernel_cutoff , y_out , ierr_f ) ierr = ierr_f end subroutine loess_smooth_2d_c","tags":"","url":"sourcefile/f42_utils.f90.html"},{"title":"array_utils.F90 – TensorOmics","text":"Source Code !> Module for array utilities module array_utils use , intrinsic :: iso_fortran_env , only : int32 , real64 use tox_errors implicit none PUBLIC :: get_array_metadata , ascii_to_string , read_file_header , write_file_header , string_to_ascii_arr , check_okay_dims public :: check_okay_ndims integer ( int32 ), parameter :: ARRAY_FILE_MAGIC = int ( z '46413230' , int32 ) ! 'FA20' in hex !! Magic number for array files contains !> Check I/O error and set ierr accordingly subroutine check_okay_ioerror ( ioerror , ierr , msg , unit ) integer ( int32 ), intent ( in ) :: ioerror !! IO error set by fortran integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ), intent ( in ) :: msg !! Error code readable version used for setting integer ( int32 ), intent ( in ) :: unit !! pass unit allowing it to be closed if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , msg ) close ( unit ) return end if end subroutine !> check if array dimensions match the expected dimensions subroutine check_okay_dims ( dims , expected , ierr ) integer ( int32 ), intent ( in ) :: dims (:) !! array of actual dimensions integer ( int32 ), intent ( in ) :: expected !! expected number of dimensions integer ( int32 ), intent ( out ) :: ierr !! error code if ( size ( dims ) /= expected ) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) RETURN end if end subroutine subroutine check_okay_ndims ( ndims , expected , unit , ierr ) integer ( int32 ), intent ( in ) :: ndims !! number of dimensions integer ( int32 ), intent ( in ) :: expected !! expected number of dimensions integer ( int32 ), intent ( in ) :: unit !! unit representation integer ( int32 ), intent ( out ) :: ierr !! error code if ( ndims /= expected ) then close ( unit ) call set_err_once ( ierr , ERR_DIM_MISMATCH ) RETURN end if end Subroutine !> Opens unit and writes fileheader with all metadata to the given filename subroutine write_file_header ( filename , unit , type_code , ndim , dims , ierr , clen ) character ( len =* ), intent ( in ) :: filename !! filename to write to integer ( int32 ), intent ( in ) :: type_code !! type code of the array (1=int, 2=real, 3=char) integer ( int32 ), intent ( in ) :: ndim !! number of dimensions integer ( int32 ), intent ( in ) :: dims ( ndim ) !! dimensions of the array integer ( int32 ), intent ( in ), optional :: clen !! character length (only for character arrays) integer ( int32 ), intent ( inout ) :: ierr !! error code integer ( int32 ), INTENT ( OUT ) :: unit !! Fortran unit number for the file integer ( int32 ) :: ioerror !! internal I/O error code call set_ok ( ierr ) call set_ok ( ioerror ) open ( newunit = unit , file = filename , form = 'unformatted' , access = 'stream' , status = 'replace' , iostat = ioerror ) call check_okay_ioerror ( ioerror , ierr , ERR_FILE_OPEN , unit ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) ARRAY_FILE_MAGIC call check_okay_ioerror ( ioerror , ierr , ERR_WRITE_MAGIC , unit ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) type_code call check_okay_ioerror ( ioerror , ierr , ERR_WRITE_TYPE , unit ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) ndim call check_okay_ioerror ( ioerror , ierr , ERR_WRITE_NDIMS , unit ) if (. not . is_ok ( ierr )) return write ( unit , iostat = ioerror ) dims call check_okay_ioerror ( ioerror , ierr , ERR_WRITE_DIMS , unit ) if (. not . is_ok ( ierr )) return if ( type_code == 3 . and . present ( clen )) then write ( unit , iostat = ioerror ) clen call check_okay_ioerror ( ioerror , ierr , ERR_WRITE_CHARLEN , unit ) if (. not . is_ok ( ierr )) return end if end subroutine write_file_header !> Opens unit and reads file header with all metadata from given file subroutine read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) character ( len =* ), intent ( in ) :: filename !! filename to read from integer ( int32 ), intent ( out ) :: unit !! Fortran unit number for the file integer ( int32 ), intent ( out ) :: type_code !! type code of the array (1=int, 2=real, 3=char) integer ( int32 ), INTENT ( out ) :: ndims !! number of dimensions integer ( int32 ), intent ( out ) :: clen !! character length (only for character arrays) integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ), allocatable :: dims (:) !! dimensions of the array integer ( int32 ) :: ioerror !! internal I/O error code integer ( int32 ) :: magic !! magic number to verify file format call set_ok ( ioerror ) call set_ok ( ierr ) open ( newunit = unit , file = filename , form = 'unformatted' , access = 'stream' , status = 'old' , iostat = ioerror ) call check_okay_ioerror ( ioerror , ierr , ERR_FILE_OPEN , unit ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) magic call check_okay_ioerror ( ioerror , ierr , ERR_READ_MAGIC , unit ) if (. not . is_ok ( ierr )) return if ( magic /= ARRAY_FILE_MAGIC ) then call set_err_once ( ierr , ERR_INVALID_FORMAT ) close ( unit ) return end if read ( unit , iostat = ioerror ) type_code call check_okay_ioerror ( ioerror , ierr , ERR_READ_TYPE , unit ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) ndims call check_okay_ioerror ( ioerror , ierr , ERR_READ_NDIMS , unit ) if (. not . is_ok ( ierr )) return allocate ( dims ( ndims )) read ( unit , iostat = ioerror ) dims call check_okay_ioerror ( ioerror , ierr , ERR_READ_DIMS , unit ) if (. not . is_ok ( ierr )) return if ( type_code == 3 ) then read ( unit , iostat = ioerror ) clen call check_okay_ioerror ( ioerror , ierr , ERR_READ_CHARLEN , unit ) if (. not . is_ok ( ierr )) return else clen = 0 ! Not applicable for non-character types end if end subroutine !> Get the metadata of an array file subroutine get_array_metadata ( filename , dims_out , dims_out_capacity , ndims , ierr , clen ) implicit none character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ndims !! number of dimensions integer ( int32 ), intent ( in ) :: dims_out_capacity !! Capacity of the dims_out array integer ( int32 ), intent ( out ) :: dims_out ( dims_out_capacity ) !! Array to store output dimensions integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ), INTENT ( OUT ), OPTIONAL :: clen !! length of each string (needed for char arrays) integer ( int32 ) :: unit integer ( int32 ), allocatable :: dims (:) integer ( int32 ) :: type_code integer ( int32 ) :: i integer ( int32 ) :: ioerror integer ( int32 ) :: local_clen call set_ok ( ioerror ) call read_file_header ( filename , unit , type_code , ndims , dims , local_clen , ierr ) close ( unit ) if (. not . is_ok ( ierr )) return if ( size ( dims ) > dims_out_capacity ) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) RETURN end if do i = 1 , ndims dims_out ( i ) = dims ( i ) end do if ( present ( clen )) then clen = local_clen end if end subroutine !> subroutine to convert an ASCII array to a string subroutine ascii_to_string ( ascii_array , clen , str ) implicit none integer ( int32 ), intent ( in ) :: clen !! Length of the ASCII array integer ( int32 ), intent ( in ) :: ascii_array ( clen ) !! Array of ASCII characters character ( len = :), allocatable , INTENT ( OUT ) :: str !! Output string integer ( int32 ) :: i !! loop variable allocate ( character ( len = clen ) :: str ) do i = 1 , clen str ( i : i ) = char ( ascii_array ( i )) end do end subroutine ascii_to_string !> converts a string array to an ascii array subroutine string_to_ascii_arr ( flat , array_size , ascii_arr , clen ) implicit none integer ( int32 ), intent ( in ) :: array_size !! size of the input array integer ( int32 ), intent ( in ) :: clen !! length of the longest string integer ( int32 ), intent ( out ) :: ascii_arr ( array_size * clen ) !! ascii output array character ( len =* ), intent ( in ) :: flat ( array_size ) !! input array with characters integer ( int32 ) :: i , j do i = 1 , array_size do j = 1 , clen if ( j <= len_trim ( flat ( i ))) then ascii_arr (( i - 1 ) * clen + j ) = iachar ( flat ( i )( j : j )) else ascii_arr (( i - 1 ) * clen + j ) = 0 end if end do end do end subroutine string_to_ascii_arr end module array_utils !> Subroutine to get the dimensions of an array file subroutine get_array_metadata_r ( filename_ascii , fn_len , dims_out , dims_out_capacity , ndims , ierr , clen ) use iso_fortran_env , only : int32 use array_utils , only : ascii_to_string , get_array_metadata implicit none ! Input integer ( int32 ), intent ( in ) :: fn_len !! Length of the filename array integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( int32 ), intent ( in ) :: dims_out_capacity ! Output integer ( int32 ), intent ( out ) :: dims_out ( dims_out_capacity ) ! R provides storage !! Output array for dimensions integer ( int32 ), intent ( out ) :: ndims ! Number of dimensions !! Output variable for the number of dimensions integer ( int32 ), intent ( out ), optional :: clen !! Character length (only for character arrays) integer ( int32 ), intent ( out ) :: ierr !! Error code character ( len = :), allocatable :: filename call ascii_to_string ( filename_ascii , fn_len , filename ) call get_array_metadata ( filename , dims_out , dims_out_capacity , ndims , ierr , clen ) end subroutine get_array_metadata_r !> C binding for the subroutine to get the dimensions of an array file subroutine get_array_metadata_C ( filename_ascii , fn_len , dims_out , dims_out_capacity , ndims , ierr , clen ) bind ( C , name = \"get_array_metadata_C\" ) use iso_c_binding , only : c_int use iso_fortran_env , only : int32 use array_utils , only : ascii_to_string , get_array_metadata implicit none ! Input integer ( c_int ), value :: fn_len !! Length of the filename array integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( c_int ), intent ( in ) :: dims_out_capacity ! Output integer ( c_int ), intent ( out ) :: dims_out ( dims_out_capacity ) !! Output array for dimensions integer ( c_int ), intent ( out ) :: ndims !! Output variable for the number of dimensions integer ( c_int ), intent ( out ) :: ierr !! Error code integer ( c_int ), intent ( out ) :: clen !! Character length (only for character arrays) ! Local variables character ( len = :), allocatable :: filename !! Filename as a string call ascii_to_string ( filename_ascii , fn_len , filename ) call get_array_metadata ( filename , dims_out , dims_out_capacity , ndims , ierr , clen ) end subroutine get_array_metadata_C","tags":"","url":"sourcefile/array_utils.f90.html"},{"title":"tox_errors.F90 – TensorOmics","text":"Source Code !> error handling module for tensor-omics module tox_errors use iso_fortran_env , only : int32 implicit none public ! <-- expose all names (constants + procedures) !------------------------------ ! Success !------------------------------ integer ( int32 ), parameter :: ERR_OK = 0 !! no error, operation successful !------------------------------ ! 1xx: I/O / File reading !------------------------------ integer ( int32 ), parameter :: ERR_FILE_OPEN = 101 !! could not open file integer ( int32 ), parameter :: ERR_READ_MAGIC = 102 !! could not read magic number integer ( int32 ), parameter :: ERR_READ_TYPE = 103 !! could not read array type code integer ( int32 ), parameter :: ERR_READ_NDIMS = 104 !! could not read number of dimensions integer ( int32 ), parameter :: ERR_READ_DIMS = 105 !! could not read array dimensions integer ( int32 ), parameter :: ERR_READ_CHARLEN = 106 !! could not read character length integer ( int32 ), parameter :: ERR_READ_DATA = 107 !! could not read array data integer ( int32 ), parameter :: ERR_WRITE_MAGIC = 112 !! could not write magic number integer ( int32 ), parameter :: ERR_WRITE_TYPE = 113 !! could not write array type code integer ( int32 ), parameter :: ERR_WRITE_NDIMS = 114 !! could not write number of dimensions integer ( int32 ), parameter :: ERR_WRITE_DIMS = 115 !! could not write array dimensions integer ( int32 ), parameter :: ERR_WRITE_CHARLEN = 116 !! could not write character length integer ( int32 ), parameter :: ERR_WRITE_DATA = 117 !! could not write array data !------------------------------ ! 2xx: Format / Input validation !------------------------------ integer ( int32 ), parameter :: ERR_INVALID_FORMAT = 200 !! invalid format detected integer ( int32 ), parameter :: ERR_INVALID_INPUT = 201 !! invalid input arguments integer ( int32 ), parameter :: ERR_EMPTY_INPUT = 202 !! empty input arrays integer ( int32 ), parameter :: ERR_DIM_MISMATCH = 203 !! dimensions do not match expected shape integer ( int32 ), parameter :: ERR_NAN_INF = 204 !! NaN or Inf found where not allowed integer ( int32 ), parameter :: ERR_UNSUPPORTED_TYPE = 205 !! unsupported data type encountered integer ( int32 ), parameter :: ERR_SIZE_MISMATCH = 206 !! Array size mismatch !------------------------------ ! 3xx: Memory !------------------------------ integer ( int32 ), parameter :: ERR_ALLOC_FAIL = 301 !! memory allocation failed integer ( int32 ), parameter :: ERR_POINTER_NULL = 302 !! null pointer dereference !------------------------------ ! 5xxx: Fortran runtime / Unit state ! (Keep 5002 for compatibility with existing R mapping) !------------------------------ integer ( int32 ), parameter :: ERR_UNIT_NOT_CONNECTED = 5002 !! Fortran runtime error: unit not connected !------------------------------ ! 9xxx: Internal / Unknown !------------------------------ integer ( int32 ), parameter :: ERR_INTERNAL = 9001 !! unexpected internal state or logic error integer ( int32 ), parameter :: ERR_UNKNOWN = 9999 !! unknown error contains !> set the error code to OK, use at beginning of procedures pure subroutine set_ok ( ierr ) integer ( int32 ), intent ( out ) :: ierr ierr = ERR_OK end subroutine set_ok !> set the error code to specific code pure subroutine set_err ( ierr , code ) integer ( int32 ), intent ( inout ) :: ierr integer ( int32 ), intent ( in ) :: code if ( ierr == ERR_OK ) ierr = code end subroutine set_err !> set the error code only if it is currently OK, use to prevent overwriting first error pure subroutine set_err_once ( ierr , code ) integer ( int32 ), intent ( inout ) :: ierr integer ( int32 ), intent ( in ) :: code if ( ierr == ERR_OK ) call set_err ( ierr , code ) end subroutine set_err_once !> check if the error code indicates error pure logical function is_err ( ierr ) result ( not_ok ) integer ( int32 ), intent ( in ) :: ierr not_ok = ( ierr /= ERR_OK ) end function is_err !> check if the error code indicates success pure logical function is_ok ( ierr ) result ( ok ) integer ( int32 ), intent ( in ) :: ierr ok = . not . is_err ( ierr ) end function is_ok pure subroutine validate_dimension_size ( n , ierr ) integer ( int32 ), intent ( in ) :: n integer ( int32 ), intent ( out ) :: ierr if ( n < 0 ) call set_err ( ierr , ERR_INVALID_INPUT ) if ( n == 0 ) call set_err ( ierr , ERR_EMPTY_INPUT ) end subroutine end module tox_errors","tags":"","url":"sourcefile/tox_errors.f90.html"},{"title":"serialize_char.F90 – TensorOmics","text":"Source Code !> Module providing serialization and deserialization routines for character arrays !! of up to 5 dimensions, arrays are serialized to a custom binary format with a magic number and type/dimension metadata. module serialize_char use , intrinsic :: iso_fortran_env , only : int32 , real64 use array_utils , only : write_file_header use tox_errors implicit none public :: serialize_char_1d , serialize_char_2d , serialize_char_3d , & serialize_char_4d , serialize_char_5d , serialize_char_nd integer ( int32 ), parameter :: ARRAY_TYPE_CHAR = 3 contains !> Serialize a 1D character array to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. subroutine serialize_char_1d ( arr , filename , ierr ) character ( len =* ), intent ( in ) :: arr (:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit , clen integer ( int32 ) :: dims ( 1 ) integer ( int32 ) :: ioerror dims = shape ( arr ) clen = len ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , 1 , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 2D character array to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. subroutine serialize_char_2d ( arr , filename , ierr ) character ( len =* ), intent ( in ) :: arr (:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit , clen integer ( int32 ) :: dims ( 2 ) integer ( int32 ) :: ioerror dims = shape ( arr ) clen = len ( arr ) call set_ok ( ierr ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , 2 , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 3D character array to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. subroutine serialize_char_3d ( arr , filename , ierr ) character ( len =* ), intent ( in ) :: arr (:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror integer ( int32 ) :: unit , clen integer ( int32 ) :: dims ( 3 ) dims = shape ( arr ) clen = len ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , 3 , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 4D character array to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. subroutine serialize_char_4d ( arr , filename , ierr ) character ( len =* ), intent ( in ) :: arr (:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit , clen integer ( int32 ) :: dims ( 4 ) integer ( int32 ) :: ioerror dims = shape ( arr ) clen = len ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , 4 , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a 5D character array to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. subroutine serialize_char_5d ( arr , filename , ierr ) character ( len =* ), intent ( in ) :: arr (:,:,:,:,:) !! array to save character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: unit , clen integer ( int32 ) :: dims ( 5 ) integer ( int32 ) :: ioerror dims = shape ( arr ) clen = len ( arr ) call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , 5 , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) arr if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine !> Serialize a character array of arbitrary dimensions to a binary file. !! The file will contain a magic number, type code, dimension, shape, character length, and the array data. !! @note This routine is only called by R and serializes only flat character arrays to the memory subroutine serialize_char_nd ( flat , dims , ndim , clen , filename , ierr ) implicit none character ( len =* ), intent ( in ) :: flat (:) !! flat array to save integer ( int32 ), intent ( in ) :: dims (:) !! dimensions of the array character ( len =* ), intent ( in ) :: filename !! output filename integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ), intent ( in ) :: ndim !! number of dimensions integer ( int32 ), intent ( in ) :: clen !! Length of each string integer ( int32 ) :: ioerror integer ( int32 ) :: unit call set_ok ( ierr ) call set_ok ( ioerror ) call write_file_header ( filename , unit , ARRAY_TYPE_CHAR , ndim , dims , ierr , clen ) if (. not . is_ok ( ierr )) return ! Write the entire array as a contiguous block write ( unit , iostat = ioerror ) flat if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_WRITE_DATA ) end if close ( unit ) end subroutine serialize_char_nd end module serialize_char !> serializes a flat character array to a binary file. subroutine serialize_char_flat_r ( ascii_arr , array_size , dims , ndim , clen , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : int32 use serialize_char , only : serialize_char_nd use array_utils , only : ascii_to_string use tox_errors implicit none integer ( int32 ), intent ( in ) :: ndim !! Number of dimensions integer ( int32 ), intent ( in ) :: array_size !! size of the input array integer ( int32 ), intent ( in ) :: clen !! character length integer ( int32 ), intent ( in ) :: ascii_arr ( clen , array_size ) !! Flat character array in ASCII format integer ( int32 ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( int32 ), intent ( in ) :: fn_len !! length of the filename integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! filename in ascii integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror character ( len = :), allocatable :: filename character ( len = clen ), allocatable :: flat (:) integer ( int32 ) :: i , j , total call set_ok ( ioerror ) call set_ok ( ierr ) total = product ( dims ) allocate ( flat ( total ), stat = ioerror ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_ALLOC_FAIL ) RETURN end if ! ASCII to character conversion do i = 1 , total flat ( i ) = \"\" do j = 1 , clen if ( ascii_arr ( j , i ) > 0 ) then flat ( i )( j : j ) = char ( ascii_arr ( j , i )) else exit end if end do end do call ascii_to_string ( filename_ascii , fn_len , filename ) call serialize_char_nd ( flat , dims , ndim , clen , filename , ierr ) end subroutine serialize_char_flat_r !> C binding for the subroutine to serialize a flat character array to a binary file. subroutine serialize_char_flat_C ( ascii_ptr , dims , ndim , clen , filename_ascii , fn_len , ierr ) bind ( C , name = \"serialize_char_flat_C\" ) use iso_c_binding , only : c_ptr , c_int , c_f_pointer use iso_fortran_env , only : int32 use serialize_char , only : serialize_char_nd use array_utils , only : ascii_to_string use tox_errors implicit none type ( c_ptr ), value :: ascii_ptr !! pointer to ascii array integer ( c_int ), value :: ndim !! Number of dimensions integer ( c_int ), intent ( in ) :: dims ( ndim ) !! Dimensions of the array integer ( c_int ), value :: clen !! Character length integer ( c_int ), value :: fn_len !! Length of the filename array integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Array of ASCII characters representing the filename integer ( c_int ), intent ( out ) :: ierr !! error code integer ( c_int ), pointer :: ascii_arr (:) character ( len = :), allocatable :: filename character ( len = clen ), allocatable :: flat (:) integer ( int32 ) :: i , j , total , ioerror call set_ok ( ierr ) call set_ok ( ioerror ) total = product ( dims ) call c_f_pointer ( ascii_ptr , ascii_arr , [ clen * total ]) allocate ( flat ( total ), stat = ioerror ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_ALLOC_FAIL ) RETURN end if ! ASCII to Fortran character(len=clen) do i = 1 , total flat ( i ) = \"\" do j = 1 , clen if ( ascii_arr (( i - 1 ) * clen + j ) > 0 ) then flat ( i )( j : j ) = char ( ascii_arr (( i - 1 ) * clen + j )) else exit end if end do end do call ascii_to_string ( filename_ascii , fn_len , filename ) call serialize_char_nd ( flat , dims , ndim , clen , filename , ierr ) end subroutine serialize_char_flat_C","tags":"","url":"sourcefile/serialize_char.f90.html"},{"title":"config.F90 – TensorOmics","text":"Source Code #include \"precompiler_constants.F90\" module config implicit none #ifdef DEFAULT_ALIGNMENT integer , parameter :: alignment = DEFAULT_ALIGNMENT #else integer , parameter :: alignment = 32 ! fallback #endif end module config","tags":"","url":"sourcefile/config.f90.html"},{"title":"k_d_tree.F90 – TensorOmics","text":"Source Code module kd_tree use f42_utils , only : sort_array use iso_fortran_env , only : int32 , real64 use tox_errors , only : ERR_OK , ERR_INVALID_INPUT , ERR_EMPTY_INPUT , ERR_DIM_MISMATCH , ERR_SIZE_MISMATCH , set_ok , set_err_once , is_ok , validate_dimension_size implicit none private public :: build_kd_index , build_spherical_kd , get_kd_point contains !> Build a k-d tree index using a stack-based, non-recursive approach. pure subroutine build_kd_index ( points , num_dimensions , num_points , kd_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , recursion_stack , ierr ) integer ( int32 ), intent ( in ) :: num_dimensions !! Number of dimensions integer ( int32 ), intent ( in ) :: num_points !! Number of points real ( real64 ), intent ( in ) :: points ( num_dimensions , num_points ) !! Data points integer ( int32 ), intent ( in ) :: dimension_order ( num_dimensions ) !! Dimension order (by variance) integer ( int32 ), intent ( out ) :: recursion_stack ( 3 , num_points ) !! Stack for l, r, depth integer ( int32 ), intent ( out ) :: kd_indices ( num_points ) !! Output index array (k-d tree order) integer ( int32 ), intent ( out ) :: workspace ( num_points ) !! Workspace array real ( real64 ), intent ( out ) :: value_buffer ( num_points ) !! Workspace for sorting integer ( int32 ), intent ( out ) :: permutation ( num_points ) !! Workspace for sorting integer ( int32 ), intent ( out ) :: left_stack ( num_points ) !! Workspace for sorting integer ( int32 ), intent ( out ) :: right_stack ( num_points ) !! Workspace for sorting integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: stack_top integer ( int32 ) :: left_idx , right_idx , mid_idx , current_dim , current_depth integer ( int32 ) :: i call set_ok ( ierr ) ! Input validation call validate_dimension_size ( num_points , ierr ) if (. not . is_ok ( ierr )) return call validate_dimension_size ( num_dimensions , ierr ) if (. not . is_ok ( ierr )) return do i = 1 , size ( dimension_order ) if ( dimension_order ( i ) < 1 . or . dimension_order ( i ) > num_dimensions ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) exit ! Exit the loop as soon as an invalid value is found end if end do if (. not . is_ok ( ierr )) return !! Initialize kd_indices to 1:num_points (original indices) do i = 1 , num_points kd_indices ( i ) = i end do stack_top = 1 recursion_stack ( 1 , 1 ) = 1 recursion_stack ( 2 , 1 ) = num_points recursion_stack ( 3 , 1 ) = 0 do while ( stack_top > 0 ) left_idx = recursion_stack ( 1 , stack_top ) right_idx = recursion_stack ( 2 , stack_top ) current_depth = recursion_stack ( 3 , stack_top ) stack_top = stack_top - 1 if ( right_idx <= left_idx ) cycle !! Choose split dimension by cycling through dimension_order current_dim = dimension_order ( mod ( current_depth , num_dimensions ) + 1 ) !! Find median index mid_idx = left_idx + ( right_idx - left_idx ) / 2 !! Partition kd_indices(left_idx:right_idx) by points(current_dim, kd_indices(:)) call partial_sort_by_dimension ( points , num_points , num_dimensions , kd_indices , left_idx , right_idx , & current_dim , mid_idx , workspace , value_buffer , permutation , & left_stack , right_stack , ierr ) if (. not . is_ok ( ierr )) return !! Push right and left intervals onto stack if ( mid_idx < right_idx ) then stack_top = stack_top + 1 recursion_stack ( 1 , stack_top ) = mid_idx + 1 recursion_stack ( 2 , stack_top ) = right_idx recursion_stack ( 3 , stack_top ) = current_depth + 1 end if if ( left_idx < mid_idx ) then stack_top = stack_top + 1 recursion_stack ( 1 , stack_top ) = left_idx recursion_stack ( 2 , stack_top ) = mid_idx - 1 recursion_stack ( 3 , stack_top ) = current_depth + 1 end if end do end subroutine build_kd_index !> Helper: sorts kd_indices(left_idx:right_idx) by points(dimension, kd_indices(:)) pure subroutine partial_sort_by_dimension ( points , n_points , num_dimensions , kd_indices , left_idx , right_idx , & dim , mid_idx , workspace , value_buffer , permutation , & left_stack , right_stack , ierr ) use f42_utils , only : sort_array integer ( int32 ), intent ( in ) :: num_dimensions !! Number of dimensions integer ( int32 ), intent ( in ) :: left_idx !! Left index of subarray integer ( int32 ), intent ( in ) :: right_idx !! Right index of subarray integer ( int32 ), intent ( in ) :: dim !! Dimension to sort by integer ( int32 ), intent ( in ) :: mid_idx !! Target median index integer ( int32 ), intent ( in ) :: n_points !! size of points real ( real64 ), intent ( in ) :: points ( num_dimensions , n_points ) !! Input points array integer ( int32 ), intent ( out ) :: kd_indices (:) !! Index array to modify integer ( int32 ), intent ( out ) :: workspace (:) !! Workspace array real ( real64 ), intent ( out ) :: value_buffer (:) !! Buffer for dimension values integer ( int32 ), intent ( out ) :: permutation (:) !! Permutation array integer ( int32 ), intent ( out ) :: left_stack (:) !! Stack for left indices integer ( int32 ), intent ( out ) :: right_stack (:) !! Stack for right indices integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: subarray_size , i call set_ok ( ierr ) ! Input validation if ( left_idx < 1 . or . right_idx > size ( kd_indices ) . or . left_idx > right_idx ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( dim < 1 . or . dim > num_dimensions ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( mid_idx < left_idx . or . mid_idx > right_idx ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if subarray_size = right_idx - left_idx + 1 if ( subarray_size <= 1 ) return !! Fill value_buffer with the values of points(dimension, kd_indices(left_idx:right_idx)) do i = 1 , subarray_size value_buffer ( i ) = points ( dim , kd_indices ( left_idx + i - 1 )) permutation ( i ) = i end do call sort_array ( value_buffer ( 1 : subarray_size ), permutation ( 1 : subarray_size ), left_stack , right_stack ) !! Reorder kd_indices(left_idx:right_idx) according to permutation do i = 1 , subarray_size if ( permutation ( i ) < 1 . or . permutation ( i ) > subarray_size ) then ierr = ERR_INVALID_INPUT return end if workspace ( i ) = kd_indices ( left_idx + permutation ( i ) - 1 ) end do do i = 1 , subarray_size kd_indices ( left_idx + i - 1 ) = workspace ( i ) end do end subroutine partial_sort_by_dimension !> Build spherical k-d tree index pure subroutine build_spherical_kd ( vectors , num_dimensions , num_vectors , sphere_indices , & dimension_order , workspace , value_buffer , permutation , & left_stack , right_stack , recursion_stack , ierr ) integer ( int32 ), intent ( in ) :: num_dimensions !! Number of dimensions integer ( int32 ), intent ( in ) :: num_vectors !! Number of vectors real ( real64 ), intent ( in ) :: vectors ( num_dimensions , num_vectors ) !! Input unit vectors integer ( int32 ), intent ( out ) :: recursion_stack ( 3 , num_vectors ) !! Stack for recursive calls integer ( int32 ), intent ( out ) :: sphere_indices ( num_vectors ) !! Output index array integer ( int32 ), intent ( out ) :: dimension_order ( num_dimensions ) !! Dimension order integer ( int32 ), intent ( out ) :: workspace ( num_vectors ) !! Workspace array real ( real64 ), intent ( out ) :: value_buffer ( num_vectors ) !! Value buffer integer ( int32 ), intent ( out ) :: permutation ( num_vectors ) !! Permutation array integer ( int32 ), intent ( out ) :: left_stack ( num_vectors ) !! Left stack integer ( int32 ), intent ( out ) :: right_stack ( num_vectors ) !! Right stack integer ( int32 ), intent ( out ) :: ierr !! Error code call build_kd_index ( vectors , num_dimensions , num_vectors , sphere_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , recursion_stack , ierr ) end subroutine build_spherical_kd !> Get point from KD index pure subroutine get_kd_point ( points , kd_indices , position , point_values , ierr ) real ( real64 ), intent ( in ) :: points (:, :) !! Input points integer ( int32 ), intent ( in ) :: kd_indices (:) !! KD index array integer ( int32 ), intent ( in ) :: position !! Position in index real ( real64 ), intent ( out ) :: point_values (:) !! Output point values integer ( int32 ), intent ( out ) :: ierr !! Error code call set_ok ( ierr ) ! Input validation if ( position < 1 . or . position > size ( kd_indices )) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if if ( kd_indices ( position ) < 1 . or . kd_indices ( position ) > size ( points , 2 )) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) return end if if ( size ( point_values ) < size ( points , 1 )) then call set_err_once ( ierr , ERR_DIM_MISMATCH ) return end if point_values = points (:, kd_indices ( position )) end subroutine get_kd_point end module kd_tree !> R interface for building KD index subroutine build_kd_index_r ( points , num_dimensions , num_points , kd_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , ierr ) use kd_tree , only : build_kd_index use iso_fortran_env , only : int32 , real64 implicit none integer ( int32 ), intent ( in ) :: num_dimensions !! Number of dimensions integer ( int32 ), intent ( in ) :: num_points !! Number of points real ( real64 ), intent ( in ) :: points ( num_dimensions , num_points ) !! Input points integer ( int32 ), intent ( in ) :: dimension_order ( num_dimensions ) !! Dimension order integer ( int32 ), intent ( out ) :: kd_indices ( num_points ) !! Output indices integer ( int32 ), intent ( out ) :: workspace ( num_points ) !! Workspace real ( real64 ), intent ( out ) :: value_buffer ( num_points ) !! Value buffer integer ( int32 ), intent ( out ) :: permutation ( num_points ) !! Permutation array integer ( int32 ), intent ( out ) :: left_stack ( num_points ) !! Left stack integer ( int32 ), intent ( out ) :: right_stack ( num_points ) !! Right stack integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: recursion_stack ( 3 , num_points ) call build_kd_index ( points , num_dimensions , num_points , kd_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , recursion_stack , ierr ) end subroutine build_kd_index_r !> R interface for building spherical KD index subroutine build_spherical_kd_r ( vectors , num_dimensions , num_vectors , sphere_indices , & dimension_order , workspace , value_buffer , permutation , & left_stack , right_stack , ierr ) use kd_tree , only : build_spherical_kd use iso_fortran_env , only : int32 , real64 implicit none integer ( int32 ), intent ( in ) :: num_dimensions !! Number of dimensions integer ( int32 ), intent ( in ) :: num_vectors !! Number of vectors real ( real64 ), intent ( in ) :: vectors ( num_dimensions , num_vectors ) !! Input vectors integer ( int32 ), intent ( out ) :: sphere_indices ( num_vectors ) !! Output indices integer ( int32 ), intent ( out ) :: dimension_order ( num_dimensions ) !! Dimension order integer ( int32 ), intent ( out ) :: workspace ( num_vectors ) !! Workspace real ( real64 ), intent ( out ) :: value_buffer ( num_vectors ) !! Value buffer integer ( int32 ), intent ( out ) :: permutation ( num_vectors ) !! Permutation array integer ( int32 ), intent ( out ) :: left_stack ( num_vectors ) !! Left stack integer ( int32 ), intent ( out ) :: right_stack ( num_vectors ) !! Right stack integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: recursion_stack ( 3 , num_vectors ) call build_spherical_kd ( vectors , num_dimensions , num_vectors , sphere_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , recursion_stack , ierr ) end subroutine build_spherical_kd_r !> C interface for building KD index subroutine build_kd_index_C ( points , num_dimensions , num_points , kd_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , ierr ) & bind ( C , name = \"build_kd_index_C\" ) use iso_c_binding , only : c_int , c_double , c_f_pointer , c_loc use iso_fortran_env , only : int32 use kd_tree , only : build_kd_index implicit none integer ( c_int ), value :: num_dimensions integer ( c_int ), value :: num_points real ( c_double ), intent ( in ) :: points ( num_dimensions , num_points ) integer ( c_int ), intent ( in ) :: dimension_order ( num_dimensions ) integer ( c_int ), intent ( out ) :: kd_indices ( num_points ) integer ( c_int ), intent ( out ) :: workspace ( num_points ) real ( c_double ), intent ( out ) :: value_buffer ( num_points ) integer ( c_int ), intent ( out ) :: permutation ( num_points ) integer ( c_int ), intent ( out ) :: left_stack ( num_points ) integer ( c_int ), intent ( out ) :: right_stack ( num_points ) integer ( c_int ), intent ( out ) :: ierr integer ( int32 ) :: recursion_stack ( 3 , num_points ) ! Call the original implementation call build_kd_index ( points , num_dimensions , num_points , kd_indices , dimension_order , & workspace , value_buffer , permutation , left_stack , right_stack , recursion_stack , ierr ) end subroutine build_kd_index_C","tags":"","url":"sourcefile/k_d_tree.f90.html"},{"title":"deserialize_int.F90 – TensorOmics","text":"Source Code !> Module for deserializing integer arrays from files module int_deserialize_mod use , intrinsic :: iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_loc , c_f_pointer use array_utils , only : ascii_to_string , read_file_header , check_okay_dims , check_okay_ndims use tox_errors implicit none private public :: deserialize_int_1d , deserialize_int_2d , & deserialize_int_3d , deserialize_int_4d , deserialize_int_5d contains !> Deserialize a flat integer array from a file !> Directly deserialize a 1D integer array from a file subroutine deserialize_int_1d ( arr , filename , ierr ) integer ( int32 ), intent ( out ) :: arr (:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 1 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_1d !> Directly deserialize a 2D integer array from a file subroutine deserialize_int_2d ( arr , filename , ierr ) integer ( int32 ), intent ( out ) :: arr (:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 2 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_2d !> Directly deserialize a 3D integer array from a file subroutine deserialize_int_3d ( arr , filename , ierr ) integer ( int32 ), intent ( out ) :: arr (:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 3 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_3d !> Directly deserialize a 4D integer array from a file subroutine deserialize_int_4d ( arr , filename , ierr ) integer ( int32 ), intent ( out ) :: arr (:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the File integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 4 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_4d !> Directly deserialize a 5D integer array from a file subroutine deserialize_int_5d ( arr , filename , ierr ) integer ( int32 ), intent ( out ) :: arr (:,:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 5 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_5d end module int_deserialize_mod !> R interface for deserializing an integer array from a file !> @note The output array is handled and preallocated by R subroutine deserialize_int_r ( flat_arr , arr_size , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : int32 use array_utils , only : ascii_to_string , read_file_header use tox_errors , only : set_err_once , set_ok , is_ok , ERR_SIZE_MISMATCH , ERR_READ_DATA implicit none integer ( int32 ), intent ( in ) :: arr_size !! size of the array integer ( int32 ), intent ( out ) :: flat_arr ( arr_size ) !! array passed by R integer ( int32 ), intent ( in ) :: fn_len !! length of the filename integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! filename to read from integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror character ( len = :), allocatable :: filename !! filename in characters integer ( int32 ), allocatable :: dims (:) !! dimensions of the array integer ( int32 ) :: unit , type_code , ndims , clen call set_ok ( ierr ) call set_ok ( ioerror ) call ascii_to_string ( filename_ascii , fn_len , filename ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return if ( product ( dims ) /= arr_size ) then call set_err_once ( ierr , ERR_SIZE_MISMATCH ) return end if ! Read directly into R buffer read ( unit , iostat = ioerror ) flat_arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) RETURN end if end subroutine !> C binding for the subroutine to deserialize an integer array from a file !>@note It is assumed that the array is already allocated and passed together with its size subroutine deserialize_int_C ( arr , arr_size , filename_ascii , fn_len , ierr ) bind ( C , name = \"deserialize_int_C\" ) use iso_c_binding , only : c_int use iso_fortran_env , only : int32 use array_utils , only : ascii_to_string , read_file_header use tox_errors , only : set_err_once , set_ok , is_ok , ERR_SIZE_MISMATCH , ERR_READ_DATA implicit none ! Inputs / Outputs integer ( c_int ), value :: arr_size ! Buffer length !! Size of the array integer ( c_int ), intent ( out ) :: arr ( arr_size ) ! Preallocated buffer from C/Python !! preallocated array integer ( c_int ), value :: fn_len !! length of the filename integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Filename in ascii integer ( c_int ), intent ( out ) :: ierr !! Error code ! Locals character ( len = :), allocatable :: filename integer ( int32 ), allocatable :: dims (:) integer ( int32 ) :: unit integer ( int32 ) :: ioerror integer ( int32 ) :: type_code , ndims , clen call set_ok ( ierr ) call set_ok ( ioerror ) ! ASCII → String call ascii_to_string ( filename_ascii , fn_len , filename ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return ! Safety check: ensure provided buffer matches size in file if ( product ( dims ) /= arr_size ) then call set_err_once ( ierr , ERR_SIZE_MISMATCH ) close ( unit ) return end if ! Read directly into C/Python-provided buffer → ZERO COPY read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_int_C","tags":"","url":"sourcefile/deserialize_int.f90.html"},{"title":"tox_gene_centroids.f90 – TensorOmics","text":"Source Code !>Module for computing expression centroids of gene families. ! ! This module contains the core scientific kernel. The C and R interface ! wrappers are defined outside the module for compatibility. module tox_gene_centroids use , intrinsic :: iso_fortran_env , only : int32 , real64 use tox_errors , only : ERR_INVALID_INPUT , ERR_EMPTY_INPUT , set_ok , set_err_once , is_ok implicit none integer ( int32 ), parameter , public :: GROUP_ORTHOLOGS = 0 integer ( int32 ), parameter , public :: GROUP_ALL = 1 contains !> Computes the element-wise mean for a given set of vectors. pure subroutine mean_vector ( expression_vectors , n_axes , n_genes , gene_indices , n_selected_genes , centroid , ierr ) implicit none !| Number of axes (tissues/dimensions). integer ( int32 ), intent ( in ) :: n_axes !| Total number of genes in the input matrix. integer ( int32 ), intent ( in ) :: n_genes !| The input matrix of all gene expression vectors (n_axes x n_genes). real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| The number of genes in the current family to be averaged. integer ( int32 ), intent ( in ) :: n_selected_genes !| An array containing the column indices of the selected genes in 'expression_vectors'. integer ( int32 ), intent ( in ) :: gene_indices ( n_selected_genes ) !| The output vector representing the computed centroid. real ( real64 ), intent ( out ) :: centroid ( n_axes ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr ! Local variables integer ( int32 ) :: i , j , gene_idx real ( real64 ) :: sum_val ! Initialize error code call set_ok ( ierr ) ! Check for n_genes < 0 if ( n_axes <= 0 . or . n_genes <= 0 ) then call set_err_once ( ierr , ERR_EMPTY_INPUT ) return end if ! Check for invalid n_selected_genes (not < 0 and not > n_genes) if ( n_selected_genes > n_genes ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! If no genes are selected, return a zero vector centroid = 0.0_real64 if ( n_selected_genes == 0 ) return ! Compute the mean vector do j = 1 , n_axes sum_val = 0.0_real64 ! For each selected gene, accumulate its expression value. do i = 1 , n_selected_genes gene_idx = gene_indices ( i ) sum_val = sum_val + expression_vectors ( j , gene_idx ) end do ! Compute the mean for the current dimension by dividing through the number of selected genes. centroid ( j ) = sum_val / real ( n_selected_genes , real64 ) end do end subroutine mean_vector !> Iterates over families, filters gene indices, and computes centroids. pure subroutine group_centroid ( expression_vectors , n_axes , n_genes , gene_to_family , n_families , & centroid_matrix , mode , selected_indices , ierr , ortholog_set ) implicit none !| Number of axes (tissues/dimensions). integer ( int32 ), intent ( in ) :: n_axes !| Total number of genes in the 'expression_vectors' matrix. integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families to compute centroids for. integer ( int32 ), intent ( in ) :: n_families !| The input matrix of all gene expression vectors (n_axes x n_genes). real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| An array mapping each gene (by index) to a family ID. integer ( int32 ), intent ( in ) :: gene_to_family ( n_genes ) !| A integer constant indicating the mode of operation (\"all\" or \"orthologs\"). integer ( int32 ), intent ( in ) :: mode !| The output matrix (n_axes x n_families) to store the computed centroids. real ( real64 ), intent ( out ) :: centroid_matrix ( n_axes , n_families ) !| An output array for storing indices. integer ( int32 ), intent ( out ) :: selected_indices ( n_genes ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr !| A logical array indicating if a gene is part of a specific subset (e.g., orthologs). logical , intent ( in ), optional :: ortholog_set ( n_genes ) ! Local variables integer ( int32 ) :: i , j , n_selected ! Initialize error code call set_ok ( ierr ) ! Determine the mode of operation if ( mode /= GROUP_ALL . and . mode /= GROUP_ORTHOLOGS ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! If \"orthologs\" mode is selected, ensure ortholog_set is provided if ( mode == GROUP_ORTHOLOGS . and . . not . present ( ortholog_set )) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! Check for arguments <= 0 if ( n_axes <= 0 . or . n_genes <= 0 . or . n_families <= 0 ) then call set_err_once ( ierr , ERR_EMPTY_INPUT ) return end if do j = 1 , n_families ! Reset selected indices for the current family selected_indices = 0 n_selected = 0 do i = 1 , n_genes ! Validate family ID if ( gene_to_family ( i ) < 1 . or . gene_to_family ( i ) > n_families ) then call set_err_once ( ierr , ERR_INVALID_INPUT ) return end if ! Check if the gene belongs to the current family and in orthologs set if required if ( gene_to_family ( i ) == j ) then if ( mode == GROUP_ORTHOLOGS ) then if (. not . ortholog_set ( i )) cycle end if n_selected = n_selected + 1 selected_indices ( n_selected ) = i end if end do call mean_vector ( expression_vectors , n_axes , n_genes , selected_indices , n_selected , centroid_matrix (:, j ), ierr ) if (. not . is_ok ( ierr )) return end do end subroutine group_centroid end module tox_gene_centroids ! ============================================================================= ! C Wrapper Subroutine ! ============================================================================= !> C interface wrapper for mean_vector. pure subroutine mean_vector_c ( expression_vectors , n_axes , n_genes , gene_indices , n_selected_genes , centroid_col , ierr ) & bind ( c , name = 'mean_vector_c' ) use , intrinsic :: iso_c_binding , only : c_int , c_double use tox_gene_centroids , only : mean_vector implicit none !| Number of axes (tissues/dimensions). integer ( c_int ), intent ( in ), value :: n_axes !| Total number of genes in the input matrix. integer ( c_int ), intent ( in ), value :: n_genes !| The input matrix of all gene expression vectors (n_axes x n_genes). real ( c_double ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| The number of genes in the current family to be averaged. integer ( c_int ), intent ( in ), value :: n_selected_genes !| An array containing the column indices of the selected genes in 'expression_vectors'. integer ( c_int ), intent ( in ) :: gene_indices ( n_selected_genes ) !| The output vector representing the computed centroid. real ( c_double ), intent ( out ) :: centroid_col ( n_axes ) !| Error code: 0 - success, non-zero = error integer ( c_int ), intent ( out ) :: ierr call mean_vector ( expression_vectors , n_axes , n_genes , gene_indices , n_selected_genes , centroid_col , ierr ) end subroutine mean_vector_c !> C interface wrapper for group_centroid. pure subroutine group_centroid_c ( expression_vectors , n_axes , n_genes , gene_to_family , n_families , & centroid_matrix , mode , ortholog_set , selected_indices , & selected_indices_len , ierr ) & bind ( c , name = 'group_centroid_c' ) use , intrinsic :: iso_c_binding , only : c_int , c_double , c_char use tox_gene_centroids , only : group_centroid , GROUP_ORTHOLOGS , GROUP_ALL use tox_errors , only : is_ok , set_err , ERR_INVALID_INPUT use tox_conversions , only : c_char_1d_as_string , c_int_as_logical implicit none !| Number of axes (tissues/dimensions). integer ( c_int ), intent ( in ), value :: n_axes !| Total number of genes. integer ( c_int ), intent ( in ), value :: n_genes !| Total number of families. integer ( c_int ), intent ( in ), value :: n_families !| The allocated length of the 'selected_indices' array. integer ( c_int ), intent ( in ), value :: selected_indices_len !| Input expression vectors (passed from C). real ( c_double ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| Array mapping gene index to family ID. integer ( c_int ), intent ( in ) :: gene_to_family ( n_genes ) !| A character array indicating the mode of operation ('orthologs' or 'all'). character ( c_char ), intent ( in ) :: mode ( 10 ) !| Output matrix for centroids. real ( c_double ), intent ( out ) :: centroid_matrix ( n_axes , n_families ) !| Output array for selected indices. integer ( c_int ), intent ( out ) :: selected_indices ( selected_indices_len ) !| Error code: 0 - success, non-zero = error integer ( c_int ), intent ( out ) :: ierr !| Integer array from C indicating subset membership. integer ( c_int ), intent ( in ) :: ortholog_set ( n_genes ) ! Local variables logical :: ortholog_set_fortran ( n_genes ) integer :: i , mode_int character ( len = :), allocatable :: mode_string ! Convert raw character array to Fortran string call c_char_1d_as_string ( mode , mode_string , ierr ) if (. not . is_ok ( ierr )) return ! If \"orthologs\" mode is selected, convert ortholog_set to logical ! If \"all\" mode is selected, call group_centroid directly without ortholog_set select case ( mode_string ) case ( \"orthologs\" ) mode_int = GROUP_ORTHOLOGS call c_int_as_logical ( ortholog_set , ortholog_set_fortran ) case ( \"all\" ) mode_int = GROUP_ALL case default call set_err ( ierr , ERR_INVALID_INPUT ) return end select call group_centroid ( expression_vectors , n_axes , n_genes , gene_to_family , n_families , & centroid_matrix , mode_int , selected_indices , ierr , ortholog_set_fortran ) end subroutine group_centroid_c ! ============================================================================= ! R Wrapper Subroutine ! ============================================================================= !> R interface wrapper for mean_vector. pure subroutine mean_vector_r ( expression_vectors , n_axes , n_genes , gene_indices , n_selected_genes , centroid_col , ierr ) use , intrinsic :: iso_fortran_env , only : int32 , real64 use tox_gene_centroids , only : mean_vector implicit none !| Number of axes (tissues/dimensions). integer ( int32 ), intent ( in ) :: n_axes !| Total number of genes in the input matrix. integer ( int32 ), intent ( in ) :: n_genes !| The input matrix of all gene expression vectors (n_axes x n_genes). real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| The number of genes in the current family to be averaged. integer ( int32 ), intent ( in ) :: n_selected_genes !| An array containing the column indices of the selected genes in 'expression_vectors'. integer ( int32 ), intent ( in ) :: gene_indices ( n_selected_genes ) !| The output vector representing the computed centroid. real ( real64 ), intent ( out ) :: centroid_col ( n_axes ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr call mean_vector ( expression_vectors , n_axes , n_genes , gene_indices , n_selected_genes , centroid_col , ierr ) end subroutine mean_vector_r !> R interface wrapper for group_centroid. pure subroutine group_centroid_r ( expression_vectors , n_axes , n_genes , gene_to_family , n_families , & centroid_matrix , mode_raw , ortholog_set , & selected_indices , selected_indices_len , ierr ) use , intrinsic :: iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_char use tox_gene_centroids , only : group_centroid , GROUP_ORTHOLOGS , GROUP_ALL use tox_conversions , only : c_char_1d_as_string use tox_errors , only : is_ok , set_err , ERR_INVALID_INPUT implicit none !| Number of axes (tissues/dimensions). integer ( int32 ), intent ( in ) :: n_axes !| Total number of genes in the 'expression_vectors' matrix. integer ( int32 ), intent ( in ) :: n_genes !| Total number of gene families to compute centroids for. integer ( int32 ), intent ( in ) :: n_families !| The allocated length of the 'selected_indices' array. integer ( int32 ), intent ( in ) :: selected_indices_len !| The input matrix of all gene expression vectors (n_axes x n_genes). real ( real64 ), intent ( in ) :: expression_vectors ( n_axes , n_genes ) !| An array mapping each gene (by index) to a family ID. integer ( int32 ), intent ( in ) :: gene_to_family ( n_genes ) !| A raw character array indicating the mode of operation (\"orthologs\" or \"all\"). character ( c_char ), intent ( in ) :: mode_raw ( 10 ) !| A logical array indicating if a gene is part of a specific subset. logical , intent ( in ) :: ortholog_set ( n_genes ) !| The output matrix (n_axes x n_families) to store the computed centroids. real ( real64 ), intent ( out ) :: centroid_matrix ( n_axes , n_families ) !| An output array for storing selected gene indices. integer ( int32 ), intent ( out ) :: selected_indices ( selected_indices_len ) !| Error code: 0 - success, non-zero = error integer ( int32 ), intent ( out ) :: ierr ! Local variables integer ( int32 ) :: mode_int character ( len = :), allocatable :: mode_string ! Convert raw character array to Fortran string call c_char_1d_as_string ( mode_raw , mode_string , ierr ) if (. not . is_ok ( ierr )) return ! Convert string to integer mode select case ( mode_string ) case ( \"orthologs\" ) mode_int = GROUP_ORTHOLOGS case ( \"all\" ) mode_int = GROUP_ALL case default call set_err ( ierr , ERR_INVALID_INPUT ) return end select call group_centroid ( expression_vectors , n_axes , n_genes , gene_to_family , n_families , & centroid_matrix , mode_int , selected_indices , ierr , ortholog_set ) end subroutine group_centroid_r","tags":"","url":"sourcefile/tox_gene_centroids.f90.html"},{"title":"deserialize_real.F90 – TensorOmics","text":"Source Code !> Module for deserializing real (double precision) arrays from binary files module real_deserialize_mod use , intrinsic :: iso_fortran_env , only : int32 , real64 use iso_c_binding , only : c_loc , c_f_pointer use array_utils , only : ascii_to_string , read_file_header , check_okay_dims , check_okay_ndims use , intrinsic :: iso_fortran_env , only : real64 , int32 use tox_errors implicit none private public :: deserialize_real_1d , deserialize_real_2d , & deserialize_real_3d , deserialize_real_4d , deserialize_real_5d contains !> Directly deserialize a 1D real array from a file (array already allocated) subroutine deserialize_real_1d ( arr , filename , ierr ) real ( real64 ), intent ( out ) :: arr (:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 1 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_1d !> Directly deserialize a 2D real array from a file (array already allocated) subroutine deserialize_real_2d ( arr , filename , ierr ) real ( real64 ), intent ( out ) :: arr (:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 2 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_2d !> Directly deserialize a 3D real array from a file (array already allocated) subroutine deserialize_real_3d ( arr , filename , ierr ) real ( real64 ), intent ( out ) :: arr (:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 3 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_3d !> Directly deserialize a 4D real array from a file (array already allocated) subroutine deserialize_real_4d ( arr , filename , ierr ) real ( real64 ), intent ( out ) :: arr (:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 4 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_4d !> Directly deserialize a 5D real array from a file (array already allocated) subroutine deserialize_real_5d ( arr , filename , ierr ) real ( real64 ), intent ( out ) :: arr (:,:,:,:,:) !! Pre-allocated array to read the data into character ( len =* ), intent ( in ) :: filename !! Name of the file integer ( int32 ), intent ( out ) :: ierr !! Error code integer ( int32 ) :: unit , type_code , ndims , clen , ioerror integer ( int32 ), allocatable :: dims (:) call set_ok ( ierr ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return call check_okay_ndims ( ndims , 5 , unit , ierr ) if (. not . is_ok ( ierr )) return read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_5d end module real_deserialize_mod !> R binding for the subroutine to deserialize a flat real array from a file !> @note It is assumed that the array is already allocated and passed together with its size subroutine deserialize_real_flat_r ( flat_arr , arr_size , filename_ascii , fn_len , ierr ) use iso_fortran_env , only : real64 , int32 use array_utils , only : ascii_to_string , read_file_header use tox_errors , only : set_ok , set_err_once , is_ok , ERR_SIZE_MISMATCH , ERR_READ_DATA implicit none integer ( int32 ), intent ( in ) :: fn_len !! length of the filename integer ( int32 ), intent ( in ) :: arr_size !! size of the array real ( real64 ), intent ( out ) :: flat_arr ( arr_size ) !! array provided by R integer ( int32 ), intent ( in ) :: filename_ascii ( fn_len ) !! filename in ascii integer ( int32 ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror !! internal fortran error character ( len = :), allocatable :: filename !! filename integer ( int32 ), allocatable :: dims (:) !! dimensions integer ( int32 ) :: unit , type_code , ndims , clen call set_ok ( ierr ) call set_ok ( ioerror ) call ascii_to_string ( filename_ascii , fn_len , filename ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return if ( product ( dims ) /= arr_size ) then call set_err_once ( ierr , ERR_SIZE_MISMATCH ) close ( unit ) return end if read ( unit , iostat = ioerror ) flat_arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine !> C binding for the subroutine to deserialize a real array from a file !> @note It is assumed that the array is already allocated and passed together with its size subroutine deserialize_real_C ( arr , arr_size , filename_ascii , fn_len , ierr ) bind ( C , name = \"deserialize_real_C\" ) use iso_c_binding , only : c_int , c_double use iso_fortran_env , only : int32 , real64 use array_utils , only : ascii_to_string , read_file_header use tox_errors , only : set_ok , set_err_once , is_ok , ERR_SIZE_MISMATCH , ERR_READ_DATA implicit none ! Inputs / Outputs integer ( c_int ), value :: arr_size !! size of the output array real ( c_double ), intent ( out ) :: arr ( arr_size ) !! output array integer ( c_int ), value :: fn_len !! length of the filename integer ( c_int ), intent ( in ) :: filename_ascii ( fn_len ) !! Filename in ascii integer ( c_int ), intent ( out ) :: ierr !! error code integer ( int32 ) :: ioerror !! internal fortran error ! Locals character ( len = :), allocatable :: filename !! filename integer ( int32 ), allocatable :: dims (:) !! dimensions integer ( int32 ) :: unit integer ( int32 ) :: type_code , ndims , clen ierr = 0 ! ASCII to String call ascii_to_string ( filename_ascii , fn_len , filename ) call read_file_header ( filename , unit , type_code , ndims , dims , clen , ierr ) if (. not . is_ok ( ierr )) return ! Safety check: ensure provided buffer matches size in file if ( product ( dims ) /= arr_size ) then call set_err_once ( ierr , ERR_SIZE_MISMATCH ) close ( unit ) return end if ! Read directly into provided buffer read ( unit , iostat = ioerror ) arr close ( unit ) if (. not . is_ok ( ioerror )) then call set_err_once ( ierr , ERR_READ_DATA ) return end if end subroutine deserialize_real_C","tags":"","url":"sourcefile/deserialize_real.f90.html"}]}