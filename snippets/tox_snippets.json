{
	"R wrapper legend": {
		"prefix": "tox:legend_r",
		"body": [
		"!> IMPORTANT - When using these R wrapper functions, copies of the arrays will be created.",
		"!| No direct modification of the original R objects occurs."
		],
		"description": "Standard legend for R wrappers about array copy behavior"
	},
	"C wrapper legend": {
		"prefix": "tox:legend_c",
		"body": [
		"!> IMPORTANT - When using these C wrapper functions, no copies of the arrays will be created.",
		"!| The Fortran routine will operate directly on the memory provided by the caller."
		],
		"description": "Standard legend for C wrappers about direct memory access"
	},
	"Call to normalize_by_std_dev": {
      "prefix": "tox:norm_by_std_dev",
      "body": [
        "! Normalize expression values using sqrt(mean(x^2)) across tissues",
        "call normalize_by_std_dev_r(n_genes, n_tissues, input_matrix, output_matrix, ierr)"
      ],
      "description": "Invoke normalization by standard deviation"
    },
    
    "Call to quantile_normalization": {
      "prefix": "tox:norm_quantile",
      "body": [
        "! Quantile normalization - makes distributions identical across tissues",
        "call quantile_normalization_r(n_genes, n_tissues, input_matrix, output_matrix, &",
        "                           temp_col, rank_means, perm, stack_left, stack_right, max_stack, ierr)"
      ],
      "description": "Invoke quantile normalization with rank averaging"
    },
    
    "Call to log2_transformation": {
      "prefix": "tox:norm_log2_trans",
      "body": [
        "! Apply log2(x + 1) transformation to stabilize variance",
        "call log2_transformation_r(n_genes, n_tissues, input_matrix, output_matrix, ierr)"
      ],
      "description": "Apply log2(x + 1) transformation to expression data"
    },
    
    "Call to calc_tiss_avg": {
      "prefix": "tox:norm_tiss_avg",
      "body": [
        "! Calculate tissue averages by grouping replicates",
        "call calc_tiss_avg_r(n_gene, n_grps, group_s, group_c, input_matrix, output_matrix, ierr)"
      ],
      "description": "Calculate average expression per tissue group from replicates"
    },
  
  "Call to calc_fchange": {
    "prefix": "tox:norm_fchange",
    "body": [
      "! Calculate log2 fold changes between condition and control pairs",
      "call calc_fchange_r(n_genes, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ierr)"
    ],
    "description": "Calculate log2 fold changes between condition-control pairs"
  },
  "Call to euclidean_distance": {
    "prefix": "tox:euclidean_distance",
    "body": [
      "! Calculate Euclidean distance between two vectors",
      "call euclidean_distance(vec1, vec2, d, result)"
    ],
    "description": "Invoke Euclidean distance calculation between two vectors"
  },
  "Call to distance_to_centroid": {
    "prefix": "tox:distance_to_centroid",
    "body": [
      "! Calculate distance from each gene to its family centroid",
      "call distance_to_centroid(n_genes, n_families, genes, centroids, &",
      "  gene_to_fam, distances, d)"
    ],
    "description": "Invoke distance calculation from genes to family centroids"
  },
  "Wrapper R": {
    "prefix": "wrapper_r",
    "body": [
      "subroutine ${1:core_name}_r(${2:args})",
      "  use ${3:module}",
      "  ${4:! -- declare arguments here as in the core routine --}",
      "  call ${1:core_name}(${2:args})",
      "end subroutine ${1:core_name}_r"
    ],
    "description": "Wrapper for R (2D arrays, no bind(C))"
  },
  "Wrapper C/Python": {
    "prefix": "wrapper_c",
    "body": [
      "! -- use this snippet or helper_c_srapper.py to generate the C wrapper",
      "subroutine ${1:core_name}_c(${2:args}) bind(C, name=\"${1:core_name}_c\")",
      "  use iso_c_binding",
      "  use ${3:module}",
      "  ${4:! -- declare arguments here with snippets c_arg or flat_array_2d as needed --}",
      "  call ${1:core_name}(${2:args})",
      "end subroutine ${1:core_name}_c"
    ],
    "description": "Wrapper for C/Python (bind(C), flat arrays)"
  },
  "Fortran argument declaration": {
    "prefix": "r_arg",
    "body": [
      "${1:type}, intent(${2:inout}) :: ${3:name}${4:(dimensions)}"
    ],
    "description": "Fortran standard argument declaration"
  },
  "C argument declaration": {
    "prefix": "c_arg",
    "body": [
      "${1:c_type}, intent(${2:inout}), target :: ${3:name}(*)"
    ],
    "description": "C-style argument declaration"
  },
  "c_f_pointer 2D": {
    "prefix": "flat_array_2d",
    "body": [
      "real(c_double), pointer :: ${1:mat}(:,:)",
      "call c_f_pointer(c_loc(${2:flat_array}(1)), ${1:mat}, [${3:n1}, ${4:n2}])"
    ],
    "description": "Map flat array to 2D with c_f_pointer"
  },
  "R call to normalize_by_std_dev": {
    "prefix": "tox:R_norm_by_std_dev",
    "body": [
    "result <- .Fortran(\"normalize_by_std_dev_r\",",
    "                  as.integer(${1:n_genes}),",
    "                  as.integer(${2:n_tissues}),",
    "                  ${3:input_vector},",
    "                  output_vector = numeric(length(${3:input_vector})))",
    "                  ierr = as.integer(0))"

    ],
    "description": "Call normalize_by_std_dev_r Fortran function from R"
  },
  "R call to quantile_normalization": {
    "prefix": "tox:R_quantile_norm",
    "body": [
      "result <- .Fortran(\"quantile_normalization_r\",",
      "                  as.integer(${1:n_genes}),",
      "                  as.integer(${2:n_tissues}),",
      "                  ${3:input_matrix},",
      "                  output_matrix = numeric(length(${3:input_matrix})),",
      "                  temp_col = numeric(${1:n_genes}),",
      "                  rank_means = numeric(${1:n_genes}),",
      "                  perm = as.integer(1:${1:n_genes}),",
      "                  stack_left = integer(max(2 * ${1:n_genes}, 2)),",
      "                  stack_right = integer(max(2 * ${1:n_genes}, 2)),",
      "                  max_stack = as.integer(max(2 * ${1:n_genes}, 2)))",
      "                  ierr = as.integer(0))"
    ],
    "description": "Call quantile_normalization_r Fortran function from R"
  },
  "R call to log2_transformation": {
    "prefix": "tox:R_norm_log2_trans",
    "body": [
    "result <- .Fortran(\"log2_transformation_r\",",
    "                  as.integer(${1:n_genes}),",
    "                  as.integer(${2:n_tissues}),",
    "                  ${3:input_vector},",
    "                  output_vector = numeric(length(${3:input_vector})))",
    "                  ierr = as.integer(0))"
    ],
    "description": "Call log2_transformation_r Fortran function from R"
  },
  "R call to calc_tiss_avg": {
    "prefix": "tox:R_calc_tiss_avg",
    "body": [
    "result <- .Fortran(\"calc_tiss_avg_r\",",
    "                  as.integer(${1:n_genes}),",
    "                  as.integer(${2:n_groups}),",
    "                  as.integer(${3:group_starts}),",
    "                  as.integer(${4:group_counts}),",
    "                  ${5:input_matrix},",
    "                  output_matrix = numeric(${1:n_genes} * ${2:n_groups}))",
    "                  ierr = as.integer(0))"
    ],
    "description": "Call calc_tiss_avg_r Fortran function from R"
  },
  "R call to calc_fchange": {
    "prefix": "tox:R_calc_fchange",
    "body": [
    "result <- .Fortran(\"calc_fchange_r\",",
    "                  as.integer(${1:n_genes}),",
    "                  as.integer(${2:n_pairs}),",
    "                  as.integer(${3:control_cols}),",
    "                  as.integer(${4:condition_cols}),",
    "                  ${5:input_matrix},",
    "                  output_matrix = numeric(${1:n_genes} * ${2:n_pairs}))",
    "                  ierr = as.integer(0))"
    ],
    "description": "Call calc_fchange_r Fortran function from R"
  },
  "R call to euclidean_distance between 2 vectors": {
    "prefix": "tox:R_euclidean_distance",
    "body": [
      "result <- .Fortran(\"euclidean_distance_r\",",
      "                  vec1 = as.double(${1:vector1}),",
      "                  vec2 = as.double(${2:vector2}),",
      "                  d = as.integer(${3:dimension}),",
      "                  result = as.double(0.0))"
    ],
    "description": "Call euclidean_distance_r Fortran function from R"
  },
  "R call to distance_to_centroid": {
    "prefix": "tox:R_distance_to_centroid",
    "body": [
      "result <- .Fortran(\"distance_to_centroid_r\",",
      "                  n_genes = as.integer(${1:n_genes}),",
      "                  n_families = as.integer(${2:n_families}),",
      "                  genes = as.double(${3:gene_matrix}),",
      "                  centroids = as.double(${4:centroid_matrix}),",
      "                  gene_to_fam = as.integer(${5:gene_to_family}),",
      "                  distances = as.double(numeric(${1:n_genes})),",
      "                  d = as.integer(${6:dimension}))"
    ],
    "description": "Call distance_to_centroid_r Fortran function from R"
  },
  "Load libraries for C": {
    "prefix": "tox:load_c_libs",
    "body": [
      "import numpy as np",
      "import ctypes",
      "",
      "# Load library",
      "ctypes.CDLL(\"libgomp.so.1\", mode=ctypes.RTLD_GLOBAL)",
      "lib = ctypes.CDLL(\"build/libtensor-omics.so\")"
    ],
    "description": "TOX Python imports and library loading"
  },
  "C call to normalize_by_std_dev": {
    "prefix": "tox:C_norm_by_std_dev",
    "body": [
    "    lib.normalize_by_std_dev_c.argtypes = [",
    "        ctypes.c_int, # n_genes",
    "        ctypes.c_int, # n_tissues",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # input_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # output_matrix",
    "        ctypes.POINTER(ctypes.c_int)  # ierr",
    "    ]",
    "    lib.normalize_by_std_dev_c.restype = None",
    "    lib.normalize_by_std_dev_c(n_genes, n_tissues, input_matrix, output_matrix, ctypes.byref(ierr))"
    ],
    "description": "Setup normalize_by_std_dev_c function binding"
  },
  "C call to quantile_normalization": {
    "prefix": "tox:C_quantile_norm",
    "body": [
    "    lib.quantile_normalization_c.argtypes = [",
    "        ctypes.c_int, # n_genes", 
    "        ctypes.c_int, # n_tissues",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # input_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # output_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # temp_col",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # rank_means",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), # perm",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), # stack_left",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), # stack_right",
    "        ctypes.c_int, # max_stack",
    "        ctypes.POINTER(ctypes.c_int)  # ierr",
    "    ]",
    "    lib.quantile_normalization_c.restype = None",
    "    lib.quantile_normalization_c(n_genes, n_tissues, input_matrix, output_matrix, temp_col, rank_means, perm, stack_left, stack_right, max_stack, ctypes.byref(ierr))"
    ],
    "description": "Setup quantile_normalization_c function binding"
  },
  "C call to log2_transformation": {
    "prefix": "tox:C_norm_log2_trans",
    "body": [
    "    lib.log2_transformation_c.argtypes = [",
    "        ctypes.c_int, # n_genes ",
    "        ctypes.c_int, # n_tissues",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # input_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # output_matrix",
    "        ctypes.POINTER(ctypes.c_int)  # ierr",
    "    ]",
    "    lib.log2_transformation_c.restype = None",
    "    lib.log2_transformation_c(n_genes, n_tissues, input_matrix, output_matrix, ctypes.byref(ierr))"

    ],
    "description": "Setup log2_transformation_c function binding"
  },
  "C call to calc_tiss_avg": {
    "prefix": "tox:C_calc_tiss_avg",
    "body": [
    "    lib.calc_tiss_avg_c.argtypes = [",
    "        ctypes.c_int, # n_gene", 
    "        ctypes.c_int, # n_grps",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), # group_s",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), # group_c",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # input_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # output_matrix",
    "        ctypes.POINTER(ctypes.c_int)  # ierr",
    "    ]",
    "    lib.calc_tiss_avg_c.restype = None",
    "    lib.calc_tiss_avg_c(n_genes, n_grps, group_s, group_c, input_matrix, output_matrix, ctypes.byref(ierr))"

    ],
    "description": "Setup calc_tiss_avg_c function binding"
  },
  "C call to calc_fchange": {
    "prefix": "tox:C_calc_fchange",
    "body": [
    "    lib.calc_fchange_c.argtypes = [",
    "        ctypes.c_int, # n_genes ",
    "        ctypes.c_int, # n_cols",
    "        ctypes.c_int,  # n_pairs",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), control_cols",
    "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"), cond_cols",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), i_matrix",
    "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), o_matrix",
    "        ctypes.POINTER(ctypes.c_int)  # ierr",
    "    ]",
    "    lib.calc_fchange_c.restype = None",
    "    lib.calc_fchange_c(n_genes, n_cols, n_pairs, control_cols, cond_cols, i_matrix, o_matrix, ctypes.byref(ierr))"
    ],
    "description": "Setup calc_fchange_c function binding"
  },
  "C call to euclidean_distance": {
    "prefix": "tox:C_euclidean_distance",
    "body": [
      "    lib.euclidean_distance_c.argtypes = [",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # vec1",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # vec2",
      "        ctypes.c_int, # dimension",
      "        ctypes.POINTER(ctypes.c_double) # result",
      "    ]",
      "    lib.euclidean_distance_c.restype = None",
      "    lib.euclidean_distance_c(vec1, vec2, dimension, result)"
    ],
    "description": "Setup euclidean_distance_c function binding"
  },
  "C call to distance_to_centroid": {
    "prefix": "tox:C_distance_to_centroid",
    "body": [
      "def setup_distance_to_centroid():",
      "    \"\"\"Setup distance to centroid function\"\"\"",
      "    dist_to_centroid = lib.distance_to_centroid_c",
      "    dist_to_centroid.argtypes = [",
      "        ctypes.c_int, ctypes.c_int,",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),",
      "        ctypes.c_int",
      "    ]",
      "    dist_to_centroid.restype = None",
      "    return dist_to_centroid"
    ],
    "description": "Setup distance_to_centroid_c function binding"
  },
  "Call to compute_family_scaling": {
    "prefix": "tox:compute_family_scaling",
    "body": [
      "! Compute family scaling factors (dscale) for gene outlier detection",
      "call compute_family_scaling_alloc(n_genes, n_families, distances, gene_to_fam, dscale, &",
      "                        loess_x, loess_y, indices_used, error_code)"
    ],
    "description": "Call compute_family_scaling Fortran subroutine for gene outlier detection"
  },
  "Call to compute_family_scaling expert level": {
    "prefix": "tox:compute_family_scaling_expert",
    "body": [
      "! Compute family scaling factors (dscale) for gene outlier detection expert level",
      "call compute_family_scaling(n_genes, n_families, distances, gene_to_fam, dscale, &",
      "                        loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, &",
      "                        family_distances, error_code)"
    ],
    "description": "Call compute_family_scaling Fortran subroutine for gene outlier detection"
  },
  "Call to compute_rdi": {
    "prefix": "tox:compute_rdi",
    "body": [
      "! Compute RDI (Relative Distance Index) for each gene",
      "call compute_rdi(n_genes, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right)"
    ],
    "description": "Call compute_rdi Fortran subroutine for gene outlier detection"
  },
  "Call to identify_outliers": {
    "prefix": "tox:identify_outliers",
    "body": [
      "! Identify gene outliers based on RDI and percentile threshold",
      "call identify_outliers(n_genes, rdi, sorted_rdi, is_outlier, threshold, percentile)"
    ],
    "description": "Call identify_outliers Fortran subroutine for gene outlier detection"
  },
  "Call to detect_outliers": {
    "prefix": "tox:detect_outliers",
    "body": [
      "! Main hybrid routine to detect gene outliers using RDI and LOESS fallback",
      "call detect_outliers(n_genes, n_families, distances, gene_to_fam, &",
      "                  work_array, perm, stack_left, stack_right, is_outlier, &",
      "                  loess_x, loess_y, loess_n, workspace_weights, workspace_values, error_code, &",
      "                  percentile)"
    ],
    "description": "Call detect_outliers Fortran subroutine for gene outlier detection"
  },
  "R call to compute family scaling": {
    "prefix": "tox:R_compute_family_scaling_r",
    "body": [
      "n_genes <- as.integer(${1:n_genes})",
      "n_families <- as.integer(${2:n_families})",
      "distances <- as.double(${3:distances})",
      "gene_to_fam <- as.integer(${4:gene_to_fam})",
      "dscale <- double(n_families)",
      "loess_x <- double(n_families)",
      "loess_y <- double(n_families)",
      "indices_used <- integer(n_families)",
      "error_code <- integer(1)",
      "result <- .Fortran(\"compute_family_scaling_r\",",
      "  n_genes = n_genes,",
      "  n_families = n_families,",
      "  distances = distances,",
      "  gene_to_fam = gene_to_fam,",
      "  dscale = dscale,",
      "  loess_x = loess_x,",
      "  loess_y = loess_y,",
      "  indices_used = indices_used,",
      "  error_code = error_code",
      ")"
    ],
    "description": "Call compute_family_scaling_r Fortran function from R, with explicit array initializations"
  },
  "R call to compute family scaling expert level": {
    "prefix": "tox:R_compute_family_scaling_expert",
    "body": [
      "n_genes <- as.integer(${1:n_genes})",
      "n_families <- as.integer(${2:n_families})",
      "distances <- as.double(${3:distances})",
      "gene_to_fam <- as.integer(${4:gene_to_fam})",
      "dscale <- double(n_families)",
      "loess_x <- double(n_families)",
      "loess_y <- double(n_families)",
      "indices_used <- integer(n_families)",
      "perm_tmp <- integer(n_genes)",
      "stack_left_tmp <- integer(n_genes)",
      "stack_right_tmp <- integer(n_genes)",
      "family_distances <- double(n_genes)",
      "error_code <- integer(1)",
      "result <- .Fortran(\"compute_family_scaling_expert_r\",",
      "  n_genes = n_genes,",
      "  n_families = n_families,",
      "  distances = distances,",
      "  gene_to_fam = gene_to_fam,",
      "  dscale = dscale,",
      "  loess_x = loess_x,",
      "  loess_y = loess_y,",
      "  indices_used = indices_used,",
      "  perm_tmp = perm_tmp,",
      "  stack_left_tmp = stack_left_tmp,",
      "  stack_right_tmp = stack_right_tmp,",
      "  family_distances = family_distances,",
      "  error_code = error_code",
      ")"
    ],
    "description": "Call compute_family_scaling_expert_r Fortran function from R, with explicit array initializations"
  },
  "R call to compute_rdi": {
    "prefix": "tox:R_compute_rdi_r",
    "body": [
      "n_genes <- as.integer(${1:n_genes})",
      "n_families <- as.integer(${2:n_families})",
      "distances <- as.double(${3:distances})",
      "gene_to_fam <- as.integer(${4:gene_to_fam})",
      "dscale <- as.double(${5:dscale})",
      "rdi <- double(n_genes)",
      "sorted_rdi <- double(length(distances))",
      "perm <- as.integer(seq_along(distances))",
      "stack_left <- integer(length(distances))",
      "stack_right <- integer(length(distances))",
      "result <- .Fortran(\"compute_rdi_r\",",
      "  n_genes = n_genes,",
      "  n_families = n_families,",
      "  distances = distances,",
      "  gene_to_fam = gene_to_fam,",
      "  dscale = dscale,",
      "  rdi = rdi",
      "  sorted_rdi = sorted_rdi,",
      "  perm = perm,",
      "  stack_left = stack_left,",
      "  stack_right = stack_right",
      ")"
    ],
    "description": "Call compute_rdi_r Fortran function from R, with explicit array initializations"
  },
  "R call to identify_outliers": {
    "prefix": "tox:R_identify_outliers_r",
    "body": [
      "n_genes <- as.integer(${1:n_genes})",
      "rdi <- as.double(${2:rdi})",
      "sorted_rdi <- double(n_genes)",
      "is_outlier <- logical(n_genes)",
      "threshold <- double(1)",
      "percentile <- as.double(${3:percentile})",
      "result <- .Fortran(\"identify_outliers_r\",",
      "  n_genes = n_genes,",
      "  rdi = rdi,",
      "  sorted_rdi = sorted_rdi,",
      "  is_outlier = is_outlier,",
      "  threshold = threshold,",
      "  percentile = percentile",
      ")"
    ],
    "description": "Call identify_outliers_r Fortran function from R, with explicit array initializations"
  },
  "R call to detect_outliers_r": {
    "prefix": "tox:R_detect_outliers_r",
    "body": [
      "n_genes <- as.integer(${1:n_genes})",
      "n_families <- as.integer(${2:n_families})",
      "distances <- as.double(${3:distances})",
      "gene_to_fam <- as.integer(${4:gene_to_fam})",
      "work_array <- double(n_genes)",
      "perm <- seq_len(n_genes)",
      "stack_left <- integer(n_genes)",
      "stack_right <- integer(n_genes)",
      "is_outlier <- logical(n_genes)",
      "loess_x <- double(n_families)",
      "loess_y <- double(n_families)",
      "loess_n <- integer(n_families)",
      "workspace_weights <- double(n_families)",
      "workspace_values <- matrix(0, 1, n_families)",
      "error_code <- integer(1)",
      "percentile <- as.double(${5:percentile})",
      "result <- .Fortran(\"detect_outliers_r\",",
      "  n_genes = n_genes,",
      "  n_families = n_families,",
      "  distances = distances,",
      "  gene_to_fam = gene_to_fam,",
      "  work_array = work_array,",
      "  perm = perm,",
      "  stack_left = stack_left,",
      "  stack_right = stack_right,",
      "  is_outlier = is_outlier,",
      "  loess_x = loess_x,",
      "  loess_y = loess_y,",
      "  loess_n = loess_n,",
      "  workspace_weights = workspace_weights,",
      "  workspace_values = workspace_values,",
      "  error_code = error_code,",
      "  percentile = percentile",
      ")"
    ],
    "description": "Call detect_outliers_r Fortran function from R, with explicit array initializations"
  },
  "C call for compute_family_scaling expert level": {
    "prefix": "tox:setup_py_compute_family_scaling_expert_c",
    "body": [
      "    lib.compute_family_scaling_expert_c.argtypes = [",
      "        ctypes.c_int,  # n_genes",
      "        ctypes.c_int,  # n_families",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # distances (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # gene_to_fam (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # dscale (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_x (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_y (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # indices_used (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # perm_tmp (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_left_tmp (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_right_tmp (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),    # family_distances (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # error_code (1,)",
      "    ]",
      "    lib.compute_family_scaling_expert_c.restype = None",
      "    lib.compute_family_scaling_expert_c(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, perm_tmp, stack_left_tmp, stack_right_tmp, family_distances, error_code)"
    ],
    "description": "Setup compute_family_scaling_expert_c function binding for Python/ctypes"
  },
  "C call for compute_family_scaling": {
    "prefix": "tox:setup_py_compute_family_scaling_c",
    "body": [
      "    lib.compute_family_scaling_c.argtypes = [",
      "        ctypes.c_int,  # n_genes",
      "        ctypes.c_int,  # n_families",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # distances (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # gene_to_fam (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # dscale (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_x (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_y (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # indices_used (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # error_code (1,)",
      "    ]",
      "    lib.compute_family_scaling_c.restype = None",
      "    lib.compute_family_scaling_c(n_genes, n_families, distances, gene_to_fam, dscale, loess_x, loess_y, indices_used, error_code)"
    ],
    "description": "Setup compute_family_scaling_c function binding for Python/ctypes"
  },
  "C call for compute_rdi": {
    "prefix": "tox:setup_py_compute_rdi_c",
    "body": [
      "    lib.compute_rdi_c.argtypes = [",
      "        ctypes.c_int,  # n_genes",
      "        ctypes.c_int,  # n_families",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # distances (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # gene_to_fam (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # dscale (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # rdi (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # sorted_rdi (n,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # perm (n,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_left (n,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_right (n,)",
      "    ]",
      "    lib.compute_rdi_c.restype = None",
      "    lib.compute_rdi_c(n_genes, n_families, distances, gene_to_fam, dscale, rdi, sorted_rdi, perm, stack_left, stack_right)"
    ],
    "description": "Setup compute_rdi_c function binding for Python/ctypes"
  },
  "C call for identify_outliers": {
    "prefix": "tox:setup_py_identify_outliers_c",
    "body": [
      "    lib.identify_outliers_c.argtypes = [",
      "        ctypes.c_int,  # n",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # rdi (n,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # sorted_rdi (n,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # is_outlier (n,)",
      "        ctypes.POINTER(ctypes.c_double),                                  # threshold (scalar)",
      "        ctypes.c_double                                                   # percentile (scalar)",
      "    ]",
      "    lib.identify_outliers_c.restype = None",
      "    lib.identify_outliers_c(n, rdi, sorted_rdi, is_outlier, threshold, percentile)"
    ],
    "description": "Setup identify_outliers_c function binding for Python/ctypes"
  },
  "C call for detect_outliers": {
    "prefix": "tox:setup_py_detect_outliers_c",
    "body": [
      "    lib.detect_outliers_c.argtypes = [",
      "        ctypes.c_int,  # n_genes ",
      "        ctypes.c_int,  # n_families",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # distances (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # gene_to_fam (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # work_array (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # perm (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_left (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # stack_right (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # is_outlier (n_genes,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_x (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # loess_y (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # loess_n (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # workspace_weights (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # workspace_values (n_families,)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # error_code (1,)",
      "        ctypes.c_double                                                  # percentile (scalar)",
      "    ]",
      "    lib.detect_outliers_c.restype = None",
      "    lib.detect_outliers_c(n_genes, n_families, distances, gene_to_fam, work_array, perm, stack_left, stack_right, is_outlier, loess_x, loess_y, loess_n, workspace_weights, workspace_values, error_code, percentile)"
    ],
    "description": "Setup detect_outliers_c function binding for Python/ctypes"
  },
  "Call to clock_hand_angle_between_vectors": {
    "prefix": "tox:clock_hand_angle_between_vectors",
    "body": [
      "call clock_hand_angle_between_vectors(v1, v2, n_dims, signed_angle, selected_axes_for_signed)"
    ],
    "description": "Invoke clock hand angle calculation between vectors"
  },
  "Call to clock_hand_angles_for_shift_vectors": {
    "prefix": "tox:clock_hand_angles_for_shift_vectors",
    "body": [
      "call clock_hand_angles_for_shift_vectors(origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles)"
    ],
    "description": "Invoke clock hand angles calculation for shift vectors"
  },
  "R call to clock_hand_angle_between_vectors": {
    "prefix": "tox:R_clock_hand_angle_between_vectors",
    "body": [
      "result <- .Fortran(\"clock_hand_angle_between_vectors_r\",",
      "                  v1 = as.double(v1),",
      "                  v2 = as.double(v2),",
      "                  n_dims = as.integer(n_dims),",
      "                  signed_angle = as.double(0),",
      "                  selected_axes_for_signed = as.integer(selected_axes_for_signed))"
    ],
    "description": "Call clock_hand_angle_between_vectors Fortran function from R"
  },
  "R call to clock_hand_angles_for_shift_vectors": {
    "prefix": "tox:R_clock_hand_angles_for_shift_vectors",
    "body": [
      "result <- .Fortran(\"clock_hand_angles_for_shift_vectors_r\",",
      "                  origins = as.double(origins),",
      "                  targets = as.double(targets),",
      "                  n_dims = as.integer(n_dims),",
      "                  n_vecs = as.integer(n_vecs),",
      "                  vecs_selection_mask = as.logical(vecs_selection_mask),",
      "                  n_selected_vecs = as.integer(n_selected_vecs),",
      "                  selected_axes_for_signed = as.integer(selected_axes_for_signed),",
      "                  signed_angles = as.double(signed_angles))"
    ],
    "description": "Call clock_hand_angles_for_shift_vectors Fortran function from R"
  },
  "C call for clock_hand_angle_between_vectors": {
    "prefix": "tox:setup_py_clock_hand_angle_between_vectors_c",
    "body": [
      "    lib.clock_hand_angle_between_vectors_c.argtypes = [",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # v1",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # v2",
      "        ctypes.c_int,  # n_dims",
      "        ctypes.POINTER(ctypes.c_double),  # signed_angle (scalar)",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # selected_axes_for_signed",
      "    ]",
      "    lib.clock_hand_angle_between_vectors_c.restype = None",
      "    lib.clock_hand_angle_between_vectors_c(v1, v2, n_dims, signed_angle, selected_axes_for_signed)"
    ],
    "description": "Setup clock_hand_angle_between_vectors function binding for Python/ctypes"
  },
  "C call for clock_hand_angles_for_shift_vectors": {
    "prefix": "tox:setup_py_clock_hand_angles_for_shift_vectors_c",
    "body": [
      "    lib.clock_hand_angles_for_shift_vectors_c.argtypes = [",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # origins",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # targets",
      "        ctypes.c_int,  # n_dims",
      "        ctypes.c_int,  # n_vecs",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # vecs_selection_mask",
      "        ctypes.c_int,  # n_selected_vecs",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # selected_axes_for_signed",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # signed_angles",
      "    ]",
      "    lib.clock_hand_angles_for_shift_vectors_c.restype = None",
      "    lib.clock_hand_angles_for_shift_vectors_c(origins, targets, n_dims, n_vecs, vecs_selection_mask, n_selected_vecs, selected_axes_for_signed, signed_angles)"
    ],
    "description": "Setup clock_hand_angles_for_shift_vectors function binding for Python/ctypes"
  },
  "Call to relative_axes_changes_from_shift_vector": {
    "prefix": "tox:relative_axes_changes_from_shift_vector",
    "body": [
      "! Compute relative axis contributions from a shift vector (RAP space)",
      "call relative_axes_changes_from_shift_vector(vec, n_dims, contrib)"
    ],
    "description": "Invoke relative axis contributions calculation from shift vector"
  },
  "R call to relative_axes_changes_from_shift_vector": {
    "prefix": "tox:R_relative_axes_changes_from_shift_vector",
    "body": [
      "result <- .Fortran(\"relative_axes_changes_from_shift_vector_r\",",
      "                  vec = as.double(vec),",
      "                  n_dims = as.integer(n_dims),",
      "                  contrib = as.double(numeric(n_dims)))"
    ],
    "description": "Call relative_axes_changes_from_shift_vector Fortran function from R"
  },
  "C call for relative_axes_changes_from_shift_vector": {
    "prefix": "tox:setup_py_relative_axes_changes_from_shift_vector_c",
    "body": [
      "    lib.relative_axes_changes_from_shift_vector_c.argtypes = [",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # vec",
      "        ctypes.c_int,  # n_dims",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # contrib",
      "    ]",
      "    lib.relative_axes_changes_from_shift_vector_c.restype = None",
      "    lib.relative_axes_changes_from_shift_vector_c(vec, n_dims, contrib)"
    ],
    "description": "Setup relative_axes_changes_from_shift_vector function binding for Python/ctypes"
  },
  "C call for relative_axes_expression_from_expression_vector": {
    "prefix": "tox:setup_py_relative_axes_expression_from_expression_vector_c",
    "body": [
      "    lib.relative_axes_expression_from_expression_vector_c.argtypes = [",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # vec",
      "        ctypes.c_int,  # n_dims",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # contrib",
      "    ]",
      "    lib.relative_axes_expression_from_expression_vector_c.restype = None",
      "    lib.relative_axes_expression_from_expression_vector_c(vec, n_dims, contrib)"
    ],
    "description": "Setup relative_axes_expression_from_expression_vector function binding for Python/ctypes"
  },
  "R set up call function for omics_vector_RAP_projection": {
    "prefix": "tox:r_omics_vector_RAP_projection",
    "body": [
      "  n_selected_vecs <- sum(vecs_selection_mask == 1)",
      "  n_selected_axes <- sum(axes_selection_mask == 1)",
      "  res <- .Fortran(\"omics_vector_RAP_projection_r\",",
      "                  vecs = as.double(vecs),",
      "                  n_axes = as.integer(nrow(vecs)),",
      "                  n_vecs = as.integer(ncol(vecs)),",
      "                  vecs_selection_mask = as.integer(vecs_selection_mask),",
      "                  n_selected_vecs = n_selected_vecs,",
      "                  axes_selection_mask = as.integer(axes_selection_mask),",
      "                  n_selected_axes = n_selected_axes,",
      "                  projections = matrix(as.double(1), nrow = n_selected_axes, ncol = n_selected_vecs),",
      "                  ierr = as.integer(0))"
    ],
    "description": "Setup omics_vector_RAP_projection function binding with ierr error handling"
  },
  "R set up call function for omics_field_RAP_projection": {
    "prefix": "tox:r_omics_field_RAP_projection",
    "body": [
      "  n_selected_vecs <- sum(vecs_selection_mask == 1)",
      "  n_selected_axes <- sum(axes_selection_mask == 1)",
      "  res <- .Fortran(\"omics_field_RAP_projection_r\",",
      "                  vecs = as.double(vecs),",
      "                  n_axes = as.integer(nrow(vecs) / 2),",
      "                  n_vecs = as.integer(ncol(vecs)),",
      "                  vecs_selection_mask = as.integer(vecs_selection_mask),",
      "                  n_selected_vecs = n_selected_vecs,",
      "                  axes_selection_mask = as.integer(axes_selection_mask),",
      "                  n_selected_axes = n_selected_axes,",
      "                  projections = matrix(as.double(1), nrow = n_selected_axes, ncol = n_selected_vecs),",
      "                  ierr = as.integer(0))"
    ],
    "description": "Setup omics_field_RAP_projection function binding with ierr error handling"
  },
  "Python set up call function for omics_vector_RAP_projection": {
    "prefix": "tox:py_omics_vector_RAP_projection",
    "body": [
      "# Setup omics_vector_RAP_projection_c call (with ierr error handling)",
      "omics_vector_RAP_projection_c.argtypes = [",
      "    np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"),  # vecs",
      "    ctypes.c_int,  # n_axes",
      "    ctypes.c_int,  # n_vecs",
      "    np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # vecs_selection_mask",
      "    ctypes.c_int,  # n_selected_vecs",
      "    np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # axes_selection_mask",
      "    ctypes.c_int,  # n_selected_axes",
      "    np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"),  # projections",
      "    ctypes.POINTER(ctypes.c_int)  # ierr",
      "]",
      "omics_vector_RAP_projection_c.restype = None",
      "omics_vector_RAP_projection_c(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ctypes.byref(ierr))"
    ],
    "description": "Setup and call omics_vector_RAP_projection_c"
  },
  "Python set up call function for omics_field_RAP_projection": {
    "prefix": "tox:py_omics_field_RAP_projection",
    "body": [
      "# Setup omics_field_RAP_projection_c call (with ierr error handling)",
      "omics_field_RAP_projection_c.argtypes = [",
      "    np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"),  # vecs",
      "    ctypes.c_int,  # n_axes",
      "    ctypes.c_int,  # n_vecs",
      "    np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # vecs_selection_mask",
      "    ctypes.c_int,  # n_selected_vecs",
      "    np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),  # axes_selection_mask",
      "    ctypes.c_int,  # n_selected_axes",
      "    np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"),  # projections",
      "    ctypes.POINTER(ctypes.c_int)  # ierr",
      "]",
      "omics_field_RAP_projection_c.restype = None",
      "omics_field_RAP_projection_c(vecs, n_axes, n_vecs, vecs_selection_mask, n_selected_vecs, axes_selection_mask, n_selected_axes, projections, ctypes.byref(ierr))"
    ],
    "description": "Setup and call omics_field_RAP_projection_c"
  },
  "Call to tissue_versatility": {
    "prefix": "tox:tissue_versatility",
    "body": [
      "! Calculate tissue versatility for selected expression vectors (C/Python interface)",
      "call compute_tissue_versatility(n_axes, n_vectors, expression_vectors, &",
      "    exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, &",
      "    tissue_versatilities, tissue_angles_deg)"
    ],
    "description": "Invoke tissue versatility calculation"
  },
  "R call to tissue_versatility": {
    "prefix": "tox:R_tissue_versatility",
    "body": [
      "result <- .Fortran(\"compute_tissue_versatility_r\",",
      "                  n_axes = as.integer(${1:n_axes}),",
      "                  n_vectors = as.integer(${2:n_vectors}),",
      "                  expression_vectors = as.double(${3:expr_matrix}),",
      "                  exp_vecs_selection_index = as.integer(${4:select_vec}),",
      "                  n_selected_vectors = as.integer(sum(${4:select_vec})),",
      "                  axes_selection = as.integer(${5:select_axes}),",
      "                  n_selected_axes = as.integer(sum(${5:select_axes})),",
      "                  tissue_versatilities = as.double(numeric(sum(${4:select_vec}))),",
      "                  tissue_angles_deg = as.double(numeric(sum(${4:select_vec}))))"
    ],
    "description": "Call compute_tissue_versatility_r Fortran function from R"
  },
  "C call to tissue_versatility": {
    "prefix": "tox:setup_py_tissue_versatility_c",
    "body": [
      "    lib.compute_tissue_versatility_c.argtypes = [",
      "        ctypes.c_int,  # n_axes",
      "        ctypes.c_int,  # n_vectors",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # expression_vectors",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # exp_vecs_selection_index",
      "        ctypes.c_int,  # n_selected_vectors",
      "        np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),    # axes_selection",
      "        ctypes.c_int,  # n_selected_axes",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"),  # tissue_versatilities",
      "        np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\")   # tissue_angles_deg",
      "    ]",
      "    lib.compute_tissue_versatility_c.restype = None",
      "    lib.compute_tissue_versatility_c(n_axes, n_vectors, expression_vectors, &",
      "        exp_vecs_selection_index, n_selected_vectors, axes_selection, n_selected_axes, &",
      "        tissue_versatilities, tissue_angles_deg)"
    ],
    "description": "Setup compute_tissue_versatility_c function binding for Python/ctypes"
  },
  "Fortran: Call to mean_vector": {
      "prefix": "tox:mean_vector",
      "body": [
          "! Computes the element-wise mean for a given set of vectors.",
          "call mean_vector(expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid, ierr)"
      ],
      "description": "Call the core Fortran subroutine to compute a mean vector."
  },
  "Fortran: Call to group_centroid": {
      "prefix": "tox:group_centroid",
      "body": [
          "! Iterates over families, filters gene indices, and computes centroids.",
          "call group_centroid(expression_vectors, n_axes, n_genes, gene_to_family, n_families, &",
          "                   centroid_matrix, use_all_mode, ortholog_set, selected_indices, ierr)"
      ],
      "description": "Call the core Fortran subroutine to compute group centroids."
  },
  "C: Call to mean_vector": {
      "prefix": "tox:setup_py_mean_vector_c",
      "body": [
      "   lib.mean_vector_c.argtypes = [",
      "     np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"), # expression_vectors",
      "     ctypes.c_int,                                                     # n_axes",
      "     ctypes.c_int,                                                     # n_genes",
      "     np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),   # gene_indices",
      "     ctypes.c_int,                                                     # n_selected_genes",
      "     np.ctypeslib.ndpointer(dtype=np.float64, flags=\"C_CONTIGUOUS\"), # centroid_col (out)",
      "     ctypes.POINTER(ctypes.c_int)                                      # ierr",
      "   ]",
      "   lib.mean_vector_c.restype = None",
      "   lib.mean_vector_c(expression_vectors, n_axes, n_genes, gene_indices, n_selected_genes, centroid_col, ierr)"
      ],
      "description": "Setup mean_vector_c function binding for Python/ctypes."
  },
  "C: Call to group_centroid": {
      "prefix": "tox:setup_py_group_centroid_c",
      "body": [
      "   lib.group_centroid_c.argtypes = [",
      "     np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"), # expression_vectors",
      "     ctypes.c_int,                                                     # n_axes",
      "     ctypes.c_int,                                                     # n_genes",
      "     np.ctypeslib.ndpointer(dtype=np.int32, flags=\"C_CONTIGUOUS\"),   # gene_to_family",
      "     ctypes.c_int,                                                     # n_families",
      "     np.ctypeslib.ndpointer(dtype=np.float64, flags=\"F_CONTIGUOUS\"), # centroid_matrix (out)",
      "     ctypes.c_int,                                                     # use_all_mode (as int)",
      "     np.ctypeslib.ndpointer(dtype=np.int32, flags=\"F_CONTIGUOUS\"),   # ortholog_set (as int array)",
      "     np.ctypeslib.ndpointer(dtype=np.int32, flags=\"F_CONTIGUOUS\"),   # selected_indices",
      "     ctypes.c_int,                                                     # selected_indices_len",
      "     ctypes.POINTER(ctypes.c_int)                                      # ierr",
      "   ]",
      "   lib.group_centroid_c.restype = None",
      "   lib.group_centroid_c(expression_vectors, n_axes, n_genes, gene_to_family, n_families, centroid_matrix, &",
      "                                  use_all_mode, ortholog_set, selected_indices, selected_indices_len, ierr)"
      ],
      "description": "Setup group_centroid_c function binding for Python/ctypes."
  },
  "R: Call mean_vector": {
      "prefix": "tox:R_mean_vector",
      "body": [
          "result <- .Fortran(\"mean_vector_r\",",
          "    expression_vectors = as.double(expression_vectors),",
          "    n_axes = as.integer(n_axes),",
          "    n_genes = as.integer(n_genes),",
          "    gene_indices = as.integer(gene_indices),",
          "    n_selected_genes = as.integer(n_selected_genes),",
          "    centroid_col = centroid_col,",
          "    ierr = as.integer(0)"
      ],
      "description": "Call the mean_vector_r Fortran function from R."
  },
  "R: Call group_centroid": {
      "prefix": "tox:R_group_centroid",
      "body": [
          "result <- .Fortran(\"group_centroid_r\",",
          "    expression_vectors = as.double(expression_vectors),",
          "    n_axes = as.integer(n_axes),",
          "    n_genes = as.integer(n_genes),",
          "    gene_to_family = as.integer(gene_to_family),",
          "    num_families = as.integer(num_families),",
          "    centroid_matrix = centroid_matrix_out,",
          "    use_all_mode = as.logical(TRUE),",
          "    ortholog_set = as.logical(ortholog_set),",
          "    selected_indices = selected_indices,",
          "    selected_indices_len = as.integer(n_genes),",
          "    ierr = as.integer(0)"
      ],
      "description": "Call the group_centroid_r Fortran function from R."
  },
  "tox:set_ok": {
    "prefix": "tox:set_ok",
    "body": [
      "! Set error code to 0 (Success)",
      "call set_ok(ierr)"
    ],
    "description": "Set error code to 0 (Success)"
  },
  "tox:set_could_not_open_file": {
    "prefix": "tox:set_could_not_open_file",
    "body": [
      "! Set error code to 101 (Could not open file)",
      "call set_err_once(ierr, ERR_FILE_OPEN)"
    ],
    "description": "Set error code to 101 (Could not open file)"
  },
  "tox:set_could_not_read_magic": {
    "prefix": "tox:set_could_not_read_magic",
    "body": [
      "! Set error code to 102 (Could not read magic number)",
      "call set_err_once(ierr, ERR_READ_MAGIC)"
    ],
    "description": "Set error code to 102 (Could not read magic number)"
  },
  "tox:set_could_not_read_type_code": {
    "prefix": "tox:set_could_not_read_type_code",
    "body": [
      "! Set error code to 103 (Could not read type code)",
      "call set_err_once(ierr, ERR_READ_TYPE)"
    ],
    "description": "Set error code to 103 (Could not read type code)"
  },
  "tox:set_could_not_read_ndims": {
    "prefix": "tox:set_could_not_read_ndims",
    "body": [
      "! Set error code to 104 (Could not read number of dimensions)",
      "call set_err_once(ierr, ERR_READ_NDIMS)"
    ],
    "description": "Set error code to 104 (Could not read number of dimensions)"
  },
  "tox:set_could_not_read_dims": {
    "prefix": "tox:set_could_not_read_dims",
    "body": [
      "! Set error code to 105 (Could not read array dimensions)",
      "call set_err_once(ierr, ERR_READ_DIMS)"
    ],
    "description": "Set error code to 105 (Could not read array dimensions)"
  },
  "tox:set_could_not_read_charlen": {
    "prefix": "tox:set_could_not_read_charlen",
    "body": [
      "! Set error code to 106 (Could not read character length)",
      "call set_err_once(ierr, ERR_READ_CHARLEN)"
    ],
    "description": "Set error code to 106 (Could not read character length)"
  },
  "tox:set_could_not_read_data": {
    "prefix": "tox:set_could_not_read_data",
    "body": [
      "! Set error code to 107 (Could not read array data)",
      "call set_err_once(ierr, ERR_READ_DATA)"
    ],
    "description": "Set error code to 107 (Could not read array data)"
  },
  "tox:set_invalid_format": {
    "prefix": "tox:set_invalid_format",
    "body": [
      "! Set error code to 200 (Invalid format)",
      "call set_err_once(ierr, ERR_INVALID_FORMAT)"
    ],
    "description": "Set error code to 200 (Invalid format)"
  },
  "tox:set_invalid_input": {
    "prefix": "tox:set_invalid_input",
    "body": [
      "! Set error code to 201 (Invalid input)",
      "call set_err_once(ierr, ERR_INVALID_INPUT)"
    ],
    "description": "Set error code to 201 (Invalid input)"
  },
  "tox:set_empty_input": {
    "prefix": "tox:set_empty_input",
    "body": [
      "! Set error code to 202 (Empty input)",
      "call set_err_once(ierr, ERR_EMPTY_INPUT)"
    ],
    "description": "Set error code to 202 (Empty input)"
  },
  "tox:set_dim_mismatch": {
    "prefix": "tox:set_dim_mismatch",
    "body": [
      "! Set error code to 203 (Dimension mismatch)",
      "call set_err_once(ierr, ERR_DIM_MISMATCH)"
    ],
    "description": "Set error code to 203 (Dimension mismatch)"
  },
  "tox:set_nan_inf_found": {
    "prefix": "tox:set_nan_inf_found",
    "body": [
      "! Set error code to 204 (NaN or Inf found)",
      "call set_err_once(ierr, ERR_NAN_INF)"
    ],
    "description": "Set error code to 204 (NaN or Inf found)"
  },
  "tox:set_unsupported_type": {
    "prefix": "tox:set_unsupported_type",
    "body": [
      "! Set error code to 205 (Unsupported data type)",
      "call set_err_once(ierr, ERR_UNSUPPORTED_TYPE)"
    ],
    "description": "Set error code to 205 (Unsupported data type)"
  },
  "tox:set_alloc_fail": {
    "prefix": "tox:set_alloc_fail",
    "body": [
      "! Set error code to 301 (Allocation failure)",
      "call set_err_once(ierr, ERR_ALLOC_FAIL)"
    ],
    "description": "Set error code to 301 (Allocation failure)"
  },
  "tox:set_pointer_null": {
    "prefix": "tox:set_pointer_null",
    "body": [
      "! Set error code to 302 (Null pointer reference)",
      "call set_err_once(ierr, ERR_POINTER_NULL)"
    ],
    "description": "Set error code to 302 (Null pointer reference)"
  },
  "tox:set_unit_not_connected": {
    "prefix": "tox:set_unit_not_connected",
    "body": [
      "! Set error code to 5002 (Unit not connected)",
      "call set_err_once(ierr, ERR_UNIT_NOT_CONNECTED)"
    ],
    "description": "Set error code to 5002 (Unit not connected)"
  },
  "tox:set_internal_error": {
    "prefix": "tox:set_internal_error",
    "body": [
      "! Set error code to 9001 (Internal error)",
      "call set_err_once(ierr, ERR_INTERNAL)"
    ],
    "description": "Set error code to 9001 (Internal error)"
  },
  "tox:set_unknown_error": {
    "prefix": "tox:set_unknown_error",
    "body": [
      "! Set error code to 9999 (Unknown error)",
      "call set_err_once(ierr, ERR_UNKNOWN)"
    ],
    "description": "Set error code to 9999 (Unknown error)"
  },
  "tox:check_err_code_r": {
    "prefix": "tox:R_check_err_code",
    "body": [
      "check_err_code <- function(ierr) {",
      "  if (ierr == 0) return(invisible(NULL))",
      "  msg <- switch(as.character(ierr),",
      "    # I/O errors",
      "    '101' = \"Could not open file.\",",
      "    '102' = \"Could not read magic number.\",",
      "    '103' = \"Could not read type code.\",",
      "    '104' = \"Could not read number of dimensions.\",",
      "    '105' = \"Could not read array dimensions\",",
      "    '106' = \"Could not read character length.\",",
      "    '107' = \"Could not read array data.\",",
      "    # ADD MORE HERE",
      "    ",
      "    # FORMAT ERRORS",
      "    '200' = \"Invalid format detected.\",",
      "    '201' = \"Invalid input provided.\",",
      "    '202' = \"Empty input arrays provided.\",",
      "    '203' = \"Dimension mismatch detected.\",",
      "    '204' = \"NaN or Inf found in input data.\",",
      "    '205' = \"Unsupported data type encountered.\",",
      "",
      "    # MEMORY ERRORS",
      "    '301' = \"Memory allocation failed.\",",
      "    '302' = \"Null pointer reference encountered.\",",
      "",
      "    # FORTRAN RUNTIME ERRORS",
      "    '5002' = \"Fortran runtime error: unit not open / not connected.\",",
      "",
      "    # Internal errors",
      "    '9001' = \"Internal error: unexpected state.\",",
      "    '9999' = \"Unknown error.\",",
      "    paste(\"Unmapped error code:\", ierr)",
      "  )",
      "  stop(msg)",
      "}"
    ],
    "description": "R function to check and stop with tox error codes"
  },
  "tox:check_err_code_python": {
    "prefix": "tox:check_err_code_python",
    "body": [
      "def check_err_code(ierr: int) -> None:",
      "    if ierr == 0:",
      "        return",
      "    msg = {",
      "        # I/O errors",
      "        101: \"Could not open file.\",",
      "        102: \"Could not read magic number.\",",
      "        103: \"Could not read type code.\",",
      "        104: \"Could not read number of dimensions.\",",
      "        105: \"Could not read array dimensions.\",",
      "        106: \"Could not read character length.\",",
      "        107: \"Could not read array data.\",",
      "",
      "        # FORMAT ERRORS",
      "        200: \"Invalid format detected.\",",
      "        201: \"Invalid input provided.\",",
      "        202: \"Empty input arrays provided.\",",
      "        203: \"Dimension mismatch detected.\",",
      "        204: \"NaN or Inf found in input data.\",",
      "        205: \"Unsupported data type encountered.\",",
      "",
      "        # MEMORY ERRORS",
      "        301: \"Memory allocation failed.\",",
      "        302: \"Null pointer reference encountered.\",",
      "",
      "        # FORTRAN RUNTIME ERRORS",
      "        5002: \"Fortran runtime error: unit not open / not connected.\",",
      "",
      "        # Internal errors",
      "        9001: \"Internal error: unexpected state.\",",
      "        9999: \"Unknown error.\",",
      "    }.get(ierr, f\"Unmapped error code: {ierr}\")",
      "    raise RuntimeError(msg)"
    ],
    "description": "Python function to check and raise error messages for tox error codes"
  }

}